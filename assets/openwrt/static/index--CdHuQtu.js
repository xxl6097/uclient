var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_index_001 = __commonJS({
  "index--CdHuQtu.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity)
          fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy)
          fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    /**
    * @vue/shared v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$e = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$e.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap$1 = (val) => toTypeString(val) === "[object Map]";
    const isSet$1 = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$2 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s2 = str ? `on${capitalize(str)}` : ``;
      return s2;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$1(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$1(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$1(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a2, b2) {
      if (a2.length !== b2.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a2.length; i++) {
        equal = looseEqual(a2[i], b2[i]);
      }
      return equal;
    }
    function looseEqual(a2, b2) {
      if (a2 === b2)
        return true;
      let aValidType = isDate(a2);
      let bValidType = isDate(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
      }
      aValidType = isSymbol$1(a2);
      bValidType = isSymbol$1(b2);
      if (aValidType || bValidType) {
        return a2 === b2;
      }
      aValidType = isArray$1(a2);
      bValidType = isArray$1(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
      }
      aValidType = isObject$1(a2);
      bValidType = isObject$1(b2);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a2).length;
        const bKeysCount = Object.keys(b2).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a2) {
          const aHasKey = a2.hasOwnProperty(key);
          const bHasKey = b2.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
            return false;
          }
        }
      }
      return String(a2) === String(b2);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const toDisplayString = (val) => {
      return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap$1(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet$1(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v2, i = "") => {
      var _a2;
      return isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i})` : v2;
    };
    /**
    * @vue/reactivity v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l2;
          for (i = 0, l2 = this.effects.length; i < l2; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l2 = this.scopes.length; i < l2; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn2) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn2);
      }
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn2, trigger2, scheduler, scope) {
        this.fn = fn2;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 2;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
      }
      get dirty() {
        if (this._dirtyLevel === 1) {
          pauseTracking();
          for (let i = 0; i < this._depsLength; i++) {
            const dep = this.deps[i];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 2) {
                break;
              }
            }
          }
          if (this._dirtyLevel < 2) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 2;
      }
      set dirty(v2) {
        this._dirtyLevel = v2 ? 2 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        var _a2;
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps && effect2.deps.length > effect2._depsLength) {
        for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
          cleanupDepEffect(effect2.deps[i], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        if (effect2._dirtyLevel < dirtyLevel && dep.get(effect2) === effect2._trackId) {
          const lastDirtyLevel = effect2._dirtyLevel;
          effect2._dirtyLevel = dirtyLevel;
          if (lastDirtyLevel === 0) {
            effect2._shouldSchedule = true;
            effect2.trigger();
          }
        }
      }
      scheduleEffects(dep);
      resetScheduling();
    }
    function scheduleEffects(dep) {
      for (const effect2 of dep.keys()) {
        if (effect2.scheduler && effect2._shouldSchedule && (!effect2._runnings || effect2.allowRecurse) && dep.get(effect2) === effect2._trackId) {
          effect2._shouldSchedule = false;
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$1(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            2
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object, key) {
      var _a2;
      return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l2 = this.length; i < l2; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$d(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$d;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._shallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const toShallow = (value) => value;
    const getProto = (v2) => Reflect.getPrototypeOf(v2);
    function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$1(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$1(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$1(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$1(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(this, 1),
          () => this.dep && scheduleEffects(this.dep)
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if (!self2._cacheable || self2.effect.dirty) {
          if (hasChanged(self2._value, self2._value = self2.effect.run())) {
            triggerRefValue(self2, 2);
          }
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 1) {
          triggerRefValue(self2, 1);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v2) {
        this.effect.dirty = v2;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$2(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          ref2.dep || (ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          ))
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 2, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 2);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object) {
      const ret = isArray$1(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$2(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    /**
    * @vue/runtime-core v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function warn$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$1(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$2(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn2, instance, type, args) {
      let res;
      try {
        res = args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$2(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values = [];
      for (let i = 0; i < fn2.length; i++) {
        values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
      }
      return values;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$1(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a2, b2) => getId(a2) - getId(b2)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a2, b2) => {
      const diff = getId(a2) - getId(b2);
      if (diff === 0) {
        if (a2.pre && !b2.pre)
          return -1;
        if (b2.pre && !a2.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id) {
      currentScopeId = id;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$1(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
        getter = () => source.map((s2) => {
          if (isRef(s2)) {
            return s2.value;
          } else if (isReactive(s2)) {
            return reactiveGetter(s2);
          } else if (isFunction$2(s2)) {
            return callWithErrorHandling(s2, instance, 2);
          } else
            ;
        });
      } else if (isFunction$2(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope = getCurrentScope();
      const unwatch = () => {
        effect2.stop();
        if (scope) {
          remove(scope.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$2(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, depth, currentDepth = 0, seen) {
      if (!isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      if (depth && depth > 0) {
        if (currentDepth >= depth) {
          return value;
        }
        currentDepth++;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, depth, currentDepth, seen);
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, currentDepth, seen);
        }
      } else if (isSet$1(value) || isMap$1(value)) {
        value.forEach((v2) => {
          traverse(v2, depth, currentDepth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, currentDepth, seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$2(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c2 of children) {
              if (c2.type !== Comment) {
                child = c2;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? (
        // #7121 ensure get the child component subtree in case
        // it's been replaced during HMR
        vnode.children ? vnode.children[0] : void 0
      ) : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$2(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      if (isArray$1(source) || isString$1(source)) {
        ret = new Array(source.length);
        for (let i = 0, l2 = source.length; i < l2; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached && cached[i])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i = 0, l2 = keys2.length; i < l2; i++) {
            const key = keys2[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        if (isArray$1(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          i.effect.dirty = true;
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs$1() {
      return getContext().attrs;
    }
    function getContext() {
      const i = getCurrentInstance();
      return i.setupContext || (i.setupContext = createSetupContext(i));
    }
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$2(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v2) => c2.value = v2
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v2) => injected.value = v2
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$1(raw)) {
        const handler = ctx[raw];
        if (isFunction$2(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$2(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$1(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$2(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
          );
        }
        mergeOptions$1(resolved, base, optionMergeStrategies);
      }
      if (isObject$1(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions$1(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$1(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m2) => mergeOptions$1(to, m2, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$2(to) ? to.call(this, this) : to,
          isFunction$2(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$1(to) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$2(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v2) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$2(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$2(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else
              ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn2) {
            currentApp = app2;
            try {
              return fn2();
            } finally {
              currentApp = null;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent2) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent2 && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match ? match[2] : ctor === null ? "null" : "";
    }
    function isSameType(a2, b2) {
      return getType(a2) === getType(b2);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$1(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$2(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$2(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          instance.slots = toRaw(children);
          def(children, "_", type);
        } else {
          normalizeObjectSlots(
            children,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$1(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$2(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$1(ref3);
        const _isRef = isRef(ref3);
        const isVFor = rawRef.f;
        if (_isString || _isRef) {
          const doSet = () => {
            if (isVFor) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (isUnmount || isVFor) {
            doSet();
          } else {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text$1:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    namespace,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m: m2, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m2) {
              queuePostRenderEffect(m2, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u: u2, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u2) {
              queuePostRenderEffect(u2, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render2 = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text$1) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u2, v2, c2;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u2 = 0;
          v2 = result.length - 1;
          while (u2 < v2) {
            c2 = u2 + v2 >> 1;
            if (arr[result[c2]] < arrI) {
              u2 = c2 + 1;
            } else {
              v2 = c2;
            }
          }
          if (arrI < arr[result[u2]]) {
            if (u2 > 0) {
              p2[i] = result[u2 - 1];
            }
            result[u2] = i;
          }
        }
      }
      u2 = result.length;
      v2 = result[u2 - 1];
      while (u2-- > 0) {
        result[u2] = v2;
        v2 = p2[v2];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$1(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text$1 = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$1(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style)) {
          if (isProxy(style) && !isArray$1(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$2(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text$1, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text$1, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$2(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key]))
          setters = g[key] = [];
        setters.push(setter);
        return (v2) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v2));
          else
            setters[0](v2);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v2) => currentInstance = v2
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v2) => isInSSRComponentSetup = v2
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$2(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend(
              extend(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            track(instance, "get", "$attrs");
            return target[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$2(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h$1(type, propsOrChildren, children) {
      const l2 = arguments.length;
      if (l2 === 2) {
        if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l2 > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l2 === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version = "3.4.15";
    const warn = NOOP;
    /**
    * @vue/runtime-dom v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$1(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
    }
    function toMs(s2) {
      if (s2 === "auto")
        return 0;
      return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOldKey] : "none";
    }
    const CSS_VAR_TEXT = Symbol("");
    function patchStyle(el, prev, next) {
      const style = el.style;
      const currentDisplay = style.display;
      const isCssString = isString$1(next);
      if (next && !isCssString) {
        if (prev && !isString$1(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next) {
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOldKey in el) {
        style.display = currentDisplay;
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$1(val)) {
        val.forEach((v2) => setStyle(style, name, v2));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m2;
        while (m2 = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m2[0].length);
          options[m2[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p$1 = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$2(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$1(value)) {
        return false;
      }
      return key in el;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el = c2.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el = c2.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s2 = c2.el.style;
        s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
        s2.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
      clone2.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _2, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$2(el);
          const checked = el.checked;
          const assign = el[assignKey];
          if (isArray$1(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet$1(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray$1(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet$1(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
    }
    function getValue$2(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
    };
    const withModifiers = (fn2, modifiers) => {
      const cache = fn2._withMods || (fn2._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn2(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      const cache = fn2._withKeys || (fn2._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn2(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app2._component;
        if (!isFunction$2(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$1(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
    const isVisible = (element) => {
      const computed2 = getComputedStyle(element);
      return computed2.position === "fixed" ? false : element.offsetParent !== null;
    };
    const obtainAllFocusableElements$1 = (element) => {
      return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
    };
    const isFocusable = (element) => {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.disabled) {
        return false;
      }
      switch (element.nodeName) {
        case "A": {
          return !!element.href && element.rel !== "ignore";
        }
        case "INPUT": {
          return !(element.type === "hidden" || element.type === "file");
        }
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA": {
          return true;
        }
        default: {
          return false;
        }
      }
    };
    const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
      const handleEvent = (event) => {
        const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
        if (checkForDefaultPrevented === false || !shouldPrevent) {
          return oursHandler == null ? void 0 : oursHandler(event);
        }
      };
      return handleEvent;
    };
    const whenMouse = (handler) => {
      return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
    };
    var _a;
    const isClient = typeof window !== "undefined";
    const isDef = (val) => typeof val !== "undefined";
    const isFunction$1 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const noop = () => {
    };
    const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
    function resolveUnref(r) {
      return typeof r === "function" ? r() : unref(r);
    }
    function createFilterWrapper(filter, fn2) {
      function wrapper(...args) {
        return new Promise((resolve2, reject) => {
          Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
        });
      }
      return wrapper;
    }
    const bypassFilter = (invoke) => {
      return invoke();
    };
    function debounceFilter(ms, options = {}) {
      let timer;
      let maxTimer;
      let lastRejector = noop;
      const _clearTimeout = (timer2) => {
        clearTimeout(timer2);
        lastRejector();
        lastRejector = noop;
      };
      const filter = (invoke) => {
        const duration = resolveUnref(ms);
        const maxDuration = resolveUnref(options.maxWait);
        if (timer)
          _clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
          if (maxTimer) {
            _clearTimeout(maxTimer);
            maxTimer = null;
          }
          return Promise.resolve(invoke());
        }
        return new Promise((resolve2, reject) => {
          lastRejector = options.rejectOnCancel ? reject : resolve2;
          if (maxDuration && !maxTimer) {
            maxTimer = setTimeout(() => {
              if (timer)
                _clearTimeout(timer);
              maxTimer = null;
              resolve2(invoke());
            }, maxDuration);
          }
          timer = setTimeout(() => {
            if (maxTimer)
              _clearTimeout(maxTimer);
            maxTimer = null;
            resolve2(invoke());
          }, duration);
        });
      };
      return filter;
    }
    function pausableFilter(extendFilter = bypassFilter) {
      const isActive = ref(true);
      function pause() {
        isActive.value = false;
      }
      function resume() {
        isActive.value = true;
      }
      const eventFilter = (...args) => {
        if (isActive.value)
          extendFilter(...args);
      };
      return { isActive: readonly(isActive), pause, resume, eventFilter };
    }
    function identity$1(arg) {
      return arg;
    }
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function useDebounceFn(fn2, ms = 200, options = {}) {
      return createFilterWrapper(debounceFilter(ms, options), fn2);
    }
    function refDebounced(value, ms = 200, options = {}) {
      const debounced = ref(value.value);
      const updater = useDebounceFn(() => {
        debounced.value = value.value;
      }, ms, options);
      watch(value, () => updater());
      return debounced;
    }
    function resolveRef(r) {
      return typeof r === "function" ? computed(r) : ref(r);
    }
    function tryOnMounted(fn2, sync = true) {
      if (getCurrentInstance())
        onMounted(fn2);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function useTimeoutFn(cb, interval, options = {}) {
      const {
        immediate = true
      } = options;
      const isPending = ref(false);
      let timer = null;
      function clear2() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }
      function stop() {
        isPending.value = false;
        clear2();
      }
      function start(...args) {
        clear2();
        isPending.value = true;
        timer = setTimeout(() => {
          isPending.value = false;
          timer = null;
          cb(...args);
        }, resolveUnref(interval));
      }
      if (immediate) {
        isPending.value = true;
        if (isClient)
          start();
      }
      tryOnScopeDispose(stop);
      return {
        isPending: readonly(isPending),
        start,
        stop
      };
    }
    function useToggle(initialValue = false, options = {}) {
      const {
        truthyValue = true,
        falsyValue = false
      } = options;
      const valueIsRef = isRef(initialValue);
      const _value = ref(initialValue);
      function toggle(value) {
        if (arguments.length) {
          _value.value = value;
          return _value.value;
        } else {
          const truthy = resolveUnref(truthyValue);
          _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;
          return _value.value;
        }
      }
      if (valueIsRef)
        return toggle;
      else
        return [_value, toggle];
    }
    var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
    var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
    var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
    var __objRest$5 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$6)
        for (var prop of __getOwnPropSymbols$6(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function watchWithFilter(source, cb, options = {}) {
      const _a2 = options, {
        eventFilter = bypassFilter
      } = _a2, watchOptions = __objRest$5(_a2, [
        "eventFilter"
      ]);
      return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
    }
    var __defProp$2 = Object.defineProperty;
    var __defProps$2 = Object.defineProperties;
    var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
    var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
    var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$2 = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$2.call(b2, prop))
          __defNormalProp$2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$2)
        for (var prop of __getOwnPropSymbols$2(b2)) {
          if (__propIsEnum$2.call(b2, prop))
            __defNormalProp$2(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
    var __objRest$1$1 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$2)
        for (var prop of __getOwnPropSymbols$2(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function watchPausable(source, cb, options = {}) {
      const _a2 = options, {
        eventFilter: filter
      } = _a2, watchOptions = __objRest$1$1(_a2, [
        "eventFilter"
      ]);
      const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
      const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
        eventFilter
      }));
      return { stop, pause, resume, isActive };
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = resolveUnref(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    function useEventListener(...args) {
      let target;
      let events;
      let listeners;
      let options;
      if (isString(args[0]) || Array.isArray(args[0])) {
        [events, listeners, options] = args;
        target = defaultWindow;
      } else {
        [target, events, listeners, options] = args;
      }
      if (!target)
        return noop;
      if (!Array.isArray(events))
        events = [events];
      if (!Array.isArray(listeners))
        listeners = [listeners];
      const cleanups = [];
      const cleanup = () => {
        cleanups.forEach((fn2) => fn2());
        cleanups.length = 0;
      };
      const register = (el, event, listener, options2) => {
        el.addEventListener(event, listener, options2);
        return () => el.removeEventListener(event, listener, options2);
      };
      const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
        cleanup();
        if (!el)
          return;
        cleanups.push(...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        }));
      }, { immediate: true, flush: "post" });
      const stop = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop);
      return stop;
    }
    let _iOSWorkaround = false;
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
      if (!window2)
        return;
      if (isIOS && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
      }
      let shouldListen = true;
      const shouldIgnore = (event) => {
        return ignore.some((target2) => {
          if (typeof target2 === "string") {
            return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
          } else {
            const el = unrefElement(target2);
            return el && (event.target === el || event.composedPath().includes(el));
          }
        });
      };
      const listener = (event) => {
        const el = unrefElement(target);
        if (!el || el === event.target || event.composedPath().includes(el))
          return;
        if (event.detail === 0)
          shouldListen = !shouldIgnore(event);
        if (!shouldListen) {
          shouldListen = true;
          return;
        }
        handler(event);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e) => {
          const el = unrefElement(target);
          if (el)
            shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event) => {
          var _a2;
          const el = unrefElement(target);
          if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
            handler(event);
        })
      ].filter(Boolean);
      const stop = () => cleanup.forEach((fn2) => fn2());
      return stop;
    }
    function useSupported(callback, sync = false) {
      const isSupported = ref();
      const update = () => isSupported.value = Boolean(callback());
      update();
      tryOnMounted(update, sync);
      return isSupported;
    }
    function useMediaQuery(query, options = {}) {
      const { window: window2 = defaultWindow } = options;
      const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
      let mediaQuery;
      const matches = ref(false);
      const cleanup = () => {
        if (!mediaQuery)
          return;
        if ("removeEventListener" in mediaQuery)
          mediaQuery.removeEventListener("change", update);
        else
          mediaQuery.removeListener(update);
      };
      const update = () => {
        if (!isSupported.value)
          return;
        cleanup();
        mediaQuery = window2.matchMedia(resolveRef(query).value);
        matches.value = mediaQuery.matches;
        if ("addEventListener" in mediaQuery)
          mediaQuery.addEventListener("change", update);
        else
          mediaQuery.addListener(update);
      };
      watchEffect(update);
      tryOnScopeDispose(() => cleanup());
      return matches;
    }
    function cloneFnJSON(source) {
      return JSON.parse(JSON.stringify(source));
    }
    const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    _global[globalKey] = _global[globalKey] || {};
    const handlers = _global[globalKey];
    function getSSRHandler(key, fallback) {
      return handlers[key] || fallback;
    }
    function guessSerializerType(rawInit) {
      return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
    }
    var __defProp$k = Object.defineProperty;
    var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
    var __hasOwnProp$m = Object.prototype.hasOwnProperty;
    var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$k = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$m.call(b2, prop))
          __defNormalProp$k(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$m)
        for (var prop of __getOwnPropSymbols$m(b2)) {
          if (__propIsEnum$m.call(b2, prop))
            __defNormalProp$k(a2, prop, b2[prop]);
        }
      return a2;
    };
    const StorageSerializers = {
      boolean: {
        read: (v2) => v2 === "true",
        write: (v2) => String(v2)
      },
      object: {
        read: (v2) => JSON.parse(v2),
        write: (v2) => JSON.stringify(v2)
      },
      number: {
        read: (v2) => Number.parseFloat(v2),
        write: (v2) => String(v2)
      },
      any: {
        read: (v2) => v2,
        write: (v2) => String(v2)
      },
      string: {
        read: (v2) => v2,
        write: (v2) => String(v2)
      },
      map: {
        read: (v2) => new Map(JSON.parse(v2)),
        write: (v2) => JSON.stringify(Array.from(v2.entries()))
      },
      set: {
        read: (v2) => new Set(JSON.parse(v2)),
        write: (v2) => JSON.stringify(Array.from(v2))
      },
      date: {
        read: (v2) => new Date(v2),
        write: (v2) => v2.toISOString()
      }
    };
    const customStorageEventName = "vueuse-storage";
    function useStorage(key, defaults, storage, options = {}) {
      var _a2;
      const {
        flush = "pre",
        deep = true,
        listenToStorageChanges = true,
        writeDefaults = true,
        mergeDefaults = false,
        shallow,
        window: window2 = defaultWindow,
        eventFilter,
        onError = (e) => {
          console.error(e);
        }
      } = options;
      const data = (shallow ? shallowRef : ref)(defaults);
      if (!storage) {
        try {
          storage = getSSRHandler("getDefaultStorage", () => {
            var _a22;
            return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
          })();
        } catch (e) {
          onError(e);
        }
      }
      if (!storage)
        return data;
      const rawInit = resolveUnref(defaults);
      const type = guessSerializerType(rawInit);
      const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
      const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
      if (window2 && listenToStorageChanges) {
        useEventListener(window2, "storage", update);
        useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      }
      update();
      return data;
      function write(v2) {
        try {
          if (v2 == null) {
            storage.removeItem(key);
          } else {
            const serialized = serializer.write(v2);
            const oldValue = storage.getItem(key);
            if (oldValue !== serialized) {
              storage.setItem(key, serialized);
              if (window2) {
                window2.dispatchEvent(new CustomEvent(customStorageEventName, {
                  detail: {
                    key,
                    oldValue,
                    newValue: serialized,
                    storageArea: storage
                  }
                }));
              }
            }
          }
        } catch (e) {
          onError(e);
        }
      }
      function read(event) {
        const rawValue = event ? event.newValue : storage.getItem(key);
        if (rawValue == null) {
          if (writeDefaults && rawInit !== null)
            storage.setItem(key, serializer.write(rawInit));
          return rawInit;
        } else if (!event && mergeDefaults) {
          const value = serializer.read(rawValue);
          if (isFunction$1(mergeDefaults))
            return mergeDefaults(value, rawInit);
          else if (type === "object" && !Array.isArray(value))
            return __spreadValues$k(__spreadValues$k({}, rawInit), value);
          return value;
        } else if (typeof rawValue !== "string") {
          return rawValue;
        } else {
          return serializer.read(rawValue);
        }
      }
      function updateFromCustomEvent(event) {
        update(event.detail);
      }
      function update(event) {
        if (event && event.storageArea !== storage)
          return;
        if (event && event.key == null) {
          data.value = rawInit;
          return;
        }
        if (event && event.key !== key)
          return;
        pauseWatch();
        try {
          data.value = read(event);
        } catch (e) {
          onError(e);
        } finally {
          if (event)
            nextTick(resumeWatch);
          else
            resumeWatch();
        }
      }
    }
    function usePreferredDark(options) {
      return useMediaQuery("(prefers-color-scheme: dark)", options);
    }
    var __defProp$j = Object.defineProperty;
    var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
    var __hasOwnProp$l = Object.prototype.hasOwnProperty;
    var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$j = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$l.call(b2, prop))
          __defNormalProp$j(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$l)
        for (var prop of __getOwnPropSymbols$l(b2)) {
          if (__propIsEnum$l.call(b2, prop))
            __defNormalProp$j(a2, prop, b2[prop]);
        }
      return a2;
    };
    function useColorMode(options = {}) {
      const {
        selector = "html",
        attribute = "class",
        initialValue = "auto",
        window: window2 = defaultWindow,
        storage,
        storageKey = "vueuse-color-scheme",
        listenToStorageChanges = true,
        storageRef,
        emitAuto
      } = options;
      const modes = __spreadValues$j({
        auto: "",
        light: "light",
        dark: "dark"
      }, options.modes || {});
      const preferredDark = usePreferredDark({ window: window2 });
      const preferredMode = computed(() => preferredDark.value ? "dark" : "light");
      const store = storageRef || (storageKey == null ? ref(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
      const state = computed({
        get() {
          return store.value === "auto" && !emitAuto ? preferredMode.value : store.value;
        },
        set(v2) {
          store.value = v2;
        }
      });
      const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value) => {
        const el = window2 == null ? void 0 : window2.document.querySelector(selector2);
        if (!el)
          return;
        if (attribute2 === "class") {
          const current = value.split(/\s/g);
          Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
            if (current.includes(v2))
              el.classList.add(v2);
            else
              el.classList.remove(v2);
          });
        } else {
          el.setAttribute(attribute2, value);
        }
      });
      function defaultOnChanged(mode) {
        var _a2;
        const resolvedMode = mode === "auto" ? preferredMode.value : mode;
        updateHTMLAttrs(selector, attribute, (_a2 = modes[resolvedMode]) != null ? _a2 : resolvedMode);
      }
      function onChanged(mode) {
        if (options.onChanged)
          options.onChanged(mode, defaultOnChanged);
        else
          defaultOnChanged(mode);
      }
      watch(state, onChanged, { flush: "post", immediate: true });
      if (emitAuto)
        watch(preferredMode, () => onChanged(state.value), { flush: "post" });
      tryOnMounted(() => onChanged(state.value));
      return state;
    }
    var __defProp$i = Object.defineProperty;
    var __defProps$7 = Object.defineProperties;
    var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
    var __hasOwnProp$k = Object.prototype.hasOwnProperty;
    var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$i = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$k.call(b2, prop))
          __defNormalProp$i(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$k)
        for (var prop of __getOwnPropSymbols$k(b2)) {
          if (__propIsEnum$k.call(b2, prop))
            __defNormalProp$i(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps$7 = (a2, b2) => __defProps$7(a2, __getOwnPropDescs$7(b2));
    function useDark(options = {}) {
      const {
        valueDark = "dark",
        valueLight = "",
        window: window2 = defaultWindow
      } = options;
      const mode = useColorMode(__spreadProps$7(__spreadValues$i({}, options), {
        onChanged: (mode2, defaultHandler) => {
          var _a2;
          if (options.onChanged)
            (_a2 = options.onChanged) == null ? void 0 : _a2.call(options, mode2 === "dark");
          else
            defaultHandler(mode2);
        },
        modes: {
          dark: valueDark,
          light: valueLight
        }
      }));
      const preferredDark = usePreferredDark({ window: window2 });
      const isDark = computed({
        get() {
          return mode.value === "dark";
        },
        set(v2) {
          if (v2 === preferredDark.value)
            mode.value = "auto";
          else
            mode.value = v2 ? "dark" : "light";
        }
      });
      return isDark;
    }
    var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
    var __hasOwnProp$g = Object.prototype.hasOwnProperty;
    var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
    var __objRest$2 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$g)
        for (var prop of __getOwnPropSymbols$g(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useResizeObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
      let observer;
      const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported.value && window2 && el) {
          observer = new ResizeObserver(callback);
          observer.observe(el, observerOptions);
        }
      }, { immediate: true, flush: "post" });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
    var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
    var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
    var __objRest$1 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$8)
        for (var prop of __getOwnPropSymbols$8(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useMutationObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
      let observer;
      const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported.value && window2 && el) {
          observer = new MutationObserver(callback);
          observer.observe(el, mutationOptions);
        }
      }, { immediate: true });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    var SwipeDirection;
    (function(SwipeDirection2) {
      SwipeDirection2["UP"] = "UP";
      SwipeDirection2["RIGHT"] = "RIGHT";
      SwipeDirection2["DOWN"] = "DOWN";
      SwipeDirection2["LEFT"] = "LEFT";
      SwipeDirection2["NONE"] = "NONE";
    })(SwipeDirection || (SwipeDirection = {}));
    var __defProp2 = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b2)) {
          if (__propIsEnum.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        }
      return a2;
    };
    const _TransitionPresets = {
      easeInSine: [0.12, 0, 0.39, 0],
      easeOutSine: [0.61, 1, 0.88, 1],
      easeInOutSine: [0.37, 0, 0.63, 1],
      easeInQuad: [0.11, 0, 0.5, 0],
      easeOutQuad: [0.5, 1, 0.89, 1],
      easeInOutQuad: [0.45, 0, 0.55, 1],
      easeInCubic: [0.32, 0, 0.67, 0],
      easeOutCubic: [0.33, 1, 0.68, 1],
      easeInOutCubic: [0.65, 0, 0.35, 1],
      easeInQuart: [0.5, 0, 0.75, 0],
      easeOutQuart: [0.25, 1, 0.5, 1],
      easeInOutQuart: [0.76, 0, 0.24, 1],
      easeInQuint: [0.64, 0, 0.78, 0],
      easeOutQuint: [0.22, 1, 0.36, 1],
      easeInOutQuint: [0.83, 0, 0.17, 1],
      easeInExpo: [0.7, 0, 0.84, 0],
      easeOutExpo: [0.16, 1, 0.3, 1],
      easeInOutExpo: [0.87, 0, 0.13, 1],
      easeInCirc: [0.55, 0, 1, 0.45],
      easeOutCirc: [0, 0.55, 0.45, 1],
      easeInOutCirc: [0.85, 0, 0.15, 1],
      easeInBack: [0.36, 0, 0.66, -0.56],
      easeOutBack: [0.34, 1.56, 0.64, 1],
      easeInOutBack: [0.68, -0.6, 0.32, 1.6]
    };
    __spreadValues({
      linear: identity$1
    }, _TransitionPresets);
    function useVModel(props, key, emit2, options = {}) {
      var _a2, _b, _c;
      const {
        clone: clone2 = false,
        passive = false,
        eventName,
        deep = false,
        defaultValue
      } = options;
      const vm = getCurrentInstance();
      const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
      let event = eventName;
      if (!key) {
        {
          key = "modelValue";
        }
      }
      event = eventName || event || `update:${key.toString()}`;
      const cloneFn = (val) => !clone2 ? val : isFunction$1(clone2) ? clone2(val) : cloneFnJSON(val);
      const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
      if (passive) {
        const initialValue = getValue2();
        const proxy = ref(initialValue);
        watch(() => props[key], (v2) => proxy.value = cloneFn(v2));
        watch(proxy, (v2) => {
          if (v2 !== props[key] || deep)
            _emit(event, v2);
        }, { deep });
        return proxy;
      } else {
        return computed({
          get() {
            return getValue2();
          },
          set(value) {
            _emit(event, value);
          }
        });
      }
    }
    const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$f.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$e = Object.prototype;
    var nativeObjectToString = objectProto$e.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var INFINITY$2 = 1 / 0;
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index = string2.length;
      while (index-- && reWhitespace.test(string2.charAt(index))) {
      }
      return index;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$1 || value === -INFINITY$1) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root, "WeakMap");
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var setToString = shortOut(baseSetToString$1);
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$c = Object.prototype;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax$2 = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax$2(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$b = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$a = Object.prototype;
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$7.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    var objectTag$3 = "[object Object]";
    var funcProto = Function.prototype, objectProto$4 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype$1(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype$1(object);
      }
      return result;
    };
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$4;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$4;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    var Uint8Array2 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object);
        case boolTag$2:
        case dateTag$2:
          return new Ctor(+object);
        case dataViewTag$2:
          return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object, isDeep);
        case mapTag$3:
          return new Ctor();
        case numberTag$2:
        case stringTag$2:
          return new Ctor(object);
        case regexpTag$2:
          return cloneRegExp(object);
        case setTag$3:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object);
      }
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
    }
    var mapTag$2 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$2;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$2 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$2;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
      if (customizer) {
        result = object ? customizer(value, key, object, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    var CLONE_SYMBOLS_FLAG$1 = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG$1);
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack2.set(array, other);
      stack2.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array);
      stack2["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack2.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack2.set(object, other);
      stack2.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object);
      stack2["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack2 = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    var now = function() {
      return root.Date.now();
    };
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var nativeMax = Math.max, nativeMin = Math.min;
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== void 0) {
        index = toInteger(fromIndex);
        index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, baseIteratee(predicate), index, true);
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee));
    }
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }
    function fromPairs(pairs) {
      var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isNil(value) {
      return value == null;
    }
    function isUndefined$1(value) {
      return value === void 0;
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    const merge$1 = merge;
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    const isUndefined = (val) => val === void 0;
    const isBoolean = (val) => typeof val === "boolean";
    const isNumber = (val) => typeof val === "number";
    const isElement = (e) => {
      if (typeof Element === "undefined")
        return false;
      return e instanceof Element;
    };
    const isStringNumber = (val) => {
      if (!isString$1(val)) {
        return false;
      }
      return !Number.isNaN(Number(val));
    };
    const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    const keysOf = (arr) => Object.keys(arr);
    const entriesOf = (arr) => Object.entries(arr);
    const getProp = (obj, path, defaultValue) => {
      return {
        get value() {
          return get(obj, path, defaultValue);
        },
        set value(val) {
          set(obj, path, val);
        }
      };
    };
    class ElementPlusError extends Error {
      constructor(m2) {
        super(m2);
        this.name = "ElementPlusError";
      }
    }
    function throwError(scope, m2) {
      throw new ElementPlusError(`[${scope}] ${m2}`);
    }
    function debugWarn(scope, message2) {
    }
    const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
    const hasClass = (el, cls) => {
      if (!el || !cls)
        return false;
      if (cls.includes(" "))
        throw new Error("className should not contain space.");
      return el.classList.contains(cls);
    };
    const addClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.add(...classNameToArray(cls));
    };
    const removeClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.remove(...classNameToArray(cls));
    };
    const getStyle = (element, styleName) => {
      var _a2;
      if (!isClient || !element || !styleName)
        return "";
      let key = camelize(styleName);
      if (key === "float")
        key = "cssFloat";
      try {
        const style = element.style[key];
        if (style)
          return style;
        const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
        return computed2 ? computed2[key] : "";
      } catch (e) {
        return element.style[key];
      }
    };
    function addUnit(value, defaultUnit = "px") {
      if (!value)
        return "";
      if (isNumber(value) || isStringNumber(value)) {
        return `${value}${defaultUnit}`;
      } else if (isString$1(value)) {
        return value;
      }
    }
    let scrollBarWidth;
    const getScrollBarWidth = (namespace) => {
      var _a2;
      if (!isClient)
        return 0;
      if (scrollBarWidth !== void 0)
        return scrollBarWidth;
      const outer = document.createElement("div");
      outer.className = `${namespace}-scrollbar__wrap`;
      outer.style.visibility = "hidden";
      outer.style.width = "100px";
      outer.style.position = "absolute";
      outer.style.top = "-9999px";
      document.body.appendChild(outer);
      const widthNoScroll = outer.offsetWidth;
      outer.style.overflow = "scroll";
      const inner = document.createElement("div");
      inner.style.width = "100%";
      outer.appendChild(inner);
      const widthWithScroll = inner.offsetWidth;
      (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
      scrollBarWidth = widthNoScroll - widthWithScroll;
      return scrollBarWidth;
    };
    function scrollIntoView(container, selected) {
      if (!isClient)
        return;
      if (!selected) {
        container.scrollTop = 0;
        return;
      }
      const offsetParents = [];
      let pointer = selected.offsetParent;
      while (pointer !== null && container !== pointer && container.contains(pointer)) {
        offsetParents.push(pointer);
        pointer = pointer.offsetParent;
      }
      const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
      const bottom = top + selected.offsetHeight;
      const viewRectTop = container.scrollTop;
      const viewRectBottom = viewRectTop + container.clientHeight;
      if (top < viewRectTop) {
        container.scrollTop = top;
      } else if (bottom > viewRectBottom) {
        container.scrollTop = bottom - container.clientHeight;
      }
    }
    /*! Element Plus Icons Vue v2.3.1 */
    var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowDown",
      __name: "arrow-down",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
          })
        ]));
      }
    });
    var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
    var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowLeft",
      __name: "arrow-left",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
          })
        ]));
      }
    });
    var arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default;
    var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowRight",
      __name: "arrow-right",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
          })
        ]));
      }
    });
    var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
    var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowUp",
      __name: "arrow-up",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
          })
        ]));
      }
    });
    var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
    var check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Check",
      __name: "check",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
          })
        ]));
      }
    });
    var check_default = check_vue_vue_type_script_setup_true_lang_default;
    var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleCheck",
      __name: "circle-check",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
          })
        ]));
      }
    });
    var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
    var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleCloseFilled",
      __name: "circle-close-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
          })
        ]));
      }
    });
    var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
    var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleClose",
      __name: "circle-close",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
          })
        ]));
      }
    });
    var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
    var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Close",
      __name: "close",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
          })
        ]));
      }
    });
    var close_default = close_vue_vue_type_script_setup_true_lang_default;
    var d_arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "DArrowLeft",
      __name: "d-arrow-left",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
          })
        ]));
      }
    });
    var d_arrow_left_default = d_arrow_left_vue_vue_type_script_setup_true_lang_default;
    var d_arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "DArrowRight",
      __name: "d-arrow-right",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
          })
        ]));
      }
    });
    var d_arrow_right_default = d_arrow_right_vue_vue_type_script_setup_true_lang_default;
    var delete_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Delete",
      __name: "delete",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
          })
        ]));
      }
    });
    var delete_default = delete_vue_vue_type_script_setup_true_lang_default;
    var document_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Document",
      __name: "document",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
          })
        ]));
      }
    });
    var document_default = document_vue_vue_type_script_setup_true_lang_default;
    var eleme_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Eleme",
      __name: "eleme",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M300.032 188.8c174.72-113.28 408-63.36 522.24 109.44 5.76 10.56 11.52 20.16 17.28 30.72v.96a22.4 22.4 0 0 1-7.68 26.88l-352.32 228.48c-9.6 6.72-22.08 3.84-28.8-5.76l-18.24-27.84a54.336 54.336 0 0 1 16.32-74.88l225.6-146.88c9.6-6.72 12.48-19.2 5.76-28.8-.96-1.92-1.92-3.84-3.84-4.8a267.84 267.84 0 0 0-315.84-17.28c-123.84 81.6-159.36 247.68-78.72 371.52a268.096 268.096 0 0 0 370.56 78.72 54.336 54.336 0 0 1 74.88 16.32l17.28 26.88c5.76 9.6 3.84 21.12-4.8 27.84-8.64 7.68-18.24 14.4-28.8 21.12a377.92 377.92 0 0 1-522.24-110.4c-113.28-174.72-63.36-408 111.36-522.24zm526.08 305.28a22.336 22.336 0 0 1 28.8 5.76l23.04 35.52a63.232 63.232 0 0 1-18.24 87.36l-35.52 23.04c-9.6 6.72-22.08 3.84-28.8-5.76l-46.08-71.04c-6.72-9.6-3.84-22.08 5.76-28.8l71.04-46.08z"
          })
        ]));
      }
    });
    var eleme_default = eleme_vue_vue_type_script_setup_true_lang_default;
    var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Hide",
      __name: "hide",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
          })
        ]));
      }
    });
    var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
    var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "InfoFilled",
      __name: "info-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
          })
        ]));
      }
    });
    var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
    var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Loading",
      __name: "loading",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
          })
        ]));
      }
    });
    var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
    var more_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "MoreFilled",
      __name: "more-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
          })
        ]));
      }
    });
    var more_filled_default = more_filled_vue_vue_type_script_setup_true_lang_default;
    var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "SuccessFilled",
      __name: "success-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
          })
        ]));
      }
    });
    var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
    var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "View",
      __name: "view",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
          })
        ]));
      }
    });
    var view_default = view_vue_vue_type_script_setup_true_lang_default;
    var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "WarningFilled",
      __name: "warning-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
          })
        ]));
      }
    });
    var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
    var zoom_in_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ZoomIn",
      __name: "zoom-in",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
          })
        ]));
      }
    });
    var zoom_in_default = zoom_in_vue_vue_type_script_setup_true_lang_default;
    const epPropKey = "__epPropKey";
    const definePropType = (val) => val;
    const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
    const buildProp = (prop, key) => {
      if (!isObject$1(prop) || isEpProp(prop))
        return prop;
      const { values, required, default: defaultValue, type, validator } = prop;
      const _validator = values || validator ? (val) => {
        let valid = false;
        let allowedValues = [];
        if (values) {
          allowedValues = Array.from(values);
          if (hasOwn(prop, "default")) {
            allowedValues.push(defaultValue);
          }
          valid || (valid = allowedValues.includes(val));
        }
        if (validator)
          valid || (valid = validator(val));
        if (!valid && allowedValues.length > 0) {
          const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
          warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
        }
        return valid;
      } : void 0;
      const epProp = {
        type,
        required: !!required,
        validator: _validator,
        [epPropKey]: true
      };
      if (hasOwn(prop, "default"))
        epProp.default = defaultValue;
      return epProp;
    };
    const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
      key,
      buildProp(option, key)
    ]));
    const iconPropType = definePropType([
      String,
      Object,
      Function
    ]);
    const CloseComponents = {
      Close: close_default
    };
    const TypeComponents = {
      Close: close_default,
      SuccessFilled: success_filled_default,
      InfoFilled: info_filled_default,
      WarningFilled: warning_filled_default,
      CircleCloseFilled: circle_close_filled_default
    };
    const TypeComponentsMap = {
      success: success_filled_default,
      warning: warning_filled_default,
      error: circle_close_filled_default,
      info: info_filled_default
    };
    const ValidateComponentsMap = {
      validating: loading_default,
      success: circle_check_default,
      error: circle_close_default
    };
    const withInstall = (main, extra) => {
      main.install = (app2) => {
        for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
          app2.component(comp.name, comp);
        }
      };
      if (extra) {
        for (const [key, comp] of Object.entries(extra)) {
          main[key] = comp;
        }
      }
      return main;
    };
    const withInstallFunction = (fn2, name) => {
      fn2.install = (app2) => {
        fn2._context = app2._context;
        app2.config.globalProperties[name] = fn2;
      };
      return fn2;
    };
    const withNoopInstall = (component) => {
      component.install = NOOP;
      return component;
    };
    const composeRefs = (...refs) => {
      return (el) => {
        refs.forEach((ref2) => {
          if (isFunction$2(ref2)) {
            ref2(el);
          } else {
            ref2.value = el;
          }
        });
      };
    };
    const EVENT_CODE = {
      tab: "Tab",
      enter: "Enter",
      space: "Space",
      left: "ArrowLeft",
      up: "ArrowUp",
      right: "ArrowRight",
      down: "ArrowDown",
      esc: "Escape",
      delete: "Delete",
      backspace: "Backspace",
      numpadEnter: "NumpadEnter",
      pageUp: "PageUp",
      pageDown: "PageDown",
      home: "Home",
      end: "End"
    };
    const UPDATE_MODEL_EVENT = "update:modelValue";
    const CHANGE_EVENT = "change";
    const INPUT_EVENT = "input";
    const componentSizes = ["", "default", "small", "large"];
    const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
    var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
      PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
      PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
      PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
      PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
      PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
      PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
      PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
      PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
      PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
      PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
      PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
      PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
      PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
      return PatchFlags2;
    })(PatchFlags || {});
    const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
    const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
    const mutable = (val) => val;
    const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
    const LISTENER_PREFIX = /^on[A-Z]/;
    const useAttrs = (params = {}) => {
      const { excludeListeners = false, excludeKeys } = params;
      const allExcludeKeys = computed(() => {
        return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
      });
      const instance = getCurrentInstance();
      if (!instance) {
        return computed(() => ({}));
      }
      return computed(() => {
        var _a2;
        return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
      });
    };
    const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
      watch(() => unref(condition), (val) => {
      }, {
        immediate: true
      });
    };
    const useDraggable = (targetRef, dragRef, draggable) => {
      let transform = {
        offsetX: 0,
        offsetY: 0
      };
      const onMousedown = (e) => {
        const downX = e.clientX;
        const downY = e.clientY;
        const { offsetX, offsetY } = transform;
        const targetRect = targetRef.value.getBoundingClientRect();
        const targetLeft = targetRect.left;
        const targetTop = targetRect.top;
        const targetWidth = targetRect.width;
        const targetHeight = targetRect.height;
        const clientWidth = document.documentElement.clientWidth;
        const clientHeight = document.documentElement.clientHeight;
        const minLeft = -targetLeft + offsetX;
        const minTop = -targetTop + offsetY;
        const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
        const maxTop = clientHeight - targetTop - targetHeight + offsetY;
        const onMousemove = (e2) => {
          const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
          const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
          transform = {
            offsetX: moveX,
            offsetY: moveY
          };
          if (targetRef.value) {
            targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
          }
        };
        const onMouseup = () => {
          document.removeEventListener("mousemove", onMousemove);
          document.removeEventListener("mouseup", onMouseup);
        };
        document.addEventListener("mousemove", onMousemove);
        document.addEventListener("mouseup", onMouseup);
      };
      const onDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.addEventListener("mousedown", onMousedown);
        }
      };
      const offDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.removeEventListener("mousedown", onMousedown);
        }
      };
      onMounted(() => {
        watchEffect(() => {
          if (draggable.value) {
            onDraggable();
          } else {
            offDraggable();
          }
        });
      });
      onBeforeUnmount(() => {
        offDraggable();
      });
    };
    var English = {
      name: "en",
      el: {
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          page: "Page",
          prev: "Go to previous page",
          next: "Go to next page",
          currentPage: "page {pager}",
          prevPages: "Previous {pager} pages",
          nextPages: "Next {pager} pages",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tour: {
          next: "Next",
          previous: "Previous",
          finish: "Finish"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        }
      }
    };
    const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
    const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
      var _a2;
      return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
    });
    const buildLocaleContext = (locale) => {
      const lang = computed(() => unref(locale).name);
      const localeRef = isRef(locale) ? locale : ref(locale);
      return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale)
      };
    };
    const localeContextKey = Symbol("localeContextKey");
    const useLocale = (localeOverrides) => {
      const locale = localeOverrides || inject(localeContextKey, ref());
      return buildLocaleContext(computed(() => locale.value || English));
    };
    const defaultNamespace = "el";
    const statePrefix = "is-";
    const _bem = (namespace, block, blockSuffix, element, modifier) => {
      let cls = `${namespace}-${block}`;
      if (blockSuffix) {
        cls += `-${blockSuffix}`;
      }
      if (element) {
        cls += `__${element}`;
      }
      if (modifier) {
        cls += `--${modifier}`;
      }
      return cls;
    };
    const namespaceContextKey = Symbol("namespaceContextKey");
    const useGetDerivedNamespace = (namespaceOverrides) => {
      const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
      const namespace = computed(() => {
        return unref(derivedNamespace) || defaultNamespace;
      });
      return namespace;
    };
    const useNamespace = (block, namespaceOverrides) => {
      const namespace = useGetDerivedNamespace(namespaceOverrides);
      const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
      const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
      const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
      const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
      const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
      const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
      const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
      const is = (name, ...args) => {
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
      };
      const cssVar = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarBlock = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${block}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarName = (name) => `--${namespace.value}-${name}`;
      const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
      return {
        namespace,
        b: b2,
        e,
        m: m2,
        be: be2,
        em,
        bm,
        bem,
        is,
        cssVar,
        cssVarName,
        cssVarBlock,
        cssVarBlockName
      };
    };
    const useLockscreen = (trigger2, options = {}) => {
      if (!isRef(trigger2)) {
        throwError("[useLockscreen]", "You need to pass a ref param to this function");
      }
      const ns = options.ns || useNamespace("popup");
      const hiddenCls = computed$1(() => ns.bm("parent", "hidden"));
      if (!isClient || hasClass(document.body, hiddenCls.value)) {
        return;
      }
      let scrollBarWidth2 = 0;
      let withoutHiddenClass = false;
      let bodyWidth = "0";
      const cleanup = () => {
        setTimeout(() => {
          removeClass(document == null ? void 0 : document.body, hiddenCls.value);
          if (withoutHiddenClass && document) {
            document.body.style.width = bodyWidth;
          }
        }, 200);
      };
      watch(trigger2, (val) => {
        if (!val) {
          cleanup();
          return;
        }
        withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
        if (withoutHiddenClass) {
          bodyWidth = document.body.style.width;
        }
        scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
        const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        const bodyOverflowY = getStyle(document.body, "overflowY");
        if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
          document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
        }
        addClass(document.body, hiddenCls.value);
      });
      onScopeDispose(() => cleanup());
    };
    const _prop = buildProp({
      type: definePropType(Boolean),
      default: null
    });
    const _event = buildProp({
      type: definePropType(Function)
    });
    const createModelToggleComposable = (name) => {
      const updateEventKey = `update:${name}`;
      const updateEventKeyRaw = `onUpdate:${name}`;
      const useModelToggleEmits2 = [updateEventKey];
      const useModelToggleProps2 = {
        [name]: _prop,
        [updateEventKeyRaw]: _event
      };
      const useModelToggle2 = ({
        indicator,
        toggleReason,
        shouldHideWhenRouteChanges,
        shouldProceed,
        onShow,
        onHide
      }) => {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const props = instance.props;
        const hasUpdateHandler = computed(() => isFunction$2(props[updateEventKeyRaw]));
        const isModelBindingAbsent = computed(() => props[name] === null);
        const doShow = (event) => {
          if (indicator.value === true) {
            return;
          }
          indicator.value = true;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$2(onShow)) {
            onShow(event);
          }
        };
        const doHide = (event) => {
          if (indicator.value === false) {
            return;
          }
          indicator.value = false;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$2(onHide)) {
            onHide(event);
          }
        };
        const show = (event) => {
          if (props.disabled === true || isFunction$2(shouldProceed) && !shouldProceed())
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, true);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doShow(event);
          }
        };
        const hide = (event) => {
          if (props.disabled === true || !isClient)
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, false);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doHide(event);
          }
        };
        const onChange = (val) => {
          if (!isBoolean(val))
            return;
          if (props.disabled && val) {
            if (hasUpdateHandler.value) {
              emit2(updateEventKey, false);
            }
          } else if (indicator.value !== val) {
            if (val) {
              doShow();
            } else {
              doHide();
            }
          }
        };
        const toggle = () => {
          if (indicator.value) {
            hide();
          } else {
            show();
          }
        };
        watch(() => props[name], onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
          watch(() => ({
            ...instance.proxy.$route
          }), () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          });
        }
        onMounted(() => {
          onChange(props[name]);
        });
        return {
          hide,
          show,
          toggle,
          hasUpdateHandler
        };
      };
      return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
      };
    };
    createModelToggleComposable("modelValue");
    const useProp = (name) => {
      const vm = getCurrentInstance();
      return computed(() => {
        var _a2, _b;
        return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
      });
    };
    var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
      return t.concat([e + "-" + U$1, e + "-" + J]);
    }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
      return t.concat([e, e + "-" + U$1, e + "-" + J]);
    }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
    function C(t) {
      return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function H(t) {
      if (t == null)
        return window;
      if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window;
      }
      return t;
    }
    function Q(t) {
      var e = H(t).Element;
      return t instanceof e || t instanceof Element;
    }
    function B(t) {
      var e = H(t).HTMLElement;
      return t instanceof e || t instanceof HTMLElement;
    }
    function Pe(t) {
      if (typeof ShadowRoot == "undefined")
        return false;
      var e = H(t).ShadowRoot;
      return t instanceof e || t instanceof ShadowRoot;
    }
    function Mt(t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
        !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
          var s2 = o2[a2];
          s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
        }));
      });
    }
    function Rt(t) {
      var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
      return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
        Object.keys(e.elements).forEach(function(r) {
          var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
            return f2[c2] = "", f2;
          }, {});
          !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
            o2.removeAttribute(f2);
          }));
        });
      };
    }
    var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
    function q(t) {
      return t.split("-")[0];
    }
    var X$1 = Math.max, ve = Math.min, Z = Math.round;
    function ee(t, e) {
      e === void 0 && (e = false);
      var n = t.getBoundingClientRect(), r = 1, o2 = 1;
      if (B(t) && e) {
        var i = t.offsetHeight, a2 = t.offsetWidth;
        a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
      }
      return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
    }
    function ke(t) {
      var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
      return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
    }
    function it(t, e) {
      var n = e.getRootNode && e.getRootNode();
      if (t.contains(e))
        return true;
      if (n && Pe(n)) {
        var r = e;
        do {
          if (r && t.isSameNode(r))
            return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function N$1(t) {
      return H(t).getComputedStyle(t);
    }
    function Wt(t) {
      return ["table", "td", "th"].indexOf(C(t)) >= 0;
    }
    function I$1(t) {
      return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function ge(t) {
      return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
    }
    function at(t) {
      return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
    }
    function Bt(t) {
      var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
      if (n && B(t)) {
        var r = N$1(t);
        if (r.position === "fixed")
          return null;
      }
      var o2 = ge(t);
      for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
        var i = N$1(o2);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
          return o2;
        o2 = o2.parentNode;
      }
      return null;
    }
    function se(t) {
      for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; )
        n = at(n);
      return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
    }
    function Le(t) {
      return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
    }
    function fe(t, e, n) {
      return X$1(t, ve(e, n));
    }
    function St(t, e, n) {
      var r = fe(t, e, n);
      return r > n ? n : r;
    }
    function st() {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    function ft(t) {
      return Object.assign({}, st(), t);
    }
    function ct(t, e) {
      return e.reduce(function(n, r) {
        return n[r] = t, n;
      }, {});
    }
    var Tt = function(t, e) {
      return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
    };
    function Ht(t) {
      var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
      if (!(!i || !a2)) {
        var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
        n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
      }
    }
    function Ct(t) {
      var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
      o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
    }
    var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    function te(t) {
      return t.split("-")[1];
    }
    var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    function Vt(t) {
      var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
      return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
    }
    function ut(t) {
      var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
      l2 = g.x, p2 = g.y;
      var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
      if (c2) {
        var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
        if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
          d2 = R;
          var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
          p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
        }
        if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
          $ = W;
          var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
          l2 -= k - r.width, l2 *= f2 ? 1 : -1;
        }
      }
      var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
      if (l2 = S2.x, p2 = S2.y, f2) {
        var L;
        return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
      }
      return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
    }
    function Nt(t) {
      var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
    }
    var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
    function It(t) {
      var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return i && c2.forEach(function(u2) {
        u2.addEventListener("scroll", n.update, ye);
      }), s2 && f2.addEventListener("resize", n.update, ye), function() {
        i && c2.forEach(function(u2) {
          u2.removeEventListener("scroll", n.update, ye);
        }), s2 && f2.removeEventListener("resize", n.update, ye);
      };
    }
    var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function be(t) {
      return t.replace(/left|right|bottom|top/g, function(e) {
        return _t[e];
      });
    }
    var zt = { start: "end", end: "start" };
    function lt(t) {
      return t.replace(/start|end/g, function(e) {
        return zt[e];
      });
    }
    function We(t) {
      var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
      return { scrollLeft: n, scrollTop: r };
    }
    function Be(t) {
      return ee(I$1(t)).left + We(t).scrollLeft;
    }
    function Ft(t) {
      var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
      return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
    }
    function Ut(t) {
      var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
      return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
    }
    function Se(t) {
      var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + o2 + r);
    }
    function dt(t) {
      return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
    }
    function ce(t, e) {
      var n;
      e === void 0 && (e = []);
      var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
      return o2 ? s2 : s2.concat(ce(ge(a2)));
    }
    function Te(t) {
      return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
    }
    function Xt(t) {
      var e = ee(t);
      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
    }
    function ht(t, e) {
      return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
    }
    function Yt(t) {
      var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
      return Q(r) ? e.filter(function(o2) {
        return Q(o2) && it(o2, r) && C(o2) !== "body";
      }) : [];
    }
    function Gt(t, e, n) {
      var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
        var c2 = ht(t, f2);
        return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
      }, ht(t, i));
      return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
    }
    function mt(t) {
      var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
      switch (o2) {
        case E$1:
          f2 = { x: a2, y: e.y - n.height };
          break;
        case R:
          f2 = { x: a2, y: e.y + e.height };
          break;
        case W:
          f2 = { x: e.x + e.width, y: s2 };
          break;
        case P$1:
          f2 = { x: e.x - n.width, y: s2 };
          break;
        default:
          f2 = { x: e.x, y: e.y };
      }
      var c2 = o2 ? Le(o2) : null;
      if (c2 != null) {
        var u2 = c2 === "y" ? "height" : "width";
        switch (i) {
          case U$1:
            f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
            break;
          case J:
            f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
            break;
        }
      }
      return f2;
    }
    function ne(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
      if (u2 === K && A2) {
        var k = A2[o2];
        Object.keys(j).forEach(function(D2) {
          var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
          j[D2] += k[L] * S2;
        });
      }
      return j;
    }
    function Jt(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
        return te(h2) === u2;
      }) : G, v2 = m2.filter(function(h2) {
        return c2.indexOf(h2) >= 0;
      });
      v2.length === 0 && (v2 = m2);
      var l2 = v2.reduce(function(h2, p2) {
        return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
      }, {});
      return Object.keys(l2).sort(function(h2, p2) {
        return l2[h2] - l2[p2];
      });
    }
    function Kt(t) {
      if (q(t) === me)
        return [];
      var e = be(t);
      return [lt(t), e, lt(e)];
    }
    function Qt(t) {
      var e = t.state, n = t.options, r = t.name;
      if (!e.modifiersData[r]._skip) {
        for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
          return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
        }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
          var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
          b2[oe] > w2[oe] && (T2 = be(T2));
          var pe = be(T2), _2 = [];
          if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
            return z;
          })) {
            A2 = D2, j = false;
            break;
          }
          O2.set(D2, _2);
        }
        if (j)
          for (var ue = h2 ? 3 : 1, xe = function(z) {
            var V = d2.find(function(de) {
              var ae = O2.get(de);
              if (ae)
                return ae.slice(0, z).every(function(Y2) {
                  return Y2;
                });
            });
            if (V)
              return A2 = V, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break")
              break;
          }
        e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
      }
    }
    var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
    function gt(t, e, n) {
      return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
    }
    function yt(t) {
      return [E$1, W, R, P$1].some(function(e) {
        return t[e] >= 0;
      });
    }
    function Zt(t) {
      var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
      e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
    }
    var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
    function en(t, e, n) {
      var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
      return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
    }
    function tn(t) {
      var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
        return u2[m2] = en(m2, e.rects, i), u2;
      }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
    }
    var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
    function nn(t) {
      var e = t.state, n = t.name;
      e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
    }
    var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
    function rn(t) {
      return t === "x" ? "y" : "x";
    }
    function on(t) {
      var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
      if (w2) {
        if (i) {
          var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
          w2[d2] = qe, S2[d2] = qe - T2;
        }
        if (s2) {
          var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
          w2[b2] = Ue, S2[b2] = Ue - F2;
        }
        e.modifiersData[r] = S2;
      }
    }
    var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
    function an(t) {
      return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
    }
    function sn(t) {
      return t === H(t) || !B(t) ? We(t) : an(t);
    }
    function fn(t) {
      var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
      return n !== 1 || r !== 1;
    }
    function cn(t, e, n) {
      n === void 0 && (n = false);
      var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
      return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
    }
    function pn(t) {
      var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
      t.forEach(function(i) {
        e.set(i.name, i);
      });
      function o2(i) {
        n.add(i.name);
        var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
        a2.forEach(function(s2) {
          if (!n.has(s2)) {
            var f2 = e.get(s2);
            f2 && o2(f2);
          }
        }), r.push(i);
      }
      return t.forEach(function(i) {
        n.has(i.name) || o2(i);
      }), r;
    }
    function un(t) {
      var e = pn(t);
      return ot.reduce(function(n, r) {
        return n.concat(e.filter(function(o2) {
          return o2.phase === r;
        }));
      }, []);
    }
    function ln(t) {
      var e;
      return function() {
        return e || (e = new Promise(function(n) {
          Promise.resolve().then(function() {
            e = void 0, n(t());
          });
        })), e;
      };
    }
    function dn(t) {
      var e = t.reduce(function(n, r) {
        var o2 = n[r.name];
        return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
      }, {});
      return Object.keys(e).map(function(n) {
        return e[n];
      });
    }
    var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
    function $t() {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n];
      return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function we(t) {
      t === void 0 && (t = {});
      var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
      return function(a2, s2, f2) {
        f2 === void 0 && (f2 = i);
        var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
          var g = typeof p2 == "function" ? p2(c2.options) : p2;
          h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
          var x2 = un(dn([].concat(r, c2.options.modifiers)));
          return c2.orderedModifiers = x2.filter(function(y) {
            return y.enabled;
          }), l2(), v2.update();
        }, forceUpdate: function() {
          if (!m2) {
            var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
            if ($t(g, x2)) {
              c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                return c2.modifiersData[j.name] = Object.assign({}, j.data);
              });
              for (var y = 0; y < c2.orderedModifiers.length; y++) {
                if (c2.reset === true) {
                  c2.reset = false, y = -1;
                  continue;
                }
                var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
              }
            }
          }
        }, update: ln(function() {
          return new Promise(function(p2) {
            v2.forceUpdate(), p2(c2);
          });
        }), destroy: function() {
          h2(), m2 = true;
        } };
        if (!$t(a2, s2))
          return v2;
        v2.setOptions(f2).then(function(p2) {
          !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
        });
        function l2() {
          c2.orderedModifiers.forEach(function(p2) {
            var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
            if (typeof $ == "function") {
              var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
              };
              u2.push(d2 || b2);
            }
          });
        }
        function h2() {
          u2.forEach(function(p2) {
            return p2();
          }), u2 = [];
        }
        return v2;
      };
    }
    we();
    var mn = [Re, He, Me, Ae];
    we({ defaultModifiers: mn });
    var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
    const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
      const stateUpdater = {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: ({ state }) => {
          const derivedState = deriveState(state);
          Object.assign(states.value, derivedState);
        },
        requires: ["computeStyles"]
      };
      const options = computed(() => {
        const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
        return {
          onFirstUpdate,
          placement: placement || "bottom",
          strategy: strategy || "absolute",
          modifiers: [
            ...modifiers || [],
            stateUpdater,
            { name: "applyStyles", enabled: false }
          ]
        };
      });
      const instanceRef = shallowRef();
      const states = ref({
        styles: {
          popper: {
            position: unref(options).strategy,
            left: "0",
            top: "0"
          },
          arrow: {
            position: "absolute"
          }
        },
        attributes: {}
      });
      const destroy = () => {
        if (!instanceRef.value)
          return;
        instanceRef.value.destroy();
        instanceRef.value = void 0;
      };
      watch(options, (newOptions) => {
        const instance = unref(instanceRef);
        if (instance) {
          instance.setOptions(newOptions);
        }
      }, {
        deep: true
      });
      watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
        destroy();
        if (!referenceElement || !popperElement)
          return;
        instanceRef.value = yn(referenceElement, popperElement, unref(options));
      });
      onBeforeUnmount(() => {
        destroy();
      });
      return {
        state: computed(() => {
          var _a2;
          return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
        }),
        styles: computed(() => unref(states).styles),
        attributes: computed(() => unref(states).attributes),
        update: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
        },
        forceUpdate: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
        },
        instanceRef: computed(() => unref(instanceRef))
      };
    };
    function deriveState(state) {
      const elements = Object.keys(state.elements);
      const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
      const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
      return {
        styles,
        attributes
      };
    }
    const useSameTarget = (handleClick) => {
      if (!handleClick) {
        return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
      }
      let mousedownTarget = false;
      let mouseupTarget = false;
      const onClick = (e) => {
        if (mousedownTarget && mouseupTarget) {
          handleClick(e);
        }
        mousedownTarget = mouseupTarget = false;
      };
      const onMousedown = (e) => {
        mousedownTarget = e.target === e.currentTarget;
      };
      const onMouseup = (e) => {
        mouseupTarget = e.target === e.currentTarget;
      };
      return { onClick, onMousedown, onMouseup };
    };
    function useTimeout() {
      let timeoutHandle;
      const registerTimeout = (fn2, delay) => {
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn2, delay);
      };
      const cancelTimeout = () => window.clearTimeout(timeoutHandle);
      tryOnScopeDispose(() => cancelTimeout());
      return {
        registerTimeout,
        cancelTimeout
      };
    }
    const defaultIdInjection = {
      prefix: Math.floor(Math.random() * 1e4),
      current: 0
    };
    const ID_INJECTION_KEY = Symbol("elIdInjection");
    const useIdInjection = () => {
      return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
    };
    const useId = (deterministicId) => {
      const idInjection = useIdInjection();
      const namespace = useGetDerivedNamespace();
      const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
      return idRef;
    };
    let registeredEscapeHandlers = [];
    const cachedHandler = (e) => {
      const event = e;
      if (event.key === EVENT_CODE.esc) {
        registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
      }
    };
    const useEscapeKeydown = (handler) => {
      onMounted(() => {
        if (registeredEscapeHandlers.length === 0) {
          document.addEventListener("keydown", cachedHandler);
        }
        if (isClient)
          registeredEscapeHandlers.push(handler);
      });
      onBeforeUnmount(() => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
        if (registeredEscapeHandlers.length === 0) {
          if (isClient)
            document.removeEventListener("keydown", cachedHandler);
        }
      });
    };
    let cachedContainer;
    const usePopperContainerId = () => {
      const namespace = useGetDerivedNamespace();
      const idInjection = useIdInjection();
      const id = computed(() => {
        return `${namespace.value}-popper-container-${idInjection.prefix}`;
      });
      const selector = computed(() => `#${id.value}`);
      return {
        id,
        selector
      };
    };
    const createContainer = (id) => {
      const container = document.createElement("div");
      container.id = id;
      document.body.appendChild(container);
      return container;
    };
    const usePopperContainer = () => {
      const { id, selector } = usePopperContainerId();
      onBeforeMount(() => {
        if (!isClient)
          return;
        if (!cachedContainer && !document.body.querySelector(selector.value)) {
          cachedContainer = createContainer(id.value);
        }
      });
      return {
        id,
        selector
      };
    };
    const useDelayedToggleProps = buildProps({
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      autoClose: {
        type: Number,
        default: 0
      }
    });
    const useDelayedToggle = ({
      showAfter,
      hideAfter,
      autoClose,
      open,
      close
    }) => {
      const { registerTimeout } = useTimeout();
      const {
        registerTimeout: registerTimeoutForAutoClose,
        cancelTimeout: cancelTimeoutForAutoClose
      } = useTimeout();
      const onOpen = (event) => {
        registerTimeout(() => {
          open(event);
          const _autoClose = unref(autoClose);
          if (isNumber(_autoClose) && _autoClose > 0) {
            registerTimeoutForAutoClose(() => {
              close(event);
            }, _autoClose);
          }
        }, unref(showAfter));
      };
      const onClose = (event) => {
        cancelTimeoutForAutoClose();
        registerTimeout(() => {
          close(event);
        }, unref(hideAfter));
      };
      return {
        onOpen,
        onClose
      };
    };
    const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
    const useForwardRef = (forwardRef) => {
      const setForwardRef = (el) => {
        forwardRef.value = el;
      };
      provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
      });
    };
    const useForwardRefDirective = (setForwardRef) => {
      return {
        mounted(el) {
          setForwardRef(el);
        },
        updated(el) {
          setForwardRef(el);
        },
        unmounted() {
          setForwardRef(null);
        }
      };
    };
    const zIndex = ref(0);
    const defaultInitialZIndex = 2e3;
    const zIndexContextKey = Symbol("zIndexContextKey");
    const useZIndex = (zIndexOverrides) => {
      const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
      const initialZIndex = computed(() => {
        const zIndexFromInjection = unref(zIndexInjection);
        return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
      });
      const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
      const nextZIndex = () => {
        zIndex.value++;
        return currentZIndex.value;
      };
      return {
        initialZIndex,
        currentZIndex,
        nextZIndex
      };
    };
    function useCursor(input) {
      const selectionRef = ref();
      function recordCursor() {
        if (input.value == void 0)
          return;
        const { selectionStart, selectionEnd, value } = input.value;
        if (selectionStart == null || selectionEnd == null)
          return;
        const beforeTxt = value.slice(0, Math.max(0, selectionStart));
        const afterTxt = value.slice(Math.max(0, selectionEnd));
        selectionRef.value = {
          selectionStart,
          selectionEnd,
          value,
          beforeTxt,
          afterTxt
        };
      }
      function setCursor() {
        if (input.value == void 0 || selectionRef.value == void 0)
          return;
        const { value } = input.value;
        const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
        if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
          return;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[selectionStart - 1];
          const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.value.setSelectionRange(startPos, startPos);
      }
      return [recordCursor, setCursor];
    }
    const useSizeProp = buildProp({
      type: String,
      values: componentSizes,
      required: false
    });
    const SIZE_INJECTION_KEY = Symbol("size");
    const useGlobalSize = () => {
      const injectedSize = inject(SIZE_INJECTION_KEY, {});
      return computed(() => {
        return unref(injectedSize.size) || "";
      });
    };
    function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
      const instance = getCurrentInstance();
      const { emit: emit2 } = instance;
      const wrapperRef = shallowRef();
      const isFocused = ref(false);
      const handleFocus = (event) => {
        if (isFocused.value)
          return;
        isFocused.value = true;
        emit2("focus", event);
        afterFocus == null ? void 0 : afterFocus();
      };
      const handleBlur = (event) => {
        var _a2;
        const cancelBlur = isFunction$2(beforeBlur) ? beforeBlur(event) : false;
        if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
          return;
        isFocused.value = false;
        emit2("blur", event);
        afterBlur == null ? void 0 : afterBlur();
      };
      const handleClick = () => {
        var _a2;
        (_a2 = target.value) == null ? void 0 : _a2.focus();
      };
      watch(wrapperRef, (el) => {
        if (el) {
          el.setAttribute("tabindex", "-1");
        }
      });
      useEventListener(wrapperRef, "click", handleClick);
      return {
        wrapperRef,
        isFocused,
        handleFocus,
        handleBlur
      };
    }
    const configProviderContextKey = Symbol();
    const globalConfig = ref();
    function useGlobalConfig(key, defaultValue = void 0) {
      const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
      if (key) {
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
        });
      } else {
        return config;
      }
    }
    function useGlobalComponentSettings(block, sizeFallback) {
      const config = useGlobalConfig();
      const ns = useNamespace(block, computed(() => {
        var _a2;
        return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
      }));
      const locale = useLocale(computed(() => {
        var _a2;
        return (_a2 = config.value) == null ? void 0 : _a2.locale;
      }));
      const zIndex2 = useZIndex(computed(() => {
        var _a2;
        return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
      }));
      const size2 = computed(() => {
        var _a2;
        return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
      });
      provideGlobalConfig(computed(() => unref(config) || {}));
      return {
        ns,
        locale,
        zIndex: zIndex2,
        size: size2
      };
    }
    const provideGlobalConfig = (config, app2, global2 = false) => {
      var _a2;
      const inSetup = !!getCurrentInstance();
      const oldConfig = inSetup ? useGlobalConfig() : void 0;
      const provideFn = (_a2 = app2 == null ? void 0 : app2.provide) != null ? _a2 : inSetup ? provide : void 0;
      if (!provideFn) {
        return;
      }
      const context = computed(() => {
        const cfg = unref(config);
        if (!(oldConfig == null ? void 0 : oldConfig.value))
          return cfg;
        return mergeConfig(oldConfig.value, cfg);
      });
      provideFn(configProviderContextKey, context);
      provideFn(localeContextKey, computed(() => context.value.locale));
      provideFn(namespaceContextKey, computed(() => context.value.namespace));
      provideFn(zIndexContextKey, computed(() => context.value.zIndex));
      provideFn(SIZE_INJECTION_KEY, {
        size: computed(() => context.value.size || "")
      });
      if (global2 || !globalConfig.value) {
        globalConfig.value = context.value;
      }
      return context;
    };
    const mergeConfig = (a2, b2) => {
      var _a2;
      const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
      const obj = {};
      for (const key of keys2) {
        obj[key] = (_a2 = b2[key]) != null ? _a2 : a2[key];
      }
      return obj;
    };
    const messageConfig = {};
    var _export_sfc$1 = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const iconProps = buildProps({
      size: {
        type: definePropType([Number, String])
      },
      color: {
        type: String
      }
    });
    const __default__$E = /* @__PURE__ */ defineComponent({
      name: "ElIcon",
      inheritAttrs: false
    });
    const _sfc_main$11 = /* @__PURE__ */ defineComponent({
      ...__default__$E,
      props: iconProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("icon");
        const style = computed(() => {
          const { size: size2, color } = props;
          if (!size2 && !color)
            return {};
          return {
            fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
            "--color": color
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("i", mergeProps({
            class: unref(ns).b(),
            style: unref(style)
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default")
          ], 16);
        };
      }
    });
    var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "icon.vue"]]);
    const ElIcon = withInstall(Icon);
    const formContextKey = Symbol("formContextKey");
    const formItemContextKey = Symbol("formItemContextKey");
    const useFormSize = (fallback, ignore = {}) => {
      const emptyRef = ref(void 0);
      const size2 = ignore.prop ? emptyRef : useProp("size");
      const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
      const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
      const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
      return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
    };
    const useFormDisabled = (fallback) => {
      const disabled = useProp("disabled");
      const form = inject(formContextKey, void 0);
      return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
    };
    const useFormItem = () => {
      const form = inject(formContextKey, void 0);
      const formItem = inject(formItemContextKey, void 0);
      return {
        form,
        formItem
      };
    };
    const useFormItemInputId = (props, {
      formItemContext,
      disableIdGeneration,
      disableIdManagement
    }) => {
      if (!disableIdGeneration) {
        disableIdGeneration = ref(false);
      }
      if (!disableIdManagement) {
        disableIdManagement = ref(false);
      }
      const inputId = ref();
      let idUnwatch = void 0;
      const isLabeledByFormItem = computed(() => {
        var _a2;
        return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
      });
      onMounted(() => {
        idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
          const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
          if (newId !== inputId.value) {
            if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
              inputId.value && formItemContext.removeInputId(inputId.value);
              if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                formItemContext.addInputId(newId);
              }
            }
            inputId.value = newId;
          }
        }, { immediate: true });
      });
      onUnmounted(() => {
        idUnwatch && idUnwatch();
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
        }
      });
      return {
        isLabeledByFormItem,
        inputId
      };
    };
    const formMetaProps = buildProps({
      size: {
        type: String,
        values: componentSizes
      },
      disabled: Boolean
    });
    const formProps = buildProps({
      ...formMetaProps,
      model: Object,
      rules: {
        type: definePropType(Object)
      },
      labelPosition: {
        type: String,
        values: ["left", "right", "top"],
        default: "right"
      },
      requireAsteriskPosition: {
        type: String,
        values: ["left", "right"],
        default: "left"
      },
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      labelSuffix: {
        type: String,
        default: ""
      },
      inline: Boolean,
      inlineMessage: Boolean,
      statusIcon: Boolean,
      showMessage: {
        type: Boolean,
        default: true
      },
      validateOnRuleChange: {
        type: Boolean,
        default: true
      },
      hideRequiredAsterisk: Boolean,
      scrollToError: Boolean,
      scrollIntoViewOptions: {
        type: [Object, Boolean]
      }
    });
    const formEmits = {
      validate: (prop, isValid, message2) => (isArray$1(prop) || isString$1(prop)) && isBoolean(isValid) && isString$1(message2)
    };
    function useFormLabelWidth() {
      const potentialLabelWidthArr = ref([]);
      const autoLabelWidth = computed(() => {
        if (!potentialLabelWidthArr.value.length)
          return "0";
        const max = Math.max(...potentialLabelWidthArr.value);
        return max ? `${max}px` : "";
      });
      function getLabelWidthIndex(width) {
        const index = potentialLabelWidthArr.value.indexOf(width);
        if (index === -1 && autoLabelWidth.value === "0")
          ;
        return index;
      }
      function registerLabelWidth(val, oldVal) {
        if (val && oldVal) {
          const index = getLabelWidthIndex(oldVal);
          potentialLabelWidthArr.value.splice(index, 1, val);
        } else if (val) {
          potentialLabelWidthArr.value.push(val);
        }
      }
      function deregisterLabelWidth(val) {
        const index = getLabelWidthIndex(val);
        if (index > -1) {
          potentialLabelWidthArr.value.splice(index, 1);
        }
      }
      return {
        autoLabelWidth,
        registerLabelWidth,
        deregisterLabelWidth
      };
    }
    const filterFields = (fields, props) => {
      const normalized = castArray(props);
      return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
    };
    const COMPONENT_NAME$6 = "ElForm";
    const __default__$D = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$6
    });
    const _sfc_main$10 = /* @__PURE__ */ defineComponent({
      ...__default__$D,
      props: formProps,
      emits: formEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const fields = [];
        const formSize = useFormSize();
        const ns = useNamespace("form");
        const formClasses = computed(() => {
          const { labelPosition, inline } = props;
          return [
            ns.b(),
            ns.m(formSize.value || "default"),
            {
              [ns.m(`label-${labelPosition}`)]: labelPosition,
              [ns.m("inline")]: inline
            }
          ];
        });
        const getField = (prop) => {
          return fields.find((field) => field.prop === prop);
        };
        const addField = (field) => {
          fields.push(field);
        };
        const removeField = (field) => {
          if (field.prop) {
            fields.splice(fields.indexOf(field), 1);
          }
        };
        const resetFields = (properties = []) => {
          if (!props.model) {
            return;
          }
          filterFields(fields, properties).forEach((field) => field.resetField());
        };
        const clearValidate = (props2 = []) => {
          filterFields(fields, props2).forEach((field) => field.clearValidate());
        };
        const isValidatable = computed(() => {
          const hasModel = !!props.model;
          return hasModel;
        });
        const obtainValidateFields = (props2) => {
          if (fields.length === 0)
            return [];
          const filteredFields = filterFields(fields, props2);
          if (!filteredFields.length) {
            return [];
          }
          return filteredFields;
        };
        const validate = async (callback) => validateField(void 0, callback);
        const doValidateField = async (props2 = []) => {
          if (!isValidatable.value)
            return false;
          const fields2 = obtainValidateFields(props2);
          if (fields2.length === 0)
            return true;
          let validationErrors = {};
          for (const field of fields2) {
            try {
              await field.validate("");
            } catch (fields3) {
              validationErrors = {
                ...validationErrors,
                ...fields3
              };
            }
          }
          if (Object.keys(validationErrors).length === 0)
            return true;
          return Promise.reject(validationErrors);
        };
        const validateField = async (modelProps = [], callback) => {
          const shouldThrow = !isFunction$2(callback);
          try {
            const result = await doValidateField(modelProps);
            if (result === true) {
              callback == null ? void 0 : callback(result);
            }
            return result;
          } catch (e) {
            if (e instanceof Error)
              throw e;
            const invalidFields = e;
            if (props.scrollToError) {
              scrollToField(Object.keys(invalidFields)[0]);
            }
            callback == null ? void 0 : callback(false, invalidFields);
            return shouldThrow && Promise.reject(invalidFields);
          }
        };
        const scrollToField = (prop) => {
          var _a2;
          const field = filterFields(fields, prop)[0];
          if (field) {
            (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
          }
        };
        watch(() => props.rules, () => {
          if (props.validateOnRuleChange) {
            validate().catch((err) => debugWarn());
          }
        }, { deep: true });
        provide(formContextKey, reactive({
          ...toRefs(props),
          emit: emit2,
          resetFields,
          clearValidate,
          validateField,
          getField,
          addField,
          removeField,
          ...useFormLabelWidth()
        }));
        expose({
          validate,
          validateField,
          resetFields,
          clearValidate,
          scrollToField
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("form", {
            class: normalizeClass(unref(formClasses))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "form.vue"]]);
    var define_process_env_default = {};
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
        return o22.__proto__ || Object.getPrototypeOf(o22);
      };
      return _getPrototypeOf(o2);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
        o22.__proto__ = p22;
        return o22;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a2 = [null];
          a2.push.apply(a2, args2);
          var Constructor = Function.bind.apply(Parent2, a2);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    if (typeof process !== "undefined" && define_process_env_default && false) {
      warning = function warning3(type4, errors) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors.every(function(e) {
            return typeof e === "string";
          })) {
            console.warn(type4, errors);
          }
        }
      };
    }
    function convertFieldsError(errors) {
      if (!errors || !errors.length)
        return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x2) {
          if (x2 === "%%") {
            return "%";
          }
          if (i >= len) {
            return x2;
          }
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_2) {
                return "[Circular]";
              }
              break;
            default:
              return x2;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a2) {
        func(a2, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v2 = value;
      for (var i = 0; i < path.length; i++) {
        if (v2 == void 0) {
          return v2;
        }
        v2 = v2[path[i]];
      }
      return v2;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s2 in source) {
          if (source.hasOwnProperty(s2)) {
            var value = source[s2];
            if (typeof value === "object" && typeof target[s2] === "object") {
              target[s2] = _extends({}, target[s2], value);
            } else {
              target[s2] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b2 = function b22(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone2() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o2, oc) {
        var _this2 = this;
        if (o2 === void 0) {
          o2 = {};
        }
        if (oc === void 0) {
          oc = function oc2() {
          };
        }
        var source = source_;
        var options = o2;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add2(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e) {
              return cb(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType2(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type4, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type4] = validator;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;
    const formItemValidateStates = [
      "",
      "error",
      "validating",
      "success"
    ];
    const formItemProps = buildProps({
      label: String,
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      prop: {
        type: definePropType([String, Array])
      },
      required: {
        type: Boolean,
        default: void 0
      },
      rules: {
        type: definePropType([Object, Array])
      },
      error: String,
      validateStatus: {
        type: String,
        values: formItemValidateStates
      },
      for: String,
      inlineMessage: {
        type: [String, Boolean],
        default: ""
      },
      showMessage: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        values: componentSizes
      }
    });
    const COMPONENT_NAME$5 = "ElLabelWrap";
    var FormLabelWrap = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$5,
      props: {
        isAutoWidth: Boolean,
        updateAll: Boolean
      },
      setup(props, {
        slots
      }) {
        const formContext = inject(formContextKey, void 0);
        const formItemContext = inject(formItemContextKey);
        if (!formItemContext)
          throwError(COMPONENT_NAME$5, "usage: <el-form-item><label-wrap /></el-form-item>");
        const ns = useNamespace("form");
        const el = ref();
        const computedWidth = ref(0);
        const getLabelWidth = () => {
          var _a2;
          if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
            const width = window.getComputedStyle(el.value.firstElementChild).width;
            return Math.ceil(Number.parseFloat(width));
          } else {
            return 0;
          }
        };
        const updateLabelWidth = (action = "update") => {
          nextTick(() => {
            if (slots.default && props.isAutoWidth) {
              if (action === "update") {
                computedWidth.value = getLabelWidth();
              } else if (action === "remove") {
                formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
              }
            }
          });
        };
        const updateLabelWidthFn = () => updateLabelWidth("update");
        onMounted(() => {
          updateLabelWidthFn();
        });
        onBeforeUnmount(() => {
          updateLabelWidth("remove");
        });
        onUpdated(() => updateLabelWidthFn());
        watch(computedWidth, (val, oldVal) => {
          if (props.updateAll) {
            formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
          }
        });
        useResizeObserver(computed(() => {
          var _a2, _b;
          return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
        }), updateLabelWidthFn);
        return () => {
          var _a2, _b;
          if (!slots)
            return null;
          const {
            isAutoWidth
          } = props;
          if (isAutoWidth) {
            const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
            const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
            const style = {};
            if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
              const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
              const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
              if (marginWidth) {
                style[marginPosition] = `${marginWidth}px`;
              }
            }
            return createVNode("div", {
              "ref": el,
              "class": [ns.be("item", "label-wrap")],
              "style": style
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
          } else {
            return createVNode(Fragment, {
              "ref": el
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
          }
        };
      }
    });
    const _hoisted_1$v = ["role", "aria-labelledby"];
    const __default__$C = /* @__PURE__ */ defineComponent({
      name: "ElFormItem"
    });
    const _sfc_main$$ = /* @__PURE__ */ defineComponent({
      ...__default__$C,
      props: formItemProps,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        const formContext = inject(formContextKey, void 0);
        const parentFormItemContext = inject(formItemContextKey, void 0);
        const _size = useFormSize(void 0, { formItem: false });
        const ns = useNamespace("form-item");
        const labelId = useId().value;
        const inputIds = ref([]);
        const validateState = ref("");
        const validateStateDebounced = refDebounced(validateState, 100);
        const validateMessage = ref("");
        const formItemRef = ref();
        let initialValue = void 0;
        let isResettingField = false;
        const labelStyle = computed(() => {
          if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
            return {};
          }
          const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
          if (labelWidth)
            return { width: labelWidth };
          return {};
        });
        const contentStyle = computed(() => {
          if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
            return {};
          }
          if (!props.label && !props.labelWidth && isNested) {
            return {};
          }
          const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
          if (!props.label && !slots.label) {
            return { marginLeft: labelWidth };
          }
          return {};
        });
        const formItemClasses = computed(() => [
          ns.b(),
          ns.m(_size.value),
          ns.is("error", validateState.value === "error"),
          ns.is("validating", validateState.value === "validating"),
          ns.is("success", validateState.value === "success"),
          ns.is("required", isRequired.value || props.required),
          ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
          (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
          { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
        ]);
        const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
        const validateClasses = computed(() => [
          ns.e("error"),
          { [ns.em("error", "inline")]: _inlineMessage.value }
        ]);
        const propString = computed(() => {
          if (!props.prop)
            return "";
          return isString$1(props.prop) ? props.prop : props.prop.join(".");
        });
        const hasLabel = computed(() => {
          return !!(props.label || slots.label);
        });
        const labelFor = computed(() => {
          return props.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
        });
        const isGroup = computed(() => {
          return !labelFor.value && hasLabel.value;
        });
        const isNested = !!parentFormItemContext;
        const fieldValue = computed(() => {
          const model = formContext == null ? void 0 : formContext.model;
          if (!model || !props.prop) {
            return;
          }
          return getProp(model, props.prop).value;
        });
        const normalizedRules = computed(() => {
          const { required } = props;
          const rules2 = [];
          if (props.rules) {
            rules2.push(...castArray(props.rules));
          }
          const formRules = formContext == null ? void 0 : formContext.rules;
          if (formRules && props.prop) {
            const _rules = getProp(formRules, props.prop).value;
            if (_rules) {
              rules2.push(...castArray(_rules));
            }
          }
          if (required !== void 0) {
            const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
            if (requiredRules.length > 0) {
              for (const [rule, i] of requiredRules) {
                if (rule.required === required)
                  continue;
                rules2[i] = { ...rule, required };
              }
            } else {
              rules2.push({ required });
            }
          }
          return rules2;
        });
        const validateEnabled = computed(() => normalizedRules.value.length > 0);
        const getFilteredRule = (trigger2) => {
          const rules2 = normalizedRules.value;
          return rules2.filter((rule) => {
            if (!rule.trigger || !trigger2)
              return true;
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          }).map(({ trigger: trigger22, ...rule }) => rule);
        };
        const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
        const shouldShowError = computed(() => {
          var _a2;
          return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
        });
        const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
        const setValidationState = (state) => {
          validateState.value = state;
        };
        const onValidationFailed = (error) => {
          var _a2, _b;
          const { errors, fields } = error;
          if (!errors || !fields) {
            console.error(error);
          }
          setValidationState("error");
          validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
          formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
        };
        const onValidationSucceeded = () => {
          setValidationState("success");
          formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
        };
        const doValidate = async (rules2) => {
          const modelName = propString.value;
          const validator = new Schema({
            [modelName]: rules2
          });
          return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
            onValidationSucceeded();
            return true;
          }).catch((err) => {
            onValidationFailed(err);
            return Promise.reject(err);
          });
        };
        const validate = async (trigger2, callback) => {
          if (isResettingField || !props.prop) {
            return false;
          }
          const hasCallback = isFunction$2(callback);
          if (!validateEnabled.value) {
            callback == null ? void 0 : callback(false);
            return false;
          }
          const rules2 = getFilteredRule(trigger2);
          if (rules2.length === 0) {
            callback == null ? void 0 : callback(true);
            return true;
          }
          setValidationState("validating");
          return doValidate(rules2).then(() => {
            callback == null ? void 0 : callback(true);
            return true;
          }).catch((err) => {
            const { fields } = err;
            callback == null ? void 0 : callback(false, fields);
            return hasCallback ? false : Promise.reject(fields);
          });
        };
        const clearValidate = () => {
          setValidationState("");
          validateMessage.value = "";
          isResettingField = false;
        };
        const resetField = async () => {
          const model = formContext == null ? void 0 : formContext.model;
          if (!model || !props.prop)
            return;
          const computedValue = getProp(model, props.prop);
          isResettingField = true;
          computedValue.value = clone(initialValue);
          await nextTick();
          clearValidate();
          isResettingField = false;
        };
        const addInputId = (id) => {
          if (!inputIds.value.includes(id)) {
            inputIds.value.push(id);
          }
        };
        const removeInputId = (id) => {
          inputIds.value = inputIds.value.filter((listId) => listId !== id);
        };
        watch(() => props.error, (val) => {
          validateMessage.value = val || "";
          setValidationState(val ? "error" : "");
        }, { immediate: true });
        watch(() => props.validateStatus, (val) => setValidationState(val || ""));
        const context = reactive({
          ...toRefs(props),
          $el: formItemRef,
          size: _size,
          validateState,
          labelId,
          inputIds,
          isGroup,
          hasLabel,
          fieldValue,
          addInputId,
          removeInputId,
          resetField,
          clearValidate,
          validate
        });
        provide(formItemContextKey, context);
        onMounted(() => {
          if (props.prop) {
            formContext == null ? void 0 : formContext.addField(context);
            initialValue = clone(fieldValue.value);
          }
        });
        onBeforeUnmount(() => {
          formContext == null ? void 0 : formContext.removeField(context);
        });
        expose({
          size: _size,
          validateMessage,
          validateState,
          validate,
          clearValidate,
          resetField
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("div", {
            ref_key: "formItemRef",
            ref: formItemRef,
            class: normalizeClass(unref(formItemClasses)),
            role: unref(isGroup) ? "group" : void 0,
            "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
          }, [
            createVNode(unref(FormLabelWrap), {
              "is-auto-width": unref(labelStyle).width === "auto",
              "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
            }, {
              default: withCtx(() => [
                unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                  key: 0,
                  id: unref(labelId),
                  for: unref(labelFor),
                  class: normalizeClass(unref(ns).e("label")),
                  style: normalizeStyle(unref(labelStyle))
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                      createTextVNode(toDisplayString(unref(currentLabel)), 1)
                    ])
                  ]),
                  _: 3
                }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["is-auto-width", "update-all"]),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns).e("content")),
              style: normalizeStyle(unref(contentStyle))
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(TransitionGroup, {
                name: `${unref(ns).namespace.value}-zoom-in-top`
              }, {
                default: withCtx(() => [
                  unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                    key: 0,
                    error: validateMessage.value
                  }, () => [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(validateClasses))
                    }, toDisplayString(validateMessage.value), 3)
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 6)
          ], 10, _hoisted_1$v);
        };
      }
    });
    var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "form-item.vue"]]);
    const ElForm = withInstall(Form, {
      FormItem
    });
    const ElFormItem = withNoopInstall(FormItem);
    let hiddenTextarea = void 0;
    const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
    const CONTEXT_STYLE = [
      "letter-spacing",
      "line-height",
      "padding-top",
      "padding-bottom",
      "font-family",
      "font-weight",
      "font-size",
      "text-rendering",
      "text-transform",
      "width",
      "text-indent",
      "padding-left",
      "padding-right",
      "border-width",
      "box-sizing"
    ];
    function calculateNodeStyling(targetElement) {
      const style = window.getComputedStyle(targetElement);
      const boxSizing = style.getPropertyValue("box-sizing");
      const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
      const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
      const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
      return { contextStyle, paddingSize, borderSize, boxSizing };
    }
    function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
      var _a2;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        document.body.appendChild(hiddenTextarea);
      }
      const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
      hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
      hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
      let height = hiddenTextarea.scrollHeight;
      const result = {};
      if (boxSizing === "border-box") {
        height = height + borderSize;
      } else if (boxSizing === "content-box") {
        height = height - paddingSize;
      }
      hiddenTextarea.value = "";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (isNumber(minRows)) {
        let minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
        result.minHeight = `${minHeight}px`;
      }
      if (isNumber(maxRows)) {
        let maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        height = Math.min(maxHeight, height);
      }
      result.height = `${height}px`;
      (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
      hiddenTextarea = void 0;
      return result;
    }
    const inputProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: definePropType([
          String,
          Number,
          Object
        ]),
        default: ""
      },
      maxlength: {
        type: [String, Number]
      },
      minlength: {
        type: [String, Number]
      },
      type: {
        type: String,
        default: "text"
      },
      resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
      },
      autosize: {
        type: definePropType([Boolean, Object]),
        default: false
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      formatter: {
        type: Function
      },
      parser: {
        type: Function
      },
      placeholder: {
        type: String
      },
      form: {
        type: String
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      showPassword: {
        type: Boolean,
        default: false
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      suffixIcon: {
        type: iconPropType
      },
      prefixIcon: {
        type: iconPropType
      },
      containerRole: {
        type: String,
        default: void 0
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: [String, Number],
        default: 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      inputStyle: {
        type: definePropType([Object, Array, String]),
        default: () => mutable({})
      },
      autofocus: {
        type: Boolean,
        default: false
      }
    });
    const inputEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
      input: (value) => isString$1(value),
      change: (value) => isString$1(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      mouseleave: (evt) => evt instanceof MouseEvent,
      mouseenter: (evt) => evt instanceof MouseEvent,
      keydown: (evt) => evt instanceof Event,
      compositionstart: (evt) => evt instanceof CompositionEvent,
      compositionupdate: (evt) => evt instanceof CompositionEvent,
      compositionend: (evt) => evt instanceof CompositionEvent
    };
    const _hoisted_1$u = ["role"];
    const _hoisted_2$i = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
    const _hoisted_3$9 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
    const __default__$B = /* @__PURE__ */ defineComponent({
      name: "ElInput",
      inheritAttrs: false
    });
    const _sfc_main$_ = /* @__PURE__ */ defineComponent({
      ...__default__$B,
      props: inputProps,
      emits: inputEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const rawAttrs = useAttrs$1();
        const slots = useSlots();
        const containerAttrs = computed(() => {
          const comboBoxAttrs = {};
          if (props.containerRole === "combobox") {
            comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
            comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
            comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
          }
          return comboBoxAttrs;
        });
        const containerKls = computed(() => [
          props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
          nsInput.m(inputSize.value),
          nsInput.is("disabled", inputDisabled.value),
          nsInput.is("exceed", inputExceed.value),
          {
            [nsInput.b("group")]: slots.prepend || slots.append,
            [nsInput.bm("group", "append")]: slots.append,
            [nsInput.bm("group", "prepend")]: slots.prepend,
            [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
            [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
            [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
          },
          rawAttrs.class
        ]);
        const wrapperKls = computed(() => [
          nsInput.e("wrapper"),
          nsInput.is("focus", isFocused.value)
        ]);
        const attrs = useAttrs({
          excludeKeys: computed(() => {
            return Object.keys(containerAttrs.value);
          })
        });
        const { form: elForm, formItem: elFormItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: elFormItem
        });
        const inputSize = useFormSize();
        const inputDisabled = useFormDisabled();
        const nsInput = useNamespace("input");
        const nsTextarea = useNamespace("textarea");
        const input = shallowRef();
        const textarea = shallowRef();
        const hovering = ref(false);
        const isComposing = ref(false);
        const passwordVisible = ref(false);
        const countStyle = ref();
        const textareaCalcStyle = shallowRef(props.inputStyle);
        const _ref = computed(() => input.value || textarea.value);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
          afterBlur() {
            var _a2;
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
            }
          }
        });
        const needStatusIcon = computed(() => {
          var _a2;
          return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
        });
        const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
        const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
        const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
        const containerStyle = computed(() => [
          rawAttrs.style
        ]);
        const textareaStyle = computed(() => [
          props.inputStyle,
          textareaCalcStyle.value,
          { resize: props.resize }
        ]);
        const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
        const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
        const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
        const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
        const textLength = computed(() => nativeInputValue.value.length);
        const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
        const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
        const [recordCursor, setCursor] = useCursor(input);
        useResizeObserver(textarea, (entries) => {
          onceInitSizeTextarea();
          if (!isWordLimitVisible.value || props.resize !== "both")
            return;
          const entry = entries[0];
          const { width } = entry.contentRect;
          countStyle.value = {
            right: `calc(100% - ${width + 15 + 6}px)`
          };
        });
        const resizeTextarea = () => {
          const { type, autosize } = props;
          if (!isClient || type !== "textarea" || !textarea.value)
            return;
          if (autosize) {
            const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
            const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
            const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
            textareaCalcStyle.value = {
              overflowY: "hidden",
              ...textareaStyle2
            };
            nextTick(() => {
              textarea.value.offsetHeight;
              textareaCalcStyle.value = textareaStyle2;
            });
          } else {
            textareaCalcStyle.value = {
              minHeight: calcTextareaHeight(textarea.value).minHeight
            };
          }
        };
        const createOnceInitResize = (resizeTextarea2) => {
          let isInit = false;
          return () => {
            var _a2;
            if (isInit || !props.autosize)
              return;
            const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
            if (!isElHidden) {
              resizeTextarea2();
              isInit = true;
            }
          };
        };
        const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
        const setNativeInputValue = () => {
          const input2 = _ref.value;
          const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
          if (!input2 || input2.value === formatterValue)
            return;
          input2.value = formatterValue;
        };
        const handleInput = async (event) => {
          recordCursor();
          let { value } = event.target;
          if (props.formatter) {
            value = props.parser ? props.parser(value) : value;
          }
          if (isComposing.value)
            return;
          if (value === nativeInputValue.value) {
            setNativeInputValue();
            return;
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emit2("input", value);
          await nextTick();
          setNativeInputValue();
          setCursor();
        };
        const handleChange = (event) => {
          emit2("change", event.target.value);
        };
        const handleCompositionStart = (event) => {
          emit2("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit2("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit2("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            handleInput(event);
          }
        };
        const handlePasswordVisible = () => {
          passwordVisible.value = !passwordVisible.value;
          focus();
        };
        const focus = async () => {
          var _a2;
          await nextTick();
          (_a2 = _ref.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
        };
        const handleMouseLeave = (evt) => {
          hovering.value = false;
          emit2("mouseleave", evt);
        };
        const handleMouseEnter = (evt) => {
          hovering.value = true;
          emit2("mouseenter", evt);
        };
        const handleKeydown = (evt) => {
          emit2("keydown", evt);
        };
        const select = () => {
          var _a2;
          (_a2 = _ref.value) == null ? void 0 : _a2.select();
        };
        const clear2 = () => {
          emit2(UPDATE_MODEL_EVENT, "");
          emit2("change", "");
          emit2("clear");
          emit2("input", "");
        };
        watch(() => props.modelValue, () => {
          var _a2;
          nextTick(() => resizeTextarea());
          if (props.validateEvent) {
            (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
          }
        });
        watch(nativeInputValue, () => setNativeInputValue());
        watch(() => props.type, async () => {
          await nextTick();
          setNativeInputValue();
          resizeTextarea();
        });
        onMounted(() => {
          if (!props.formatter && props.parser)
            ;
          setNativeInputValue();
          nextTick(resizeTextarea);
        });
        expose({
          input,
          textarea,
          ref: _ref,
          textareaStyle,
          autosize: toRef(props, "autosize"),
          focus,
          blur,
          select,
          clear: clear2,
          resizeTextarea
        });
        return (_ctx, _cache) => {
          return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
            class: unref(containerKls),
            style: unref(containerStyle),
            role: _ctx.containerRole,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }), [
            createCommentVNode(" input "),
            _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" prepend slot "),
              _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(nsInput).be("group", "prepend"))
              }, [
                renderSlot(_ctx.$slots, "prepend")
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                ref_key: "wrapperRef",
                ref: wrapperRef,
                class: normalizeClass(unref(wrapperKls))
              }, [
                createCommentVNode(" prefix slot "),
                _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("prefix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("prefix-inner"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix"),
                    _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  id: unref(inputId),
                  ref_key: "input",
                  ref: input,
                  class: unref(nsInput).e("inner")
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  tabindex: _ctx.tabindex,
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  style: _ctx.inputStyle,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_2$i),
                createCommentVNode(" suffix slot "),
                unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).e("suffix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("suffix-inner"))
                  }, [
                    !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      renderSlot(_ctx.$slots, "suffix"),
                      _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 64)) : createCommentVNode("v-if", true),
                    unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: clear2
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(circle_close_default))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                    unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                      onClick: handlePasswordVisible
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                      key: 3,
                      class: normalizeClass(unref(nsInput).e("count"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsInput).e("count-inner"))
                      }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 4,
                      class: normalizeClass([
                        unref(nsInput).e("icon"),
                        unref(nsInput).e("validateIcon"),
                        unref(nsInput).is("loading", unref(validateState) === "validating")
                      ])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ], 2),
              createCommentVNode(" append slot "),
              _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(nsInput).be("group", "append"))
              }, [
                renderSlot(_ctx.$slots, "append")
              ], 2)) : createCommentVNode("v-if", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" textarea "),
              createBaseVNode("textarea", mergeProps({
                id: unref(inputId),
                ref_key: "textarea",
                ref: textarea,
                class: unref(nsTextarea).e("inner")
              }, unref(attrs), {
                minlength: _ctx.minlength,
                maxlength: _ctx.maxlength,
                tabindex: _ctx.tabindex,
                disabled: unref(inputDisabled),
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                style: unref(textareaStyle),
                "aria-label": _ctx.label,
                placeholder: _ctx.placeholder,
                form: _ctx.form,
                autofocus: _ctx.autofocus,
                onCompositionstart: handleCompositionStart,
                onCompositionupdate: handleCompositionUpdate,
                onCompositionend: handleCompositionEnd,
                onInput: handleInput,
                onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                onChange: handleChange,
                onKeydown: handleKeydown
              }), null, 16, _hoisted_3$9),
              unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                key: 0,
                style: normalizeStyle(countStyle.value),
                class: normalizeClass(unref(nsInput).e("count"))
              }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
            ], 64))
          ], 16, _hoisted_1$u)), [
            [vShow, _ctx.type !== "hidden"]
          ]);
        };
      }
    });
    var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "input.vue"]]);
    const ElInput = withInstall(Input);
    const GAP = 4;
    const BAR_MAP = {
      vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top"
      },
      horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left"
      }
    };
    const renderThumbStyle = ({
      move,
      size: size2,
      bar
    }) => ({
      [bar.size]: size2,
      transform: `translate${bar.axis}(${move}%)`
    });
    const scrollbarContextKey = Symbol("scrollbarContextKey");
    const thumbProps = buildProps({
      vertical: Boolean,
      size: String,
      move: Number,
      ratio: {
        type: Number,
        required: true
      },
      always: Boolean
    });
    const COMPONENT_NAME$4 = "Thumb";
    const _sfc_main$Z = /* @__PURE__ */ defineComponent({
      __name: "thumb",
      props: thumbProps,
      setup(__props) {
        const props = __props;
        const scrollbar = inject(scrollbarContextKey);
        const ns = useNamespace("scrollbar");
        if (!scrollbar)
          throwError(COMPONENT_NAME$4, "can not inject scrollbar context");
        const instance = ref();
        const thumb = ref();
        const thumbState = ref({});
        const visible = ref(false);
        let cursorDown = false;
        let cursorLeave = false;
        let originalOnSelectStart = isClient ? document.onselectstart : null;
        const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
        const thumbStyle = computed(() => renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value
        }));
        const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
        const clickThumbHandler = (e) => {
          var _a2;
          e.stopPropagation();
          if (e.ctrlKey || [1, 2].includes(e.button))
            return;
          (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
          startDrag(e);
          const el = e.currentTarget;
          if (!el)
            return;
          thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
        };
        const clickTrackHandler = (e) => {
          if (!thumb.value || !instance.value || !scrollbar.wrapElement)
            return;
          const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
          const thumbHalf = thumb.value[bar.value.offset] / 2;
          const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const startDrag = (e) => {
          e.stopImmediatePropagation();
          cursorDown = true;
          document.addEventListener("mousemove", mouseMoveDocumentHandler);
          document.addEventListener("mouseup", mouseUpDocumentHandler);
          originalOnSelectStart = document.onselectstart;
          document.onselectstart = () => false;
        };
        const mouseMoveDocumentHandler = (e) => {
          if (!instance.value || !thumb.value)
            return;
          if (cursorDown === false)
            return;
          const prevPage = thumbState.value[bar.value.axis];
          if (!prevPage)
            return;
          const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
          const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
          const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const mouseUpDocumentHandler = () => {
          cursorDown = false;
          thumbState.value[bar.value.axis] = 0;
          document.removeEventListener("mousemove", mouseMoveDocumentHandler);
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
          restoreOnselectstart();
          if (cursorLeave)
            visible.value = false;
        };
        const mouseMoveScrollbarHandler = () => {
          cursorLeave = false;
          visible.value = !!props.size;
        };
        const mouseLeaveScrollbarHandler = () => {
          cursorLeave = true;
          visible.value = cursorDown;
        };
        onBeforeUnmount(() => {
          restoreOnselectstart();
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
        });
        const restoreOnselectstart = () => {
          if (document.onselectstart !== originalOnSelectStart)
            document.onselectstart = originalOnSelectStart;
        };
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                ref_key: "instance",
                ref: instance,
                class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                onMousedown: clickTrackHandler
              }, [
                createBaseVNode("div", {
                  ref_key: "thumb",
                  ref: thumb,
                  class: normalizeClass(unref(ns).e("thumb")),
                  style: normalizeStyle(unref(thumbStyle)),
                  onMousedown: clickThumbHandler
                }, null, 38)
              ], 34), [
                [vShow, _ctx.always || visible.value]
              ])
            ]),
            _: 1
          }, 8, ["name"]);
        };
      }
    });
    var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "thumb.vue"]]);
    const barProps = buildProps({
      always: {
        type: Boolean,
        default: true
      },
      width: String,
      height: String,
      ratioX: {
        type: Number,
        default: 1
      },
      ratioY: {
        type: Number,
        default: 1
      }
    });
    const _sfc_main$Y = /* @__PURE__ */ defineComponent({
      __name: "bar",
      props: barProps,
      setup(__props, { expose }) {
        const props = __props;
        const moveX = ref(0);
        const moveY = ref(0);
        const handleScroll = (wrap) => {
          if (wrap) {
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
            moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
          }
        };
        expose({
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(Thumb, {
              move: moveX.value,
              ratio: _ctx.ratioX,
              size: _ctx.width,
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"]),
            createVNode(Thumb, {
              move: moveY.value,
              ratio: _ctx.ratioY,
              size: _ctx.height,
              vertical: "",
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"])
          ], 64);
        };
      }
    });
    var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__file", "bar.vue"]]);
    const scrollbarProps = buildProps({
      height: {
        type: [String, Number],
        default: ""
      },
      maxHeight: {
        type: [String, Number],
        default: ""
      },
      native: {
        type: Boolean,
        default: false
      },
      wrapStyle: {
        type: definePropType([String, Object, Array]),
        default: ""
      },
      wrapClass: {
        type: [String, Array],
        default: ""
      },
      viewClass: {
        type: [String, Array],
        default: ""
      },
      viewStyle: {
        type: [String, Array, Object],
        default: ""
      },
      noresize: Boolean,
      tag: {
        type: String,
        default: "div"
      },
      always: Boolean,
      minSize: {
        type: Number,
        default: 20
      },
      id: String,
      role: String,
      ariaLabel: String,
      ariaOrientation: {
        type: String,
        values: ["horizontal", "vertical"]
      }
    });
    const scrollbarEmits = {
      scroll: ({
        scrollTop,
        scrollLeft
      }) => [scrollTop, scrollLeft].every(isNumber)
    };
    const COMPONENT_NAME$3 = "ElScrollbar";
    const __default__$A = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$3
    });
    const _sfc_main$X = /* @__PURE__ */ defineComponent({
      ...__default__$A,
      props: scrollbarProps,
      emits: scrollbarEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("scrollbar");
        let stopResizeObserver = void 0;
        let stopResizeListener = void 0;
        const scrollbarRef = ref();
        const wrapRef = ref();
        const resizeRef = ref();
        const sizeWidth = ref("0");
        const sizeHeight = ref("0");
        const barRef = ref();
        const ratioY = ref(1);
        const ratioX = ref(1);
        const wrapStyle = computed(() => {
          const style = {};
          if (props.height)
            style.height = addUnit(props.height);
          if (props.maxHeight)
            style.maxHeight = addUnit(props.maxHeight);
          return [props.wrapStyle, style];
        });
        const wrapKls = computed(() => {
          return [
            props.wrapClass,
            ns.e("wrap"),
            { [ns.em("wrap", "hidden-default")]: !props.native }
          ];
        });
        const resizeKls = computed(() => {
          return [ns.e("view"), props.viewClass];
        });
        const handleScroll = () => {
          var _a2;
          if (wrapRef.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
            emit2("scroll", {
              scrollTop: wrapRef.value.scrollTop,
              scrollLeft: wrapRef.value.scrollLeft
            });
          }
        };
        function scrollTo(arg1, arg2) {
          if (isObject$1(arg1)) {
            wrapRef.value.scrollTo(arg1);
          } else if (isNumber(arg1) && isNumber(arg2)) {
            wrapRef.value.scrollTo(arg1, arg2);
          }
        }
        const setScrollTop = (value) => {
          if (!isNumber(value)) {
            return;
          }
          wrapRef.value.scrollTop = value;
        };
        const setScrollLeft = (value) => {
          if (!isNumber(value)) {
            return;
          }
          wrapRef.value.scrollLeft = value;
        };
        const update = () => {
          if (!wrapRef.value)
            return;
          const offsetHeight = wrapRef.value.offsetHeight - GAP;
          const offsetWidth = wrapRef.value.offsetWidth - GAP;
          const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
          const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
          const height = Math.max(originalHeight, props.minSize);
          const width = Math.max(originalWidth, props.minSize);
          ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
          ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
          sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
          sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
        };
        watch(() => props.noresize, (noresize) => {
          if (noresize) {
            stopResizeObserver == null ? void 0 : stopResizeObserver();
            stopResizeListener == null ? void 0 : stopResizeListener();
          } else {
            ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
            stopResizeListener = useEventListener("resize", update);
          }
        }, { immediate: true });
        watch(() => [props.maxHeight, props.height], () => {
          if (!props.native)
            nextTick(() => {
              var _a2;
              update();
              if (wrapRef.value) {
                (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              }
            });
        });
        provide(scrollbarContextKey, reactive({
          scrollbarElement: scrollbarRef,
          wrapElement: wrapRef
        }));
        onMounted(() => {
          if (!props.native)
            nextTick(() => {
              update();
            });
        });
        onUpdated(() => update());
        expose({
          wrapRef,
          update,
          scrollTo,
          setScrollTop,
          setScrollLeft,
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "scrollbarRef",
            ref: scrollbarRef,
            class: normalizeClass(unref(ns).b())
          }, [
            createBaseVNode("div", {
              ref_key: "wrapRef",
              ref: wrapRef,
              class: normalizeClass(unref(wrapKls)),
              style: normalizeStyle(unref(wrapStyle)),
              onScroll: handleScroll
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                id: _ctx.id,
                ref_key: "resizeRef",
                ref: resizeRef,
                class: normalizeClass(unref(resizeKls)),
                style: normalizeStyle(_ctx.viewStyle),
                role: _ctx.role,
                "aria-label": _ctx.ariaLabel,
                "aria-orientation": _ctx.ariaOrientation
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
            ], 38),
            !_ctx.native ? (openBlock(), createBlock(Bar, {
              key: 0,
              ref_key: "barRef",
              ref: barRef,
              height: sizeHeight.value,
              width: sizeWidth.value,
              always: _ctx.always,
              "ratio-x": ratioX.value,
              "ratio-y": ratioY.value
            }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__file", "scrollbar.vue"]]);
    const ElScrollbar = withInstall(Scrollbar);
    const POPPER_INJECTION_KEY = Symbol("popper");
    const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
    const roleTypes = [
      "dialog",
      "grid",
      "group",
      "listbox",
      "menu",
      "navigation",
      "tooltip",
      "tree"
    ];
    const popperProps = buildProps({
      role: {
        type: String,
        values: roleTypes,
        default: "tooltip"
      }
    });
    const __default__$z = /* @__PURE__ */ defineComponent({
      name: "ElPopper",
      inheritAttrs: false
    });
    const _sfc_main$W = /* @__PURE__ */ defineComponent({
      ...__default__$z,
      props: popperProps,
      setup(__props, { expose }) {
        const props = __props;
        const triggerRef = ref();
        const popperInstanceRef = ref();
        const contentRef = ref();
        const referenceRef = ref();
        const role = computed(() => props.role);
        const popperProvides = {
          triggerRef,
          popperInstanceRef,
          contentRef,
          referenceRef,
          role
        };
        expose(popperProvides);
        provide(POPPER_INJECTION_KEY, popperProvides);
        return (_ctx, _cache) => {
          return renderSlot(_ctx.$slots, "default");
        };
      }
    });
    var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "popper.vue"]]);
    const popperArrowProps = buildProps({
      arrowOffset: {
        type: Number,
        default: 5
      }
    });
    const __default__$y = /* @__PURE__ */ defineComponent({
      name: "ElPopperArrow",
      inheritAttrs: false
    });
    const _sfc_main$V = /* @__PURE__ */ defineComponent({
      ...__default__$y,
      props: popperArrowProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("popper");
        const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
        watch(() => props.arrowOffset, (val) => {
          arrowOffset.value = val;
        });
        onBeforeUnmount(() => {
          arrowRef.value = void 0;
        });
        expose({
          arrowRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            ref_key: "arrowRef",
            ref: arrowRef,
            class: normalizeClass(unref(ns).e("arrow")),
            style: normalizeStyle(unref(arrowStyle)),
            "data-popper-arrow": ""
          }, null, 6);
        };
      }
    });
    var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__file", "arrow.vue"]]);
    const NAME = "ElOnlyChild";
    const OnlyChild = /* @__PURE__ */ defineComponent({
      name: NAME,
      setup(_2, {
        slots,
        attrs
      }) {
        var _a2;
        const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
        const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
        return () => {
          var _a22;
          const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
          if (!defaultSlot)
            return null;
          if (defaultSlot.length > 1) {
            return null;
          }
          const firstLegitNode = findFirstLegitChild(defaultSlot);
          if (!firstLegitNode) {
            return null;
          }
          return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
        };
      }
    });
    function findFirstLegitChild(node) {
      if (!node)
        return null;
      const children = node;
      for (const child of children) {
        if (isObject$1(child)) {
          switch (child.type) {
            case Comment:
              continue;
            case Text$1:
            case "svg":
              return wrapTextContent(child);
            case Fragment:
              return findFirstLegitChild(child.children);
            default:
              return child;
          }
        }
        return wrapTextContent(child);
      }
      return null;
    }
    function wrapTextContent(s2) {
      const ns = useNamespace("only-child");
      return createVNode("span", {
        "class": ns.e("content")
      }, [s2]);
    }
    const popperTriggerProps = buildProps({
      virtualRef: {
        type: definePropType(Object)
      },
      virtualTriggering: Boolean,
      onMouseenter: {
        type: definePropType(Function)
      },
      onMouseleave: {
        type: definePropType(Function)
      },
      onClick: {
        type: definePropType(Function)
      },
      onKeydown: {
        type: definePropType(Function)
      },
      onFocus: {
        type: definePropType(Function)
      },
      onBlur: {
        type: definePropType(Function)
      },
      onContextmenu: {
        type: definePropType(Function)
      },
      id: String,
      open: Boolean
    });
    const __default__$x = /* @__PURE__ */ defineComponent({
      name: "ElPopperTrigger",
      inheritAttrs: false
    });
    const _sfc_main$U = /* @__PURE__ */ defineComponent({
      ...__default__$x,
      props: popperTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
        useForwardRef(triggerRef);
        const ariaControls = computed(() => {
          return ariaHaspopup.value ? props.id : void 0;
        });
        const ariaDescribedby = computed(() => {
          if (role && role.value === "tooltip") {
            return props.open && props.id ? props.id : void 0;
          }
          return void 0;
        });
        const ariaHaspopup = computed(() => {
          if (role && role.value !== "tooltip") {
            return role.value;
          }
          return void 0;
        });
        const ariaExpanded = computed(() => {
          return ariaHaspopup.value ? `${props.open}` : void 0;
        });
        let virtualTriggerAriaStopWatch = void 0;
        onMounted(() => {
          watch(() => props.virtualRef, (virtualEl) => {
            if (virtualEl) {
              triggerRef.value = unrefElement(virtualEl);
            }
          }, {
            immediate: true
          });
          watch(triggerRef, (el, prevEl) => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (isElement(el)) {
              [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
              ].forEach((eventName) => {
                var _a2;
                const handler = props[eventName];
                if (handler) {
                  el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                  (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                }
              });
              virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (isElement(prevEl)) {
              [
                "aria-controls",
                "aria-describedby",
                "aria-haspopup",
                "aria-expanded"
              ].forEach((key) => prevEl.removeAttribute(key));
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
          virtualTriggerAriaStopWatch = void 0;
        });
        expose({
          triggerRef
        });
        return (_ctx, _cache) => {
          return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
            "aria-controls": unref(ariaControls),
            "aria-describedby": unref(ariaDescribedby),
            "aria-expanded": unref(ariaExpanded),
            "aria-haspopup": unref(ariaHaspopup)
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
        };
      }
    });
    var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["__file", "trigger.vue"]]);
    const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
    const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
    const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
    const FOCUS_AFTER_TRAPPED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const FOCUSOUT_PREVENTED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
    const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
    const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
    const focusReason = ref();
    const lastUserFocusTimestamp = ref(0);
    const lastAutomatedFocusTimestamp = ref(0);
    let focusReasonUserCount = 0;
    const obtainAllFocusableElements = (element) => {
      const nodes = [];
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
          if (node.disabled || node.hidden || isHiddenInput)
            return NodeFilter.FILTER_SKIP;
          return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      });
      while (walker.nextNode())
        nodes.push(walker.currentNode);
      return nodes;
    };
    const getVisibleElement = (elements, container) => {
      for (const element of elements) {
        if (!isHidden(element, container))
          return element;
      }
    };
    const isHidden = (element, container) => {
      if (getComputedStyle(element).visibility === "hidden")
        return true;
      while (element) {
        if (container && element === container)
          return false;
        if (getComputedStyle(element).display === "none")
          return true;
        element = element.parentElement;
      }
      return false;
    };
    const getEdges = (container) => {
      const focusable = obtainAllFocusableElements(container);
      const first = getVisibleElement(focusable, container);
      const last = getVisibleElement(focusable.reverse(), container);
      return [first, last];
    };
    const isSelectable = (element) => {
      return element instanceof HTMLInputElement && "select" in element;
    };
    const tryFocus = (element, shouldSelect) => {
      if (element && element.focus) {
        const prevFocusedElement = document.activeElement;
        element.focus({ preventScroll: true });
        lastAutomatedFocusTimestamp.value = window.performance.now();
        if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
          element.select();
        }
      }
    };
    function removeFromStack(list, item) {
      const copy = [...list];
      const idx = list.indexOf(item);
      if (idx !== -1) {
        copy.splice(idx, 1);
      }
      return copy;
    }
    const createFocusableStack = () => {
      let stack2 = [];
      const push = (layer) => {
        const currentLayer = stack2[0];
        if (currentLayer && layer !== currentLayer) {
          currentLayer.pause();
        }
        stack2 = removeFromStack(stack2, layer);
        stack2.unshift(layer);
      };
      const remove2 = (layer) => {
        var _a2, _b;
        stack2 = removeFromStack(stack2, layer);
        (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
      };
      return {
        push,
        remove: remove2
      };
    };
    const focusFirstDescendant = (elements, shouldSelect = false) => {
      const prevFocusedElement = document.activeElement;
      for (const element of elements) {
        tryFocus(element, shouldSelect);
        if (document.activeElement !== prevFocusedElement)
          return;
      }
    };
    const focusableStack = createFocusableStack();
    const isFocusCausedByUserEvent = () => {
      return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
    };
    const notifyFocusReasonPointer = () => {
      focusReason.value = "pointer";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const notifyFocusReasonKeydown = () => {
      focusReason.value = "keyboard";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const useFocusReason = () => {
      onMounted(() => {
        if (focusReasonUserCount === 0) {
          document.addEventListener("mousedown", notifyFocusReasonPointer);
          document.addEventListener("touchstart", notifyFocusReasonPointer);
          document.addEventListener("keydown", notifyFocusReasonKeydown);
        }
        focusReasonUserCount++;
      });
      onBeforeUnmount(() => {
        focusReasonUserCount--;
        if (focusReasonUserCount <= 0) {
          document.removeEventListener("mousedown", notifyFocusReasonPointer);
          document.removeEventListener("touchstart", notifyFocusReasonPointer);
          document.removeEventListener("keydown", notifyFocusReasonKeydown);
        }
      });
      return {
        focusReason,
        lastUserFocusTimestamp,
        lastAutomatedFocusTimestamp
      };
    };
    const createFocusOutPreventedEvent = (detail) => {
      return new CustomEvent(FOCUSOUT_PREVENTED, {
        ...FOCUSOUT_PREVENTED_OPTS,
        detail
      });
    };
    const _sfc_main$T = /* @__PURE__ */ defineComponent({
      name: "ElFocusTrap",
      inheritAttrs: false,
      props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
          type: [Object, String],
          default: "first"
        }
      },
      emits: [
        ON_TRAP_FOCUS_EVT,
        ON_RELEASE_FOCUS_EVT,
        "focusin",
        "focusout",
        "focusout-prevented",
        "release-requested"
      ],
      setup(props, { emit: emit2 }) {
        const forwardRef = ref();
        let lastFocusBeforeTrapped;
        let lastFocusAfterTrapped;
        const { focusReason: focusReason2 } = useFocusReason();
        useEscapeKeydown((event) => {
          if (props.trapped && !focusLayer.paused) {
            emit2("release-requested", event);
          }
        });
        const focusLayer = {
          paused: false,
          pause() {
            this.paused = true;
          },
          resume() {
            this.paused = false;
          }
        };
        const onKeydown = (e) => {
          if (!props.loop && !props.trapped)
            return;
          if (focusLayer.paused)
            return;
          const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
          const { loop } = props;
          const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
          const currentFocusingEl = document.activeElement;
          if (isTabbing && currentFocusingEl) {
            const container = currentTarget;
            const [first, last] = getEdges(container);
            const isTabbable = first && last;
            if (!isTabbable) {
              if (currentFocusingEl === container) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                }
              }
            } else {
              if (!shiftKey && currentFocusingEl === last) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                  if (loop)
                    tryFocus(first, true);
                }
              } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                  if (loop)
                    tryFocus(last, true);
                }
              }
            }
          }
        };
        provide(FOCUS_TRAP_INJECTION_KEY, {
          focusTrapRef: forwardRef,
          onKeydown
        });
        watch(() => props.focusTrapEl, (focusTrapEl) => {
          if (focusTrapEl) {
            forwardRef.value = focusTrapEl;
          }
        }, { immediate: true });
        watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
          if (forwardRef2) {
            forwardRef2.addEventListener("keydown", onKeydown);
            forwardRef2.addEventListener("focusin", onFocusIn);
            forwardRef2.addEventListener("focusout", onFocusOut);
          }
          if (oldForwardRef) {
            oldForwardRef.removeEventListener("keydown", onKeydown);
            oldForwardRef.removeEventListener("focusin", onFocusIn);
            oldForwardRef.removeEventListener("focusout", onFocusOut);
          }
        });
        const trapOnFocus = (e) => {
          emit2(ON_TRAP_FOCUS_EVT, e);
        };
        const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
        const onFocusIn = (e) => {
          const trapContainer = unref(forwardRef);
          if (!trapContainer)
            return;
          const target = e.target;
          const relatedTarget = e.relatedTarget;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (!props.trapped) {
            const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
            if (!isPrevFocusedInTrap) {
              lastFocusBeforeTrapped = relatedTarget;
            }
          }
          if (isFocusedInTrap)
            emit2("focusin", e);
          if (focusLayer.paused)
            return;
          if (props.trapped) {
            if (isFocusedInTrap) {
              lastFocusAfterTrapped = target;
            } else {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }
        };
        const onFocusOut = (e) => {
          const trapContainer = unref(forwardRef);
          if (focusLayer.paused || !trapContainer)
            return;
          if (props.trapped) {
            const relatedTarget = e.relatedTarget;
            if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
              setTimeout(() => {
                if (!focusLayer.paused && props.trapped) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    tryFocus(lastFocusAfterTrapped, true);
                  }
                }
              }, 0);
            }
          } else {
            const target = e.target;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!isFocusedInTrap)
              emit2("focusout", e);
          }
        };
        async function startTrap() {
          await nextTick();
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            focusableStack.push(focusLayer);
            const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
            lastFocusBeforeTrapped = prevFocusedElement;
            const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
            if (!isPrevFocusContained) {
              const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
              trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              trapContainer.dispatchEvent(focusEvent);
              if (!focusEvent.defaultPrevented) {
                nextTick(() => {
                  let focusStartEl = props.focusStartEl;
                  if (!isString$1(focusStartEl)) {
                    tryFocus(focusStartEl);
                    if (document.activeElement !== focusStartEl) {
                      focusStartEl = "first";
                    }
                  }
                  if (focusStartEl === "first") {
                    focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                  }
                  if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                    tryFocus(trapContainer);
                  }
                });
              }
            }
          }
        }
        function stopTrap() {
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
            const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
              ...FOCUS_AFTER_TRAPPED_OPTS,
              detail: {
                focusReason: focusReason2.value
              }
            });
            trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            trapContainer.dispatchEvent(releasedEvent);
            if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
              tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
            }
            trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            focusableStack.remove(focusLayer);
          }
        }
        onMounted(() => {
          if (props.trapped) {
            startTrap();
          }
          watch(() => props.trapped, (trapped) => {
            if (trapped) {
              startTrap();
            } else {
              stopTrap();
            }
          });
        });
        onBeforeUnmount(() => {
          if (props.trapped) {
            stopTrap();
          }
        });
        return {
          onKeydown
        };
      }
    });
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
    }
    var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["render", _sfc_render$g], ["__file", "focus-trap.vue"]]);
    const POSITIONING_STRATEGIES = ["fixed", "absolute"];
    const popperCoreConfigProps = buildProps({
      boundariesPadding: {
        type: Number,
        default: 0
      },
      fallbackPlacements: {
        type: definePropType(Array),
        default: void 0
      },
      gpuAcceleration: {
        type: Boolean,
        default: true
      },
      offset: {
        type: Number,
        default: 12
      },
      placement: {
        type: String,
        values: Ee,
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      strategy: {
        type: String,
        values: POSITIONING_STRATEGIES,
        default: "absolute"
      }
    });
    const popperContentProps = buildProps({
      ...popperCoreConfigProps,
      id: String,
      style: {
        type: definePropType([String, Array, Object])
      },
      className: {
        type: definePropType([String, Array, Object])
      },
      effect: {
        type: String,
        default: "dark"
      },
      visible: Boolean,
      enterable: {
        type: Boolean,
        default: true
      },
      pure: Boolean,
      focusOnShow: {
        type: Boolean,
        default: false
      },
      trapping: {
        type: Boolean,
        default: false
      },
      popperClass: {
        type: definePropType([String, Array, Object])
      },
      popperStyle: {
        type: definePropType([String, Array, Object])
      },
      referenceEl: {
        type: definePropType(Object)
      },
      triggerTargetEl: {
        type: definePropType(Object)
      },
      stopPopperMouseEvent: {
        type: Boolean,
        default: true
      },
      ariaLabel: {
        type: String,
        default: void 0
      },
      virtualTriggering: Boolean,
      zIndex: Number
    });
    const popperContentEmits = {
      mouseenter: (evt) => evt instanceof MouseEvent,
      mouseleave: (evt) => evt instanceof MouseEvent,
      focus: () => true,
      blur: () => true,
      close: () => true
    };
    const buildPopperOptions = (props, modifiers = []) => {
      const { placement, strategy, popperOptions } = props;
      const options = {
        placement,
        strategy,
        ...popperOptions,
        modifiers: [...genModifiers(props), ...modifiers]
      };
      deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
      return options;
    };
    const unwrapMeasurableEl = ($el) => {
      if (!isClient)
        return;
      return unrefElement($el);
    };
    function genModifiers(options) {
      const { offset, gpuAcceleration, fallbackPlacements } = options;
      return [
        {
          name: "offset",
          options: {
            offset: [0, offset != null ? offset : 12]
          }
        },
        {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        },
        {
          name: "flip",
          options: {
            padding: 5,
            fallbackPlacements
          }
        },
        {
          name: "computeStyles",
          options: {
            gpuAcceleration
          }
        }
      ];
    }
    function deriveExtraModifiers(options, modifiers) {
      if (modifiers) {
        options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
      }
    }
    const DEFAULT_ARROW_OFFSET = 0;
    const usePopperContent = (props) => {
      const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
      const arrowRef = ref();
      const arrowOffset = ref();
      const eventListenerModifier = computed(() => {
        return {
          name: "eventListeners",
          enabled: !!props.visible
        };
      });
      const arrowModifier = computed(() => {
        var _a2;
        const arrowEl = unref(arrowRef);
        const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
        return {
          name: "arrow",
          enabled: !isUndefined$1(arrowEl),
          options: {
            element: arrowEl,
            padding: offset
          }
        };
      });
      const options = computed(() => {
        return {
          onFirstUpdate: () => {
            update();
          },
          ...buildPopperOptions(props, [
            unref(arrowModifier),
            unref(eventListenerModifier)
          ])
        };
      });
      const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
      const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
      watch(instanceRef, (instance) => popperInstanceRef.value = instance);
      onMounted(() => {
        watch(() => {
          var _a2;
          return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
        }, () => {
          update();
        });
      });
      return {
        attributes,
        arrowRef,
        contentRef,
        instanceRef,
        state,
        styles,
        role,
        forceUpdate,
        update
      };
    };
    const usePopperContentDOM = (props, {
      attributes,
      styles,
      role
    }) => {
      const { nextZIndex } = useZIndex();
      const ns = useNamespace("popper");
      const contentAttrs = computed(() => unref(attributes).popper);
      const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
      const contentClass = computed(() => [
        ns.b(),
        ns.is("pure", props.pure),
        ns.is(props.effect),
        props.popperClass
      ]);
      const contentStyle = computed(() => {
        return [
          { zIndex: unref(contentZIndex) },
          unref(styles).popper,
          props.popperStyle || {}
        ];
      });
      const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
      const arrowStyle = computed(() => unref(styles).arrow || {});
      const updateZIndex = () => {
        contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
      };
      return {
        ariaModal,
        arrowStyle,
        contentAttrs,
        contentClass,
        contentStyle,
        contentZIndex,
        updateZIndex
      };
    };
    const usePopperContentFocusTrap = (props, emit2) => {
      const trapped = ref(false);
      const focusStartRef = ref();
      const onFocusAfterTrapped = () => {
        emit2("focus");
      };
      const onFocusAfterReleased = (event) => {
        var _a2;
        if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
          focusStartRef.value = "first";
          emit2("blur");
        }
      };
      const onFocusInTrap = (event) => {
        if (props.visible && !trapped.value) {
          if (event.target) {
            focusStartRef.value = event.target;
          }
          trapped.value = true;
        }
      };
      const onFocusoutPrevented = (event) => {
        if (!props.trapping) {
          if (event.detail.focusReason === "pointer") {
            event.preventDefault();
          }
          trapped.value = false;
        }
      };
      const onReleaseRequested = () => {
        trapped.value = false;
        emit2("close");
      };
      return {
        focusStartRef,
        trapped,
        onFocusAfterReleased,
        onFocusAfterTrapped,
        onFocusInTrap,
        onFocusoutPrevented,
        onReleaseRequested
      };
    };
    const __default__$w = /* @__PURE__ */ defineComponent({
      name: "ElPopperContent"
    });
    const _sfc_main$S = /* @__PURE__ */ defineComponent({
      ...__default__$w,
      props: popperContentProps,
      emits: popperContentEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        } = usePopperContentFocusTrap(props, emit2);
        const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
        const {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          updateZIndex
        } = usePopperContentDOM(props, {
          styles,
          attributes,
          role
        });
        const formItemContext = inject(formItemContextKey, void 0);
        const arrowOffset = ref();
        provide(POPPER_CONTENT_INJECTION_KEY, {
          arrowStyle,
          arrowRef,
          arrowOffset
        });
        if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
          provide(formItemContextKey, {
            ...formItemContext,
            addInputId: NOOP,
            removeInputId: NOOP
          });
        }
        let triggerTargetAriaStopWatch = void 0;
        const updatePopper = (shouldUpdateZIndex = true) => {
          update();
          shouldUpdateZIndex && updateZIndex();
        };
        const togglePopperAlive = () => {
          updatePopper(false);
          if (props.visible && props.focusOnShow) {
            trapped.value = true;
          } else if (props.visible === false) {
            trapped.value = false;
          }
        };
        onMounted(() => {
          watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
            const el = unref(triggerTargetEl || contentRef.value);
            const prevEl = unref(prevTriggerTargetEl || contentRef.value);
            if (isElement(el)) {
              triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (prevEl !== el && isElement(prevEl)) {
              ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                prevEl.removeAttribute(key);
              });
            }
          }, { immediate: true });
          watch(() => props.visible, togglePopperAlive, { immediate: true });
        });
        onBeforeUnmount(() => {
          triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
          triggerTargetAriaStopWatch = void 0;
        });
        expose({
          popperContentRef: contentRef,
          popperInstanceRef: instanceRef,
          updatePopper,
          contentStyle
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({
            ref_key: "contentRef",
            ref: contentRef
          }, unref(contentAttrs), {
            style: unref(contentStyle),
            class: unref(contentClass),
            tabindex: "-1",
            onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
            onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
          }), [
            createVNode(unref(ElFocusTrap), {
              trapped: unref(trapped),
              "trap-on-focus-in": true,
              "focus-trap-el": unref(contentRef),
              "focus-start-el": unref(focusStartRef),
              onFocusAfterTrapped: unref(onFocusAfterTrapped),
              onFocusAfterReleased: unref(onFocusAfterReleased),
              onFocusin: unref(onFocusInTrap),
              onFocusoutPrevented: unref(onFocusoutPrevented),
              onReleaseRequested: unref(onReleaseRequested)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
          ], 16);
        };
      }
    });
    var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__file", "content.vue"]]);
    const ElPopper = withInstall(Popper);
    const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
    const useTooltipContentProps = buildProps({
      ...useDelayedToggleProps,
      ...popperContentProps,
      appendTo: {
        type: definePropType([String, Object])
      },
      content: {
        type: String,
        default: ""
      },
      rawContent: {
        type: Boolean,
        default: false
      },
      persistent: Boolean,
      ariaLabel: String,
      visible: {
        type: definePropType(Boolean),
        default: null
      },
      transition: String,
      teleported: {
        type: Boolean,
        default: true
      },
      disabled: Boolean
    });
    const useTooltipTriggerProps = buildProps({
      ...popperTriggerProps,
      disabled: Boolean,
      trigger: {
        type: definePropType([String, Array]),
        default: "hover"
      },
      triggerKeys: {
        type: definePropType(Array),
        default: () => [EVENT_CODE.enter, EVENT_CODE.space]
      }
    });
    const {
      useModelToggleProps: useTooltipModelToggleProps,
      useModelToggleEmits: useTooltipModelToggleEmits,
      useModelToggle: useTooltipModelToggle
    } = createModelToggleComposable("visible");
    const useTooltipProps = buildProps({
      ...popperProps,
      ...useTooltipModelToggleProps,
      ...useTooltipContentProps,
      ...useTooltipTriggerProps,
      ...popperArrowProps,
      showArrow: {
        type: Boolean,
        default: true
      }
    });
    const tooltipEmits = [
      ...useTooltipModelToggleEmits,
      "before-show",
      "before-hide",
      "show",
      "hide",
      "open",
      "close"
    ];
    const isTriggerType = (trigger2, type) => {
      if (isArray$1(trigger2)) {
        return trigger2.includes(type);
      }
      return trigger2 === type;
    };
    const whenTrigger = (trigger2, type, handler) => {
      return (e) => {
        isTriggerType(unref(trigger2), type) && handler(e);
      };
    };
    const __default__$v = /* @__PURE__ */ defineComponent({
      name: "ElTooltipTrigger"
    });
    const _sfc_main$R = /* @__PURE__ */ defineComponent({
      ...__default__$v,
      props: useTooltipTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("tooltip");
        const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const triggerRef = ref(null);
        const stopWhenControlledOrDisabled = () => {
          if (unref(controlled) || props.disabled) {
            return true;
          }
        };
        const trigger2 = toRef(props, "trigger");
        const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
        const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
        const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
          if (e.button === 0) {
            onToggle(e);
          }
        }));
        const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
        const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
        const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
          e.preventDefault();
          onToggle(e);
        }));
        const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
          const { code } = e;
          if (props.triggerKeys.includes(code)) {
            e.preventDefault();
            onToggle(e);
          }
        });
        expose({
          triggerRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopperTrigger), {
            id: unref(id),
            "virtual-ref": _ctx.virtualRef,
            open: unref(open),
            "virtual-triggering": _ctx.virtualTriggering,
            class: normalizeClass(unref(ns).e("trigger")),
            onBlur: unref(onBlur),
            onClick: unref(onClick),
            onContextmenu: unref(onContextMenu),
            onFocus: unref(onFocus),
            onMouseenter: unref(onMouseenter),
            onMouseleave: unref(onMouseleave),
            onKeydown: unref(onKeydown)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
        };
      }
    });
    var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "trigger.vue"]]);
    const __default__$u = /* @__PURE__ */ defineComponent({
      name: "ElTooltipContent",
      inheritAttrs: false
    });
    const _sfc_main$Q = /* @__PURE__ */ defineComponent({
      ...__default__$u,
      props: useTooltipContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const { selector } = usePopperContainerId();
        const ns = useNamespace("tooltip");
        const contentRef = ref(null);
        const destroyed = ref(false);
        const {
          controlled,
          id,
          open,
          trigger: trigger2,
          onClose,
          onOpen,
          onShow,
          onHide,
          onBeforeShow,
          onBeforeHide
        } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const transitionClass = computed(() => {
          return props.transition || `${ns.namespace.value}-fade-in-linear`;
        });
        const persistentRef = computed(() => {
          return props.persistent;
        });
        onBeforeUnmount(() => {
          destroyed.value = true;
        });
        const shouldRender = computed(() => {
          return unref(persistentRef) ? true : unref(open);
        });
        const shouldShow = computed(() => {
          return props.disabled ? false : unref(open);
        });
        const appendTo = computed(() => {
          return props.appendTo || selector.value;
        });
        const contentStyle = computed(() => {
          var _a2;
          return (_a2 = props.style) != null ? _a2 : {};
        });
        const ariaHidden = computed(() => !unref(open));
        const onTransitionLeave = () => {
          onHide();
        };
        const stopWhenControlled = () => {
          if (unref(controlled))
            return true;
        };
        const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
          if (props.enterable && unref(trigger2) === "hover") {
            onOpen();
          }
        });
        const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
          if (unref(trigger2) === "hover") {
            onClose();
          }
        });
        const onBeforeEnter = () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          onBeforeShow == null ? void 0 : onBeforeShow();
        };
        const onBeforeLeave = () => {
          onBeforeHide == null ? void 0 : onBeforeHide();
        };
        const onAfterShow = () => {
          onShow();
          stopHandle = onClickOutside(computed(() => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
          }), () => {
            if (unref(controlled))
              return;
            const $trigger = unref(trigger2);
            if ($trigger !== "hover") {
              onClose();
            }
          });
        };
        const onBlur = () => {
          if (!props.virtualTriggering) {
            onClose();
          }
        };
        let stopHandle;
        watch(() => unref(open), (val) => {
          if (!val) {
            stopHandle == null ? void 0 : stopHandle();
          }
        }, {
          flush: "post"
        });
        watch(() => props.content, () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        });
        expose({
          contentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            disabled: !_ctx.teleported,
            to: unref(appendTo)
          }, [
            createVNode(Transition, {
              name: unref(transitionClass),
              onAfterLeave: onTransitionLeave,
              onBeforeEnter,
              onAfterEnter: onAfterShow,
              onBeforeLeave
            }, {
              default: withCtx(() => [
                unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                  key: 0,
                  id: unref(id),
                  ref_key: "contentRef",
                  ref: contentRef
                }, _ctx.$attrs, {
                  "aria-label": _ctx.ariaLabel,
                  "aria-hidden": unref(ariaHidden),
                  "boundaries-padding": _ctx.boundariesPadding,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  strategy: _ctx.strategy,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  pure: _ctx.pure,
                  "popper-class": _ctx.popperClass,
                  "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  visible: unref(shouldShow),
                  "z-index": _ctx.zIndex,
                  onMouseenter: unref(onContentEnter),
                  onMouseleave: unref(onContentLeave),
                  onBlur,
                  onClose: unref(onClose)
                }), {
                  default: withCtx(() => [
                    !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                  [vShow, unref(shouldShow)]
                ]) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["name"])
          ], 8, ["disabled", "to"]);
        };
      }
    });
    var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "content.vue"]]);
    const _hoisted_1$t = ["innerHTML"];
    const _hoisted_2$h = { key: 1 };
    const __default__$t = /* @__PURE__ */ defineComponent({
      name: "ElTooltip"
    });
    const _sfc_main$P = /* @__PURE__ */ defineComponent({
      ...__default__$t,
      props: useTooltipProps,
      emits: tooltipEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        usePopperContainer();
        const id = useId();
        const popperRef = ref();
        const contentRef = ref();
        const updatePopper = () => {
          var _a2;
          const popperComponent = unref(popperRef);
          if (popperComponent) {
            (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
          }
        };
        const open = ref(false);
        const toggleReason = ref();
        const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
          indicator: open,
          toggleReason
        });
        const { onOpen, onClose } = useDelayedToggle({
          showAfter: toRef(props, "showAfter"),
          hideAfter: toRef(props, "hideAfter"),
          autoClose: toRef(props, "autoClose"),
          open: show,
          close: hide
        });
        const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
        provide(TOOLTIP_INJECTION_KEY, {
          controlled,
          id,
          open: readonly(open),
          trigger: toRef(props, "trigger"),
          onOpen: (event) => {
            onOpen(event);
          },
          onClose: (event) => {
            onClose(event);
          },
          onToggle: (event) => {
            if (unref(open)) {
              onClose(event);
            } else {
              onOpen(event);
            }
          },
          onShow: () => {
            emit2("show", toggleReason.value);
          },
          onHide: () => {
            emit2("hide", toggleReason.value);
          },
          onBeforeShow: () => {
            emit2("before-show", toggleReason.value);
          },
          onBeforeHide: () => {
            emit2("before-hide", toggleReason.value);
          },
          updatePopper
        });
        watch(() => props.disabled, (disabled) => {
          if (disabled && open.value) {
            open.value = false;
          }
        });
        const isFocusInsideContent = (event) => {
          var _a2, _b;
          const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
          const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
          return popperContent && popperContent.contains(activeElement);
        };
        onDeactivated(() => open.value && hide());
        expose({
          popperRef,
          contentRef,
          isFocusInsideContent,
          updatePopper,
          onOpen,
          onClose,
          hide
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopper), {
            ref_key: "popperRef",
            ref: popperRef,
            role: _ctx.role
          }, {
            default: withCtx(() => [
              createVNode(ElTooltipTrigger, {
                disabled: _ctx.disabled,
                trigger: _ctx.trigger,
                "trigger-keys": _ctx.triggerKeys,
                "virtual-ref": _ctx.virtualRef,
                "virtual-triggering": _ctx.virtualTriggering
              }, {
                default: withCtx(() => [
                  _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
              createVNode(ElTooltipContent, {
                ref_key: "contentRef",
                ref: contentRef,
                "aria-label": _ctx.ariaLabel,
                "boundaries-padding": _ctx.boundariesPadding,
                content: _ctx.content,
                disabled: _ctx.disabled,
                effect: _ctx.effect,
                enterable: _ctx.enterable,
                "fallback-placements": _ctx.fallbackPlacements,
                "hide-after": _ctx.hideAfter,
                "gpu-acceleration": _ctx.gpuAcceleration,
                offset: _ctx.offset,
                persistent: _ctx.persistent,
                "popper-class": _ctx.popperClass,
                "popper-style": _ctx.popperStyle,
                placement: _ctx.placement,
                "popper-options": _ctx.popperOptions,
                pure: _ctx.pure,
                "raw-content": _ctx.rawContent,
                "reference-el": _ctx.referenceEl,
                "trigger-target-el": _ctx.triggerTargetEl,
                "show-after": _ctx.showAfter,
                strategy: _ctx.strategy,
                teleported: _ctx.teleported,
                transition: _ctx.transition,
                "virtual-triggering": _ctx.virtualTriggering,
                "z-index": _ctx.zIndex,
                "append-to": _ctx.appendTo
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      innerHTML: _ctx.content
                    }, null, 8, _hoisted_1$t)) : (openBlock(), createElementBlock("span", _hoisted_2$h, toDisplayString(_ctx.content), 1))
                  ]),
                  _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                    key: 0,
                    "arrow-offset": _ctx.arrowOffset
                  }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
            ]),
            _: 3
          }, 8, ["role"]);
        };
      }
    });
    var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["__file", "tooltip.vue"]]);
    const ElTooltip = withInstall(Tooltip);
    const badgeProps = buildProps({
      value: {
        type: [String, Number],
        default: ""
      },
      max: {
        type: Number,
        default: 99
      },
      isDot: Boolean,
      hidden: Boolean,
      type: {
        type: String,
        values: ["primary", "success", "warning", "info", "danger"],
        default: "danger"
      }
    });
    const _hoisted_1$s = ["textContent"];
    const __default__$s = /* @__PURE__ */ defineComponent({
      name: "ElBadge"
    });
    const _sfc_main$O = /* @__PURE__ */ defineComponent({
      ...__default__$s,
      props: badgeProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("badge");
        const content = computed(() => {
          if (props.isDot)
            return "";
          if (isNumber(props.value) && isNumber(props.max)) {
            return props.max < props.value ? `${props.max}+` : `${props.value}`;
          }
          return `${props.value}`;
        });
        expose({
          content
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns).b())
          }, [
            renderSlot(_ctx.$slots, "default"),
            createVNode(Transition, {
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("sup", {
                  class: normalizeClass([
                    unref(ns).e("content"),
                    unref(ns).em("content", _ctx.type),
                    unref(ns).is("fixed", !!_ctx.$slots.default),
                    unref(ns).is("dot", _ctx.isDot)
                  ]),
                  textContent: toDisplayString(unref(content))
                }, null, 10, _hoisted_1$s), [
                  [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
                ])
              ]),
              _: 1
            }, 8, ["name"])
          ], 2);
        };
      }
    });
    var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "badge.vue"]]);
    const ElBadge = withInstall(Badge);
    const buttonGroupContextKey = Symbol("buttonGroupContextKey");
    const useButton = (props, emit2) => {
      useDeprecated({
        from: "type.text",
        replacement: "link",
        version: "3.0.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
      }, computed(() => props.type === "text"));
      const buttonGroupContext = inject(buttonGroupContextKey, void 0);
      const globalConfig2 = useGlobalConfig("button");
      const { form } = useFormItem();
      const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
      const _disabled = useFormDisabled();
      const _ref = ref();
      const slots = useSlots();
      const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
      const autoInsertSpace = computed(() => {
        var _a2, _b, _c;
        return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
      });
      const _props = computed(() => {
        if (props.tag === "button") {
          return {
            ariaDisabled: _disabled.value || props.loading,
            disabled: _disabled.value || props.loading,
            autofocus: props.autofocus,
            type: props.nativeType
          };
        }
        return {};
      });
      const shouldAddSpace = computed(() => {
        var _a2;
        const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
          const slot = defaultSlot[0];
          if ((slot == null ? void 0 : slot.type) === Text$1) {
            const text = slot.children;
            return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
          }
        }
        return false;
      });
      const handleClick = (evt) => {
        if (props.nativeType === "reset") {
          form == null ? void 0 : form.resetFields();
        }
        emit2("click", evt);
      };
      return {
        _disabled,
        _size,
        _type,
        _ref,
        _props,
        shouldAddSpace,
        handleClick
      };
    };
    const buttonTypes = [
      "default",
      "primary",
      "success",
      "warning",
      "info",
      "danger",
      "text",
      ""
    ];
    const buttonNativeTypes = ["button", "submit", "reset"];
    const buttonProps = buildProps({
      size: useSizeProp,
      disabled: Boolean,
      type: {
        type: String,
        values: buttonTypes,
        default: ""
      },
      icon: {
        type: iconPropType
      },
      nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
      },
      loading: Boolean,
      loadingIcon: {
        type: iconPropType,
        default: () => loading_default
      },
      plain: Boolean,
      text: Boolean,
      link: Boolean,
      bg: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean,
      color: String,
      dark: Boolean,
      autoInsertSpace: {
        type: Boolean,
        default: void 0
      },
      tag: {
        type: definePropType([String, Object]),
        default: "button"
      }
    });
    const buttonEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    function bound01(n, max) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var isPercent = isPercentage(n);
      n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max), 10) / 100;
      }
      if (Math.abs(n - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
      } else {
        n = n % max / parseFloat(String(max));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb(r, g, b2) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r, g, b2) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b2 = bound01(b2, 255);
      var max = Math.max(r, g, b2);
      var min = Math.min(r, g, b2);
      var h2 = 0;
      var s2 = 0;
      var l2 = (max + min) / 2;
      if (max === min) {
        s2 = 0;
        h2 = 0;
      } else {
        var d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        switch (max) {
          case r:
            h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
            break;
          case g:
            h2 = (b2 - r) / d2 + 2;
            break;
          case b2:
            h2 = (r - g) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hue2rgb(p2, q2, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t);
      }
      if (t < 1 / 2) {
        return q2;
      }
      if (t < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s2, l2) {
      var r;
      var g;
      var b2;
      h2 = bound01(h2, 360);
      s2 = bound01(s2, 100);
      l2 = bound01(l2, 100);
      if (s2 === 0) {
        g = l2;
        b2 = l2;
        r = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r = hue2rgb(p2, q2, h2 + 1 / 3);
        g = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b2 * 255 };
    }
    function rgbToHsv(r, g, b2) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b2 = bound01(b2, 255);
      var max = Math.max(r, g, b2);
      var min = Math.min(r, g, b2);
      var h2 = 0;
      var v2 = max;
      var d2 = max - min;
      var s2 = max === 0 ? 0 : d2 / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r:
            h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
            break;
          case g:
            h2 = (b2 - r) / d2 + 2;
            break;
          case b2:
            h2 = (r - g) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      var i = Math.floor(h2);
      var f2 = h2 - i;
      var p2 = v2 * (1 - s2);
      var q2 = v2 * (1 - f2 * s2);
      var t = v2 * (1 - (1 - f2) * s2);
      var mod = i % 6;
      var r = [v2, q2, p2, p2, t, v2][mod];
      var g = [t, v2, v2, q2, p2, p2][mod];
      var b2 = [p2, p2, t, v2, v2, q2][mod];
      return { r: r * 255, g: g * 255, b: b2 * 255 };
    }
    function rgbToHex(r, g, b2, allow3Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b2).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b2, a2, allow4Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b2).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format2 = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s2 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s2, v2);
          ok = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s2 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s2, l2);
          ok = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a2
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a2;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s2 = this.toHsl().s;
          return s2 === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s2 = Math.round(hsv.s * 100);
          var v2 = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s2 = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r = Math.round(this.r);
          var g = Math.round(this.g);
          var b2 = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b2, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
            var _b = _a2[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s2 = hsv.s;
          var v2 = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
            v2 = (v2 + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          var alpha = fg.a + bg.a * (1 - fg.a);
          return new TinyColor2({
            r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
            g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
            b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment = 360 / n;
          for (var i = 1; i < n; i++) {
            result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );
    function darken(color, amount = 20) {
      return color.mix("#141414", amount).toString();
    }
    function useButtonCustomStyle(props) {
      const _disabled = useFormDisabled();
      const ns = useNamespace("button");
      return computed(() => {
        let styles = {};
        const buttonColor = props.color;
        if (buttonColor) {
          const color = new TinyColor(buttonColor);
          const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
          if (props.plain) {
            styles = ns.cssVarBlock({
              "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
              "text-color": buttonColor,
              "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
              "hover-text-color": `var(${ns.cssVarName("color-white")})`,
              "hover-bg-color": buttonColor,
              "hover-border-color": buttonColor,
              "active-bg-color": activeBgColor,
              "active-text-color": `var(${ns.cssVarName("color-white")})`,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
            }
          } else {
            const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
            const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
            styles = ns.cssVarBlock({
              "bg-color": buttonColor,
              "text-color": textColor,
              "border-color": buttonColor,
              "hover-bg-color": hoverBgColor,
              "hover-text-color": textColor,
              "hover-border-color": hoverBgColor,
              "active-bg-color": activeBgColor,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
              styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
            }
          }
        }
        return styles;
      });
    }
    const __default__$r = /* @__PURE__ */ defineComponent({
      name: "ElButton"
    });
    const _sfc_main$N = /* @__PURE__ */ defineComponent({
      ...__default__$r,
      props: buttonProps,
      emits: buttonEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const buttonStyle = useButtonCustomStyle(props);
        const ns = useNamespace("button");
        const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
        expose({
          ref: _ref,
          size: _size,
          type: _type,
          disabled: _disabled,
          shouldAddSpace
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
            ref_key: "_ref",
            ref: _ref
          }, unref(_props), {
            class: [
              unref(ns).b(),
              unref(ns).m(unref(_type)),
              unref(ns).m(unref(_size)),
              unref(ns).is("disabled", unref(_disabled)),
              unref(ns).is("loading", _ctx.loading),
              unref(ns).is("plain", _ctx.plain),
              unref(ns).is("round", _ctx.round),
              unref(ns).is("circle", _ctx.circle),
              unref(ns).is("text", _ctx.text),
              unref(ns).is("link", _ctx.link),
              unref(ns).is("has-bg", _ctx.bg)
            ],
            style: unref(buttonStyle),
            onClick: unref(handleClick)
          }), {
            default: withCtx(() => [
              _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                ]),
                _: 3
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 16, ["class", "style", "onClick"]);
        };
      }
    });
    var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "button.vue"]]);
    const buttonGroupProps = {
      size: buttonProps.size,
      type: buttonProps.type
    };
    const __default__$q = /* @__PURE__ */ defineComponent({
      name: "ElButtonGroup"
    });
    const _sfc_main$M = /* @__PURE__ */ defineComponent({
      ...__default__$q,
      props: buttonGroupProps,
      setup(__props) {
        const props = __props;
        provide(buttonGroupContextKey, reactive({
          size: toRef(props, "size"),
          type: toRef(props, "type")
        }));
        const ns = useNamespace("button");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(`${unref(ns).b("group")}`)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "button-group.vue"]]);
    const ElButton = withInstall(Button, {
      ButtonGroup
    });
    withNoopInstall(ButtonGroup);
    const nodeList = /* @__PURE__ */ new Map();
    let startClick;
    if (isClient) {
      document.addEventListener("mousedown", (e) => startClick = e);
      document.addEventListener("mouseup", (e) => {
        for (const handlers2 of nodeList.values()) {
          for (const { documentHandler } of handlers2) {
            documentHandler(e, startClick);
          }
        }
      });
    }
    function createDocumentHandler(el, binding) {
      let excludes = [];
      if (Array.isArray(binding.arg)) {
        excludes = binding.arg;
      } else if (isElement(binding.arg)) {
        excludes.push(binding.arg);
      }
      return function(mouseup, mousedown) {
        const popperRef = binding.instance.popperRef;
        const mouseUpTarget = mouseup.target;
        const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
        const isBound = !binding || !binding.instance;
        const isTargetExists = !mouseUpTarget || !mouseDownTarget;
        const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
        const isSelf = el === mouseUpTarget;
        const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
        const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
        if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
          return;
        }
        binding.value(mouseup, mousedown);
      };
    }
    const ClickOutside = {
      beforeMount(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        nodeList.get(el).push({
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        });
      },
      updated(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        const handlers2 = nodeList.get(el);
        const oldHandlerIndex = handlers2.findIndex((item) => item.bindingFn === binding.oldValue);
        const newHandler = {
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        };
        if (oldHandlerIndex >= 0) {
          handlers2.splice(oldHandlerIndex, 1, newHandler);
        } else {
          handlers2.push(newHandler);
        }
      },
      unmounted(el) {
        nodeList.delete(el);
      }
    };
    const FOCUSABLE_CHILDREN = "_trap-focus-children";
    const FOCUS_STACK = [];
    const FOCUS_HANDLER = (e) => {
      if (FOCUS_STACK.length === 0)
        return;
      const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
      if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
        if (focusableElement.length === 1) {
          e.preventDefault();
          if (document.activeElement !== focusableElement[0]) {
            focusableElement[0].focus();
          }
          return;
        }
        const goingBackward = e.shiftKey;
        const isFirst = e.target === focusableElement[0];
        const isLast = e.target === focusableElement[focusableElement.length - 1];
        if (isFirst && goingBackward) {
          e.preventDefault();
          focusableElement[focusableElement.length - 1].focus();
        }
        if (isLast && !goingBackward) {
          e.preventDefault();
          focusableElement[0].focus();
        }
      }
    };
    const TrapFocus = {
      beforeMount(el) {
        el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
        FOCUS_STACK.push(el);
        if (FOCUS_STACK.length <= 1) {
          document.addEventListener("keydown", FOCUS_HANDLER);
        }
      },
      updated(el) {
        nextTick(() => {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
        });
      },
      unmounted() {
        FOCUS_STACK.shift();
        if (FOCUS_STACK.length === 0) {
          document.removeEventListener("keydown", FOCUS_HANDLER);
        }
      }
    };
    var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
    function a() {
      if (!v) {
        v = true;
        var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
        if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
          o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
          var r = /(?:Trident\/(\d+.\d+))/.exec(e);
          N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
        } else
          o = f = s = d = u = NaN;
        if (i) {
          if (i[1]) {
            var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
            l = t ? parseFloat(t[1].replace("_", ".")) : true;
          } else
            l = false;
          p = !!i[2], m = !!i[3];
        } else
          l = p = m = false;
      }
    }
    var _ = { ie: function() {
      return a() || o;
    }, ieCompatibilityMode: function() {
      return a() || N > o;
    }, ie64: function() {
      return _.ie() && D;
    }, firefox: function() {
      return a() || f;
    }, opera: function() {
      return a() || s;
    }, webkit: function() {
      return a() || u;
    }, safari: function() {
      return _.webkit();
    }, chrome: function() {
      return a() || d;
    }, windows: function() {
      return a() || p;
    }, osx: function() {
      return a() || l;
    }, linux: function() {
      return a() || m;
    }, iphone: function() {
      return a() || x;
    }, mobile: function() {
      return a() || x || E || w || F;
    }, nativeApp: function() {
      return a() || M;
    }, android: function() {
      return a() || w;
    }, ipad: function() {
      return a() || E;
    } }, A = _;
    var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, h = U;
    var X;
    h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
    function S(e, n) {
      if (!h.canUseDOM || n && !("addEventListener" in document))
        return false;
      var i = "on" + e, r = i in document;
      if (!r) {
        var t = document.createElement("div");
        t.setAttribute(i, "return;"), r = typeof t[i] == "function";
      }
      return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
    }
    var b = S;
    var O = 10, I = 40, P = 800;
    function T(e) {
      var n = 0, i = 0, r = 0, t = 0;
      return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
    }
    T.getEventType = function() {
      return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
    };
    var Y = T;
    /**
    * Checks if an event is supported in the current execution environment.
    *
    * NOTE: This will not work correctly for non-generic events such as `change`,
    * `reset`, `load`, `error`, and `select`.
    *
    * Borrows from Modernizr.
    *
    * @param {string} eventNameSuffix Event name, e.g. "click".
    * @param {?boolean} capture Check if the capture phase is supported.
    * @return {boolean} True if the event is supported.
    * @internal
    * @license Modernizr 3.0.0pre (Custom Build) | MIT
    */
    const mousewheel = function(element, callback) {
      if (element && element.addEventListener) {
        const fn2 = function(event) {
          const normalized = Y(event);
          callback && Reflect.apply(callback, this, [event, normalized]);
        };
        element.addEventListener("wheel", fn2, { passive: true });
      }
    };
    const Mousewheel = {
      beforeMount(el, binding) {
        mousewheel(el, binding.value);
      }
    };
    const checkboxProps = {
      modelValue: {
        type: [Number, String, Boolean],
        default: void 0
      },
      label: {
        type: [String, Boolean, Number, Object],
        default: void 0
      },
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: {
        type: String,
        default: void 0
      },
      trueLabel: {
        type: [String, Number],
        default: void 0
      },
      falseLabel: {
        type: [String, Number],
        default: void 0
      },
      id: {
        type: String,
        default: void 0
      },
      controls: {
        type: String,
        default: void 0
      },
      border: Boolean,
      size: useSizeProp,
      tabindex: [String, Number],
      validateEvent: {
        type: Boolean,
        default: true
      }
    };
    const checkboxEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
      change: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
    };
    const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
    const useCheckboxDisabled = ({
      model,
      isChecked
    }) => {
      const checkboxGroup = inject(checkboxGroupContextKey, void 0);
      const isLimitDisabled = computed(() => {
        var _a2, _b;
        const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
        const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
        return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
      });
      const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
      return {
        isDisabled,
        isLimitDisabled
      };
    };
    const useCheckboxEvent = (props, {
      model,
      isLimitExceeded,
      hasOwnLabel,
      isDisabled,
      isLabeledByFormItem
    }) => {
      const checkboxGroup = inject(checkboxGroupContextKey, void 0);
      const { formItem } = useFormItem();
      const { emit: emit2 } = getCurrentInstance();
      function getLabeledValue(value) {
        var _a2, _b;
        return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
      }
      function emitChangeEvent(checked, e) {
        emit2("change", getLabeledValue(checked), e);
      }
      function handleChange(e) {
        if (isLimitExceeded.value)
          return;
        const target = e.target;
        emit2("change", getLabeledValue(target.checked), e);
      }
      async function onClickRoot(e) {
        if (isLimitExceeded.value)
          return;
        if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
          const eventTargets = e.composedPath();
          const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
          if (!hasLabel) {
            model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
            await nextTick();
            emitChangeEvent(model.value, e);
          }
        }
      }
      const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
      watch(() => props.modelValue, () => {
        if (validateEvent.value) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
        }
      });
      return {
        handleChange,
        onClickRoot
      };
    };
    const useCheckboxModel = (props) => {
      const selfModel = ref(false);
      const { emit: emit2 } = getCurrentInstance();
      const checkboxGroup = inject(checkboxGroupContextKey, void 0);
      const isGroup = computed(() => isUndefined(checkboxGroup) === false);
      const isLimitExceeded = ref(false);
      const model = computed({
        get() {
          var _a2, _b;
          return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
        },
        set(val) {
          var _a2, _b;
          if (isGroup.value && isArray$1(val)) {
            isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
            isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
          } else {
            emit2(UPDATE_MODEL_EVENT, val);
            selfModel.value = val;
          }
        }
      });
      return {
        model,
        isGroup,
        isLimitExceeded
      };
    };
    const useCheckboxStatus = (props, slots, { model }) => {
      const checkboxGroup = inject(checkboxGroupContextKey, void 0);
      const isFocused = ref(false);
      const isChecked = computed(() => {
        const value = model.value;
        if (isBoolean(value)) {
          return value;
        } else if (isArray$1(value)) {
          if (isObject$1(props.label)) {
            return value.map(toRaw).some((o2) => isEqual(o2, props.label));
          } else {
            return value.map(toRaw).includes(props.label);
          }
        } else if (value !== null && value !== void 0) {
          return value === props.trueLabel;
        } else {
          return !!value;
        }
      });
      const checkboxButtonSize = useFormSize(computed(() => {
        var _a2;
        return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
      }), {
        prop: true
      });
      const checkboxSize = useFormSize(computed(() => {
        var _a2;
        return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
      }));
      const hasOwnLabel = computed(() => {
        return !!slots.default || !isNil(props.label);
      });
      return {
        checkboxButtonSize,
        isChecked,
        isFocused,
        checkboxSize,
        hasOwnLabel
      };
    };
    const setStoreValue = (props, { model }) => {
      function addToStore() {
        if (isArray$1(model.value) && !model.value.includes(props.label)) {
          model.value.push(props.label);
        } else {
          model.value = props.trueLabel || true;
        }
      }
      props.checked && addToStore();
    };
    const useCheckbox = (props, slots) => {
      const { formItem: elFormItem } = useFormItem();
      const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
      const {
        isFocused,
        isChecked,
        checkboxButtonSize,
        checkboxSize,
        hasOwnLabel
      } = useCheckboxStatus(props, slots, { model });
      const { isDisabled } = useCheckboxDisabled({ model, isChecked });
      const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
        formItemContext: elFormItem,
        disableIdGeneration: hasOwnLabel,
        disableIdManagement: isGroup
      });
      const { handleChange, onClickRoot } = useCheckboxEvent(props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      });
      setStoreValue(props, { model });
      return {
        inputId,
        isLabeledByFormItem,
        isChecked,
        isDisabled,
        isFocused,
        checkboxButtonSize,
        checkboxSize,
        hasOwnLabel,
        model,
        handleChange,
        onClickRoot
      };
    };
    const _hoisted_1$r = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"];
    const _hoisted_2$g = ["id", "indeterminate", "disabled", "value", "name", "tabindex"];
    const __default__$p = /* @__PURE__ */ defineComponent({
      name: "ElCheckbox"
    });
    const _sfc_main$L = /* @__PURE__ */ defineComponent({
      ...__default__$p,
      props: checkboxProps,
      emits: checkboxEmits,
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          model,
          handleChange,
          onClickRoot
        } = useCheckbox(props, slots);
        const ns = useNamespace("checkbox");
        const compKls = computed(() => {
          return [
            ns.b(),
            ns.m(checkboxSize.value),
            ns.is("disabled", isDisabled.value),
            ns.is("bordered", props.border),
            ns.is("checked", isChecked.value)
          ];
        });
        const spanKls = computed(() => {
          return [
            ns.e("input"),
            ns.is("disabled", isDisabled.value),
            ns.is("checked", isChecked.value),
            ns.is("indeterminate", props.indeterminate),
            ns.is("focus", isFocused.value)
          ];
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
            class: normalizeClass(unref(compKls)),
            "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
            onClick: unref(onClickRoot)
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass(unref(spanKls))
              }, [
                _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 0,
                  id: unref(inputId),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                  class: normalizeClass(unref(ns).e("original")),
                  type: "checkbox",
                  indeterminate: _ctx.indeterminate,
                  name: _ctx.name,
                  tabindex: _ctx.tabindex,
                  disabled: unref(isDisabled),
                  "true-value": _ctx.trueLabel,
                  "false-value": _ctx.falseLabel,
                  onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                  onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                  onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                  onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 42, _hoisted_1$r)), [
                  [vModelCheckbox, unref(model)]
                ]) : withDirectives((openBlock(), createElementBlock("input", {
                  key: 1,
                  id: unref(inputId),
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                  class: normalizeClass(unref(ns).e("original")),
                  type: "checkbox",
                  indeterminate: _ctx.indeterminate,
                  disabled: unref(isDisabled),
                  value: _ctx.label,
                  name: _ctx.name,
                  tabindex: _ctx.tabindex,
                  onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                  onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                  onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                  onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 42, _hoisted_2$g)), [
                  [vModelCheckbox, unref(model)]
                ]),
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("inner"))
                }, null, 2)
              ], 2),
              unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(ns).e("label"))
              }, [
                renderSlot(_ctx.$slots, "default"),
                !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ], 64)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["class", "aria-controls", "onClick"]);
        };
      }
    });
    var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "checkbox.vue"]]);
    const _hoisted_1$q = ["name", "tabindex", "disabled", "true-value", "false-value"];
    const _hoisted_2$f = ["name", "tabindex", "disabled", "value"];
    const __default__$o = /* @__PURE__ */ defineComponent({
      name: "ElCheckboxButton"
    });
    const _sfc_main$K = /* @__PURE__ */ defineComponent({
      ...__default__$o,
      props: checkboxProps,
      emits: checkboxEmits,
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const {
          isFocused,
          isChecked,
          isDisabled,
          checkboxButtonSize,
          model,
          handleChange
        } = useCheckbox(props, slots);
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const ns = useNamespace("checkbox");
        const activeStyle = computed(() => {
          var _a2, _b, _c, _d;
          const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
          return {
            backgroundColor: fillValue,
            borderColor: fillValue,
            color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
            boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
          };
        });
        const labelKls = computed(() => {
          return [
            ns.b("button"),
            ns.bm("button", checkboxButtonSize.value),
            ns.is("disabled", isDisabled.value),
            ns.is("checked", isChecked.value),
            ns.is("focus", isFocused.value)
          ];
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("label", {
            class: normalizeClass(unref(labelKls))
          }, [
            _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
              key: 0,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref(ns).be("button", "original")),
              type: "checkbox",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: unref(isDisabled),
              "true-value": _ctx.trueLabel,
              "false-value": _ctx.falseLabel,
              onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
              onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
              onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
              onClick: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_1$q)), [
              [vModelCheckbox, unref(model)]
            ]) : withDirectives((openBlock(), createElementBlock("input", {
              key: 1,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref(ns).be("button", "original")),
              type: "checkbox",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: unref(isDisabled),
              value: _ctx.label,
              onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
              onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
              onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
              onClick: _cache[9] || (_cache[9] = withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_2$f)), [
              [vModelCheckbox, unref(model)]
            ]),
            _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(unref(ns).be("button", "inner")),
              style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(_ctx.label), 1)
              ])
            ], 6)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "checkbox-button.vue"]]);
    const checkboxGroupProps = buildProps({
      modelValue: {
        type: definePropType(Array),
        default: () => []
      },
      disabled: Boolean,
      min: Number,
      max: Number,
      size: useSizeProp,
      label: String,
      fill: String,
      textColor: String,
      tag: {
        type: String,
        default: "div"
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    });
    const checkboxGroupEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
      change: (val) => isArray$1(val)
    };
    const __default__$n = /* @__PURE__ */ defineComponent({
      name: "ElCheckboxGroup"
    });
    const _sfc_main$J = /* @__PURE__ */ defineComponent({
      ...__default__$n,
      props: checkboxGroupProps,
      emits: checkboxGroupEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("checkbox");
        const { formItem } = useFormItem();
        const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const changeEvent = async (value) => {
          emit2(UPDATE_MODEL_EVENT, value);
          await nextTick();
          emit2("change", value);
        };
        const modelValue = computed({
          get() {
            return props.modelValue;
          },
          set(val) {
            changeEvent(val);
          }
        });
        provide(checkboxGroupContextKey, {
          ...pick(toRefs(props), [
            "size",
            "min",
            "max",
            "disabled",
            "validateEvent",
            "fill",
            "textColor"
          ]),
          modelValue,
          changeEvent
        });
        watch(() => props.modelValue, () => {
          if (props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            id: unref(groupId),
            class: normalizeClass(unref(ns).b("group")),
            role: "group",
            "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
            "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
        };
      }
    });
    var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "checkbox-group.vue"]]);
    const ElCheckbox = withInstall(Checkbox, {
      CheckboxButton,
      CheckboxGroup
    });
    withNoopInstall(CheckboxButton);
    withNoopInstall(CheckboxGroup);
    const tagProps = buildProps({
      type: {
        type: String,
        values: ["success", "info", "warning", "danger", ""],
        default: ""
      },
      closable: Boolean,
      disableTransitions: Boolean,
      hit: Boolean,
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        values: componentSizes,
        default: ""
      },
      effect: {
        type: String,
        values: ["dark", "light", "plain"],
        default: "light"
      },
      round: Boolean
    });
    const tagEmits = {
      close: (evt) => evt instanceof MouseEvent,
      click: (evt) => evt instanceof MouseEvent
    };
    const __default__$m = /* @__PURE__ */ defineComponent({
      name: "ElTag"
    });
    const _sfc_main$I = /* @__PURE__ */ defineComponent({
      ...__default__$m,
      props: tagProps,
      emits: tagEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const tagSize = useFormSize();
        const ns = useNamespace("tag");
        const containerKls = computed(() => {
          const { type, hit, effect, closable, round } = props;
          return [
            ns.b(),
            ns.is("closable", closable),
            ns.m(type),
            ns.m(tagSize.value),
            ns.m(effect),
            ns.is("hit", hit),
            ns.is("round", round)
          ];
        });
        const handleClose = (event) => {
          emit2("close", event);
        };
        const handleClick = (event) => {
          emit2("click", event);
        };
        return (_ctx, _cache) => {
          return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(containerKls)),
            style: normalizeStyle({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ns).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns).e("close")),
              onClick: withModifiers(handleClose, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 6)) : (openBlock(), createBlock(Transition, {
            key: 1,
            name: `${unref(ns).namespace.value}-zoom-in-center`,
            appear: ""
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass(unref(containerKls)),
                style: normalizeStyle({ backgroundColor: _ctx.color }),
                onClick: handleClick
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).e("close")),
                  onClick: withModifiers(handleClose, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 6)
            ]),
            _: 3
          }, 8, ["name"]));
        };
      }
    });
    var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "tag.vue"]]);
    const ElTag = withInstall(Tag);
    const __default__$l = /* @__PURE__ */ defineComponent({
      name: "ElContainer"
    });
    const _sfc_main$H = /* @__PURE__ */ defineComponent({
      ...__default__$l,
      props: {
        direction: {
          type: String
        }
      },
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const ns = useNamespace("container");
        const isVertical = computed(() => {
          if (props.direction === "vertical") {
            return true;
          } else if (props.direction === "horizontal") {
            return false;
          }
          if (slots && slots.default) {
            const vNodes = slots.default();
            return vNodes.some((vNode) => {
              const tag = vNode.type.name;
              return tag === "ElHeader" || tag === "ElFooter";
            });
          } else {
            return false;
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("section", {
            class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "container.vue"]]);
    const __default__$k = /* @__PURE__ */ defineComponent({
      name: "ElAside"
    });
    const _sfc_main$G = /* @__PURE__ */ defineComponent({
      ...__default__$k,
      props: {
        width: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("aside");
        const style = computed(() => props.width ? ns.cssVarBlock({ width: props.width }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("aside", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Aside = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "aside.vue"]]);
    const __default__$j = /* @__PURE__ */ defineComponent({
      name: "ElFooter"
    });
    const _sfc_main$F = /* @__PURE__ */ defineComponent({
      ...__default__$j,
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("footer");
        const style = computed(() => props.height ? ns.cssVarBlock({ height: props.height }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("footer", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "footer.vue"]]);
    const __default__$i = /* @__PURE__ */ defineComponent({
      name: "ElHeader"
    });
    const _sfc_main$E = /* @__PURE__ */ defineComponent({
      ...__default__$i,
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("header");
        const style = computed(() => {
          return props.height ? ns.cssVarBlock({
            height: props.height
          }) : {};
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("header", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Header = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "header.vue"]]);
    const __default__$h = /* @__PURE__ */ defineComponent({
      name: "ElMain"
    });
    const _sfc_main$D = /* @__PURE__ */ defineComponent({
      ...__default__$h,
      setup(__props) {
        const ns = useNamespace("main");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("main", {
            class: normalizeClass(unref(ns).b())
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Main = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "main.vue"]]);
    withInstall(Container, {
      Aside,
      Footer,
      Header,
      Main
    });
    withNoopInstall(Aside);
    withNoopInstall(Footer);
    withNoopInstall(Header);
    const ElMain = withNoopInstall(Main);
    const overlayProps = buildProps({
      mask: {
        type: Boolean,
        default: true
      },
      customMaskEvent: {
        type: Boolean,
        default: false
      },
      overlayClass: {
        type: definePropType([
          String,
          Array,
          Object
        ])
      },
      zIndex: {
        type: definePropType([String, Number])
      }
    });
    const overlayEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const BLOCK = "overlay";
    var Overlay = /* @__PURE__ */ defineComponent({
      name: "ElOverlay",
      props: overlayProps,
      emits: overlayEmits,
      setup(props, { slots, emit: emit2 }) {
        const ns = useNamespace(BLOCK);
        const onMaskClick = (e) => {
          emit2("click", e);
        };
        const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
        return () => {
          return props.mask ? createVNode("div", {
            class: [ns.b(), props.overlayClass],
            style: {
              zIndex: props.zIndex
            },
            onClick,
            onMousedown,
            onMouseup
          }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
            class: props.overlayClass,
            style: {
              zIndex: props.zIndex,
              position: "fixed",
              top: "0px",
              right: "0px",
              bottom: "0px",
              left: "0px"
            }
          }, [renderSlot(slots, "default")]);
        };
      }
    });
    const ElOverlay = Overlay;
    const dialogInjectionKey = Symbol("dialogInjectionKey");
    const dialogContentProps = buildProps({
      center: Boolean,
      alignCenter: Boolean,
      closeIcon: {
        type: iconPropType
      },
      customClass: {
        type: String,
        default: ""
      },
      draggable: Boolean,
      fullscreen: Boolean,
      showClose: {
        type: Boolean,
        default: true
      },
      title: {
        type: String,
        default: ""
      },
      ariaLevel: {
        type: String,
        default: "2"
      }
    });
    const dialogContentEmits = {
      close: () => true
    };
    const _hoisted_1$p = ["aria-level"];
    const _hoisted_2$e = ["aria-label"];
    const _hoisted_3$8 = ["id"];
    const __default__$g = /* @__PURE__ */ defineComponent({ name: "ElDialogContent" });
    const _sfc_main$C = /* @__PURE__ */ defineComponent({
      ...__default__$g,
      props: dialogContentProps,
      emits: dialogContentEmits,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const { Close } = CloseComponents;
        const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
        const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
        const dialogKls = computed(() => [
          ns.b(),
          ns.is("fullscreen", props.fullscreen),
          ns.is("draggable", props.draggable),
          ns.is("align-center", props.alignCenter),
          { [ns.m("center")]: props.center },
          props.customClass
        ]);
        const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
        const draggable = computed(() => props.draggable);
        useDraggable(dialogRef, headerRef, draggable);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref: unref(composedDialogRef),
            class: normalizeClass(unref(dialogKls)),
            style: normalizeStyle(unref(style)),
            tabindex: "-1"
          }, [
            createBaseVNode("header", {
              ref_key: "headerRef",
              ref: headerRef,
              class: normalizeClass(unref(ns).e("header"))
            }, [
              renderSlot(_ctx.$slots, "header", {}, () => [
                createBaseVNode("span", {
                  role: "heading",
                  "aria-level": _ctx.ariaLevel,
                  class: normalizeClass(unref(ns).e("title"))
                }, toDisplayString(_ctx.title), 11, _hoisted_1$p)
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("button", {
                key: 0,
                "aria-label": unref(t)("el.dialog.close"),
                class: normalizeClass(unref(ns).e("headerbtn")),
                type: "button",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, [
                createVNode(unref(ElIcon), {
                  class: normalizeClass(unref(ns).e("close"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, _hoisted_2$e)) : createCommentVNode("v-if", true)
            ], 2),
            createBaseVNode("div", {
              id: unref(bodyId),
              class: normalizeClass(unref(ns).e("body"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_3$8),
            _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
              key: 0,
              class: normalizeClass(unref(ns).e("footer"))
            }, [
              renderSlot(_ctx.$slots, "footer")
            ], 2)) : createCommentVNode("v-if", true)
          ], 6);
        };
      }
    });
    var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["__file", "dialog-content.vue"]]);
    const dialogProps = buildProps({
      ...dialogContentProps,
      appendToBody: Boolean,
      appendTo: {
        type: definePropType(String),
        default: "body"
      },
      beforeClose: {
        type: definePropType(Function)
      },
      destroyOnClose: Boolean,
      closeOnClickModal: {
        type: Boolean,
        default: true
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      lockScroll: {
        type: Boolean,
        default: true
      },
      modal: {
        type: Boolean,
        default: true
      },
      openDelay: {
        type: Number,
        default: 0
      },
      closeDelay: {
        type: Number,
        default: 0
      },
      top: {
        type: String
      },
      modelValue: Boolean,
      modalClass: String,
      width: {
        type: [String, Number]
      },
      zIndex: {
        type: Number
      },
      trapFocus: {
        type: Boolean,
        default: false
      },
      headerAriaLevel: {
        type: String,
        default: "2"
      }
    });
    const dialogEmits = {
      open: () => true,
      opened: () => true,
      close: () => true,
      closed: () => true,
      [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
      openAutoFocus: () => true,
      closeAutoFocus: () => true
    };
    const useDialog = (props, targetRef) => {
      var _a2;
      const instance = getCurrentInstance();
      const emit2 = instance.emit;
      const { nextZIndex } = useZIndex();
      let lastPosition = "";
      const titleId = useId();
      const bodyId = useId();
      const visible = ref(false);
      const closed = ref(false);
      const rendered = ref(false);
      const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
      let openTimer = void 0;
      let closeTimer = void 0;
      const namespace = useGlobalConfig("namespace", defaultNamespace);
      const style = computed(() => {
        const style2 = {};
        const varPrefix = `--${namespace.value}-dialog`;
        if (!props.fullscreen) {
          if (props.top) {
            style2[`${varPrefix}-margin-top`] = props.top;
          }
          if (props.width) {
            style2[`${varPrefix}-width`] = addUnit(props.width);
          }
        }
        return style2;
      });
      const overlayDialogStyle = computed(() => {
        if (props.alignCenter) {
          return { display: "flex" };
        }
        return {};
      });
      function afterEnter() {
        emit2("opened");
      }
      function afterLeave() {
        emit2("closed");
        emit2(UPDATE_MODEL_EVENT, false);
        if (props.destroyOnClose) {
          rendered.value = false;
        }
      }
      function beforeLeave() {
        emit2("close");
      }
      function open() {
        closeTimer == null ? void 0 : closeTimer();
        openTimer == null ? void 0 : openTimer();
        if (props.openDelay && props.openDelay > 0) {
          ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
        } else {
          doOpen();
        }
      }
      function close() {
        openTimer == null ? void 0 : openTimer();
        closeTimer == null ? void 0 : closeTimer();
        if (props.closeDelay && props.closeDelay > 0) {
          ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
        } else {
          doClose();
        }
      }
      function handleClose() {
        function hide(shouldCancel) {
          if (shouldCancel)
            return;
          closed.value = true;
          visible.value = false;
        }
        if (props.beforeClose) {
          props.beforeClose(hide);
        } else {
          close();
        }
      }
      function onModalClick() {
        if (props.closeOnClickModal) {
          handleClose();
        }
      }
      function doOpen() {
        if (!isClient)
          return;
        visible.value = true;
      }
      function doClose() {
        visible.value = false;
      }
      function onOpenAutoFocus() {
        emit2("openAutoFocus");
      }
      function onCloseAutoFocus() {
        emit2("closeAutoFocus");
      }
      function onFocusoutPrevented(event) {
        var _a22;
        if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
          event.preventDefault();
        }
      }
      if (props.lockScroll) {
        useLockscreen(visible);
      }
      function onCloseRequested() {
        if (props.closeOnPressEscape) {
          handleClose();
        }
      }
      watch(() => props.modelValue, (val) => {
        if (val) {
          closed.value = false;
          open();
          rendered.value = true;
          zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
          nextTick(() => {
            emit2("open");
            if (targetRef.value) {
              targetRef.value.scrollTop = 0;
            }
          });
        } else {
          if (visible.value) {
            close();
          }
        }
      });
      watch(() => props.fullscreen, (val) => {
        if (!targetRef.value)
          return;
        if (val) {
          lastPosition = targetRef.value.style.transform;
          targetRef.value.style.transform = "";
        } else {
          targetRef.value.style.transform = lastPosition;
        }
      });
      onMounted(() => {
        if (props.modelValue) {
          visible.value = true;
          rendered.value = true;
          open();
        }
      });
      return {
        afterEnter,
        afterLeave,
        beforeLeave,
        handleClose,
        onModalClick,
        close,
        doClose,
        onOpenAutoFocus,
        onCloseAutoFocus,
        onCloseRequested,
        onFocusoutPrevented,
        titleId,
        bodyId,
        closed,
        style,
        overlayDialogStyle,
        rendered,
        visible,
        zIndex: zIndex2
      };
    };
    const _hoisted_1$o = ["aria-label", "aria-labelledby", "aria-describedby"];
    const __default__$f = /* @__PURE__ */ defineComponent({
      name: "ElDialog",
      inheritAttrs: false
    });
    const _sfc_main$B = /* @__PURE__ */ defineComponent({
      ...__default__$f,
      props: dialogProps,
      emits: dialogEmits,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        useDeprecated({
          scope: "el-dialog",
          from: "the title slot",
          replacement: "the header slot",
          version: "3.0.0",
          ref: "https://element-plus.org/en-US/component/dialog.html#slots"
        }, computed(() => !!slots.title));
        useDeprecated({
          scope: "el-dialog",
          from: "custom-class",
          replacement: "class",
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
          type: "Attribute"
        }, computed(() => !!props.customClass));
        const ns = useNamespace("dialog");
        const dialogRef = ref();
        const headerRef = ref();
        const dialogContentRef = ref();
        const {
          visible,
          titleId,
          bodyId,
          style,
          overlayDialogStyle,
          rendered,
          zIndex: zIndex2,
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented
        } = useDialog(props, dialogRef);
        provide(dialogInjectionKey, {
          dialogRef,
          headerRef,
          bodyId,
          ns,
          rendered,
          style
        });
        const overlayEvent = useSameTarget(onModalClick);
        const draggable = computed(() => props.draggable && !props.fullscreen);
        expose({
          visible,
          dialogContentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            to: _ctx.appendTo,
            disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
          }, [
            createVNode(Transition, {
              name: "dialog-fade",
              onAfterEnter: unref(afterEnter),
              onAfterLeave: unref(afterLeave),
              onBeforeLeave: unref(beforeLeave),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createVNode(unref(ElOverlay), {
                  "custom-mask-event": "",
                  mask: _ctx.modal,
                  "overlay-class": _ctx.modalClass,
                  "z-index": unref(zIndex2)
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      role: "dialog",
                      "aria-modal": "true",
                      "aria-label": _ctx.title || void 0,
                      "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                      "aria-describedby": unref(bodyId),
                      class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                      style: normalizeStyle(unref(overlayDialogStyle)),
                      onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                      onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                      onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                    }, [
                      createVNode(unref(ElFocusTrap), {
                        loop: "",
                        trapped: unref(visible),
                        "focus-start-el": "container",
                        onFocusAfterTrapped: unref(onOpenAutoFocus),
                        onFocusAfterReleased: unref(onCloseAutoFocus),
                        onFocusoutPrevented: unref(onFocusoutPrevented),
                        onReleaseRequested: unref(onCloseRequested)
                      }, {
                        default: withCtx(() => [
                          unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                            key: 0,
                            ref_key: "dialogContentRef",
                            ref: dialogContentRef
                          }, _ctx.$attrs, {
                            "custom-class": _ctx.customClass,
                            center: _ctx.center,
                            "align-center": _ctx.alignCenter,
                            "close-icon": _ctx.closeIcon,
                            draggable: unref(draggable),
                            fullscreen: _ctx.fullscreen,
                            "show-close": _ctx.showClose,
                            title: _ctx.title,
                            "aria-level": _ctx.headerAriaLevel,
                            onClose: unref(handleClose)
                          }), createSlots({
                            header: withCtx(() => [
                              !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                key: 0,
                                close: unref(handleClose),
                                titleId: unref(titleId),
                                titleClass: unref(ns).e("title")
                              }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                            ]),
                            default: withCtx(() => [
                              renderSlot(_ctx.$slots, "default")
                            ]),
                            _: 2
                          }, [
                            _ctx.$slots.footer ? {
                              name: "footer",
                              fn: withCtx(() => [
                                renderSlot(_ctx.$slots, "footer")
                              ])
                            } : void 0
                          ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                        ]),
                        _: 3
                      }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                    ], 46, _hoisted_1$o)
                  ]),
                  _: 3
                }, 8, ["mask", "overlay-class", "z-index"]), [
                  [vShow, unref(visible)]
                ])
              ]),
              _: 3
            }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
          ], 8, ["to", "disabled"]);
        };
      }
    });
    var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["__file", "dialog.vue"]]);
    const ElDialog = withInstall(Dialog);
    const _sfc_main$A = /* @__PURE__ */ defineComponent({
      inheritAttrs: false
    });
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default");
    }
    var Collection = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$f], ["__file", "collection.vue"]]);
    const _sfc_main$z = /* @__PURE__ */ defineComponent({
      name: "ElCollectionItem",
      inheritAttrs: false
    });
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default");
    }
    var CollectionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$e], ["__file", "collection-item.vue"]]);
    const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
    const createCollectionWithScope = (name) => {
      const COLLECTION_NAME = `El${name}Collection`;
      const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
      const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
      const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
      const ElCollection2 = {
        ...Collection,
        name: COLLECTION_NAME,
        setup() {
          const collectionRef = ref(null);
          const itemMap = /* @__PURE__ */ new Map();
          const getItems = () => {
            const collectionEl = unref(collectionRef);
            if (!collectionEl)
              return [];
            const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
            const items = [...itemMap.values()];
            return items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
          };
          provide(COLLECTION_INJECTION_KEY2, {
            itemMap,
            getItems,
            collectionRef
          });
        }
      };
      const ElCollectionItem2 = {
        ...CollectionItem,
        name: COLLECTION_ITEM_NAME,
        setup(_2, { attrs }) {
          const collectionItemRef = ref(null);
          const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
          provide(COLLECTION_ITEM_INJECTION_KEY2, {
            collectionItemRef
          });
          onMounted(() => {
            const collectionItemEl = unref(collectionItemRef);
            if (collectionItemEl) {
              collectionInjection.itemMap.set(collectionItemEl, {
                ref: collectionItemEl,
                ...attrs
              });
            }
          });
          onBeforeUnmount(() => {
            const collectionItemEl = unref(collectionItemRef);
            collectionInjection.itemMap.delete(collectionItemEl);
          });
        }
      };
      return {
        COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
        COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
        ElCollection: ElCollection2,
        ElCollectionItem: ElCollectionItem2
      };
    };
    const rovingFocusGroupProps = buildProps({
      style: { type: definePropType([String, Array, Object]) },
      currentTabId: {
        type: definePropType(String)
      },
      defaultCurrentTabId: String,
      loop: Boolean,
      dir: {
        type: String,
        values: ["ltr", "rtl"],
        default: "ltr"
      },
      orientation: {
        type: definePropType(String)
      },
      onBlur: Function,
      onFocus: Function,
      onMousedown: Function
    });
    const {
      ElCollection: ElCollection$1,
      ElCollectionItem: ElCollectionItem$1,
      COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
      COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
    } = createCollectionWithScope("RovingFocusGroup");
    const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
    const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
    const MAP_KEY_TO_FOCUS_INTENT = {
      ArrowLeft: "prev",
      ArrowUp: "prev",
      ArrowRight: "next",
      ArrowDown: "next",
      PageUp: "first",
      Home: "first",
      PageDown: "last",
      End: "last"
    };
    const getDirectionAwareKey = (key, dir) => {
      if (dir !== "rtl")
        return key;
      switch (key) {
        case EVENT_CODE.right:
          return EVENT_CODE.left;
        case EVENT_CODE.left:
          return EVENT_CODE.right;
        default:
          return key;
      }
    };
    const getFocusIntent = (event, orientation, dir) => {
      const key = getDirectionAwareKey(event.key, dir);
      if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
        return void 0;
      if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
        return void 0;
      return MAP_KEY_TO_FOCUS_INTENT[key];
    };
    const reorderArray = (array, atIdx) => {
      return array.map((_2, idx) => array[(idx + atIdx) % array.length]);
    };
    const focusFirst = (elements) => {
      const { activeElement: prevActive } = document;
      for (const element of elements) {
        if (element === prevActive)
          return;
        element.focus();
        if (prevActive !== document.activeElement)
          return;
      }
    };
    const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
    const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
    const EVT_OPTS = { bubbles: false, cancelable: true };
    const _sfc_main$y = /* @__PURE__ */ defineComponent({
      name: "ElRovingFocusGroupImpl",
      inheritAttrs: false,
      props: rovingFocusGroupProps,
      emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
      setup(props, { emit: emit2 }) {
        var _a2;
        const currentTabbedId = ref((_a2 = props.currentTabId || props.defaultCurrentTabId) != null ? _a2 : null);
        const isBackingOut = ref(false);
        const isClickFocus = ref(false);
        const rovingFocusGroupRef = ref(null);
        const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
        const rovingFocusGroupRootStyle = computed(() => {
          return [
            {
              outline: "none"
            },
            props.style
          ];
        });
        const onItemFocus = (tabbedId) => {
          emit2(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
        };
        const onItemShiftTab = () => {
          isBackingOut.value = true;
        };
        const onMousedown = composeEventHandlers((e) => {
          var _a22;
          (_a22 = props.onMousedown) == null ? void 0 : _a22.call(props, e);
        }, () => {
          isClickFocus.value = true;
        });
        const onFocus = composeEventHandlers((e) => {
          var _a22;
          (_a22 = props.onFocus) == null ? void 0 : _a22.call(props, e);
        }, (e) => {
          const isKeyboardFocus = !unref(isClickFocus);
          const { target, currentTarget } = e;
          if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
            const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
            currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
            if (!entryFocusEvt.defaultPrevented) {
              const items = getItems().filter((item) => item.focusable);
              const activeItem = items.find((item) => item.active);
              const currentItem = items.find((item) => item.id === unref(currentTabbedId));
              const candidates = [activeItem, currentItem, ...items].filter(Boolean);
              const candidateNodes = candidates.map((item) => item.ref);
              focusFirst(candidateNodes);
            }
          }
          isClickFocus.value = false;
        });
        const onBlur = composeEventHandlers((e) => {
          var _a22;
          (_a22 = props.onBlur) == null ? void 0 : _a22.call(props, e);
        }, () => {
          isBackingOut.value = false;
        });
        const handleEntryFocus = (...args) => {
          emit2("entryFocus", ...args);
        };
        provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
          currentTabbedId: readonly(currentTabbedId),
          loop: toRef(props, "loop"),
          tabIndex: computed(() => {
            return unref(isBackingOut) ? -1 : 0;
          }),
          rovingFocusGroupRef,
          rovingFocusGroupRootStyle,
          orientation: toRef(props, "orientation"),
          dir: toRef(props, "dir"),
          onItemFocus,
          onItemShiftTab,
          onBlur,
          onFocus,
          onMousedown
        });
        watch(() => props.currentTabId, (val) => {
          currentTabbedId.value = val != null ? val : null;
        });
        useEventListener(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
      }
    });
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default");
    }
    var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$d], ["__file", "roving-focus-group-impl.vue"]]);
    const _sfc_main$x = /* @__PURE__ */ defineComponent({
      name: "ElRovingFocusGroup",
      components: {
        ElFocusGroupCollection: ElCollection$1,
        ElRovingFocusGroupImpl
      }
    });
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
      const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
      return openBlock(), createBlock(_component_el_focus_group_collection, null, {
        default: withCtx(() => [
          createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      });
    }
    var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$c], ["__file", "roving-focus-group.vue"]]);
    const _sfc_main$w = /* @__PURE__ */ defineComponent({
      components: {
        ElRovingFocusCollectionItem: ElCollectionItem$1
      },
      props: {
        focusable: {
          type: Boolean,
          default: true
        },
        active: {
          type: Boolean,
          default: false
        }
      },
      emits: ["mousedown", "focus", "keydown"],
      setup(props, { emit: emit2 }) {
        const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
        const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
        const id = useId();
        const rovingFocusGroupItemRef = ref(null);
        const handleMousedown = composeEventHandlers((e) => {
          emit2("mousedown", e);
        }, (e) => {
          if (!props.focusable) {
            e.preventDefault();
          } else {
            onItemFocus(unref(id));
          }
        });
        const handleFocus = composeEventHandlers((e) => {
          emit2("focus", e);
        }, () => {
          onItemFocus(unref(id));
        });
        const handleKeydown = composeEventHandlers((e) => {
          emit2("keydown", e);
        }, (e) => {
          const { key, shiftKey, target, currentTarget } = e;
          if (key === EVENT_CODE.tab && shiftKey) {
            onItemShiftTab();
            return;
          }
          if (target !== currentTarget)
            return;
          const focusIntent = getFocusIntent(e);
          if (focusIntent) {
            e.preventDefault();
            const items = getItems().filter((item) => item.focusable);
            let elements = items.map((item) => item.ref);
            switch (focusIntent) {
              case "last": {
                elements.reverse();
                break;
              }
              case "prev":
              case "next": {
                if (focusIntent === "prev") {
                  elements.reverse();
                }
                const currentIdx = elements.indexOf(currentTarget);
                elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                break;
              }
            }
            nextTick(() => {
              focusFirst(elements);
            });
          }
        });
        const isCurrentTab = computed(() => currentTabbedId.value === unref(id));
        provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
          rovingFocusGroupItemRef,
          tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
          handleMousedown,
          handleFocus,
          handleKeydown
        });
        return {
          id,
          handleKeydown,
          handleFocus,
          handleMousedown
        };
      }
    });
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
      return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
        id: _ctx.id,
        focusable: _ctx.focusable,
        active: _ctx.active
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "focusable", "active"]);
    }
    var ElRovingFocusItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$b], ["__file", "roving-focus-item.vue"]]);
    const dropdownProps = buildProps({
      trigger: useTooltipTriggerProps.trigger,
      effect: {
        ...useTooltipContentProps.effect,
        default: "light"
      },
      type: {
        type: definePropType(String)
      },
      placement: {
        type: definePropType(String),
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      id: String,
      size: {
        type: String,
        default: ""
      },
      splitButton: Boolean,
      hideOnClick: {
        type: Boolean,
        default: true
      },
      loop: {
        type: Boolean,
        default: true
      },
      showTimeout: {
        type: Number,
        default: 150
      },
      hideTimeout: {
        type: Number,
        default: 150
      },
      tabindex: {
        type: definePropType([Number, String]),
        default: 0
      },
      maxHeight: {
        type: definePropType([Number, String]),
        default: ""
      },
      popperClass: {
        type: String,
        default: ""
      },
      disabled: {
        type: Boolean,
        default: false
      },
      role: {
        type: String,
        default: "menu"
      },
      buttonProps: {
        type: definePropType(Object)
      },
      teleported: useTooltipContentProps.teleported
    });
    const dropdownItemProps = buildProps({
      command: {
        type: [Object, String, Number],
        default: () => ({})
      },
      disabled: Boolean,
      divided: Boolean,
      textValue: String,
      icon: {
        type: iconPropType
      }
    });
    const dropdownMenuProps = buildProps({
      onKeydown: { type: definePropType(Function) }
    });
    const FIRST_KEYS = [
      EVENT_CODE.down,
      EVENT_CODE.pageDown,
      EVENT_CODE.home
    ];
    const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
    const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    const {
      ElCollection,
      ElCollectionItem,
      COLLECTION_INJECTION_KEY,
      COLLECTION_ITEM_INJECTION_KEY
    } = createCollectionWithScope("Dropdown");
    const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
    const { ButtonGroup: ElButtonGroup } = ElButton;
    const _sfc_main$v = /* @__PURE__ */ defineComponent({
      name: "ElDropdown",
      components: {
        ElButton,
        ElButtonGroup,
        ElScrollbar,
        ElDropdownCollection: ElCollection,
        ElTooltip,
        ElRovingFocusGroup,
        ElOnlyChild: OnlyChild,
        ElIcon,
        ArrowDown: arrow_down_default
      },
      props: dropdownProps,
      emits: ["visible-change", "click", "command"],
      setup(props, { emit: emit2 }) {
        const _instance = getCurrentInstance();
        const ns = useNamespace("dropdown");
        const { t } = useLocale();
        const triggeringElementRef = ref();
        const referenceElementRef = ref();
        const popperRef = ref(null);
        const contentRef = ref(null);
        const scrollbar = ref(null);
        const currentTabId = ref(null);
        const isUsingKeyboard = ref(false);
        const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
        const wrapStyle = computed(() => ({
          maxHeight: addUnit(props.maxHeight)
        }));
        const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
        const trigger2 = computed(() => castArray(props.trigger));
        const defaultTriggerId = useId().value;
        const triggerId = computed(() => {
          return props.id || defaultTriggerId;
        });
        watch([triggeringElementRef, trigger2], ([triggeringElement, trigger22], [prevTriggeringElement]) => {
          var _a2, _b, _c;
          if ((_a2 = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a2.removeEventListener) {
            prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
          }
          if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) {
            triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
          }
          if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && trigger22.includes("hover")) {
            triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
          }
        }, { immediate: true });
        onBeforeUnmount(() => {
          var _a2, _b;
          if ((_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.removeEventListener) {
            triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
          }
        });
        function handleClick() {
          handleClose();
        }
        function handleClose() {
          var _a2;
          (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
        }
        function handleOpen() {
          var _a2;
          (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
        }
        const dropdownSize = useFormSize();
        function commandHandler(...args) {
          emit2("command", ...args);
        }
        function onAutofocusTriggerEnter() {
          var _a2, _b;
          (_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.focus();
        }
        function onItemEnter() {
        }
        function onItemLeave() {
          const contentEl = unref(contentRef);
          trigger2.value.includes("hover") && (contentEl == null ? void 0 : contentEl.focus());
          currentTabId.value = null;
        }
        function handleCurrentTabIdChange(id) {
          currentTabId.value = id;
        }
        function handleEntryFocus(e) {
          if (!isUsingKeyboard.value) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }
        function handleBeforeShowTooltip() {
          emit2("visible-change", true);
        }
        function handleShowTooltip(event) {
          if ((event == null ? void 0 : event.type) === "keydown") {
            contentRef.value.focus();
          }
        }
        function handleBeforeHideTooltip() {
          emit2("visible-change", false);
        }
        provide(DROPDOWN_INJECTION_KEY, {
          contentRef,
          role: computed(() => props.role),
          triggerId,
          isUsingKeyboard,
          onItemEnter,
          onItemLeave
        });
        provide("elDropdown", {
          instance: _instance,
          dropdownSize,
          handleClick,
          commandHandler,
          trigger: toRef(props, "trigger"),
          hideOnClick: toRef(props, "hideOnClick")
        });
        const onFocusAfterTrapped = (e) => {
          var _a2, _b;
          e.preventDefault();
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
            preventScroll: true
          });
        };
        const handlerMainButtonClick = (event) => {
          emit2("click", event);
        };
        return {
          t,
          ns,
          scrollbar,
          wrapStyle,
          dropdownTriggerKls,
          dropdownSize,
          triggerId,
          triggerKeys,
          currentTabId,
          handleCurrentTabIdChange,
          handlerMainButtonClick,
          handleEntryFocus,
          handleClose,
          handleOpen,
          handleBeforeShowTooltip,
          handleShowTooltip,
          handleBeforeHideTooltip,
          onFocusAfterTrapped,
          popperRef,
          contentRef,
          triggeringElementRef,
          referenceElementRef
        };
      }
    });
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2;
      const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
      const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_only_child = resolveComponent("el-only-child");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_button = resolveComponent("el-button");
      const _component_arrow_down = resolveComponent("arrow-down");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_button_group = resolveComponent("el-button-group");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
      }, [
        createVNode(_component_el_tooltip, {
          ref: "popperRef",
          role: _ctx.role,
          effect: _ctx.effect,
          "fallback-placements": ["bottom", "top"],
          "popper-options": _ctx.popperOptions,
          "gpu-acceleration": false,
          "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
          "manual-mode": true,
          placement: _ctx.placement,
          "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
          "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
          trigger: _ctx.trigger,
          "trigger-keys": _ctx.triggerKeys,
          "trigger-target-el": _ctx.contentRef,
          "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
          "stop-popper-mouse-event": false,
          "virtual-ref": _ctx.triggeringElementRef,
          "virtual-triggering": _ctx.splitButton,
          disabled: _ctx.disabled,
          transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
          teleported: _ctx.teleported,
          pure: "",
          persistent: "",
          onBeforeShow: _ctx.handleBeforeShowTooltip,
          onShow: _ctx.handleShowTooltip,
          onBeforeHide: _ctx.handleBeforeHideTooltip
        }, createSlots({
          content: withCtx(() => [
            createVNode(_component_el_scrollbar, {
              ref: "scrollbar",
              "wrap-style": _ctx.wrapStyle,
              tag: "div",
              "view-class": _ctx.ns.e("list")
            }, {
              default: withCtx(() => [
                createVNode(_component_el_roving_focus_group, {
                  loop: _ctx.loop,
                  "current-tab-id": _ctx.currentTabId,
                  orientation: "horizontal",
                  onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                  onEntryFocus: _ctx.handleEntryFocus
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_dropdown_collection, null, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "dropdown")
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
              ]),
              _: 3
            }, 8, ["wrap-style", "view-class"])
          ]),
          _: 2
        }, [
          !_ctx.splitButton ? {
            name: "default",
            fn: withCtx(() => [
              createVNode(_component_el_only_child, {
                id: _ctx.triggerId,
                ref: "triggeringElementRef",
                role: "button",
                tabindex: _ctx.tabindex
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["id", "tabindex"])
            ])
          } : void 0
        ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
        _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
          default: withCtx(() => [
            createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
              size: _ctx.dropdownSize,
              type: _ctx.type,
              disabled: _ctx.disabled,
              tabindex: _ctx.tabindex,
              onClick: _ctx.handlerMainButtonClick
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
            createVNode(_component_el_button, mergeProps({
              id: _ctx.triggerId,
              ref: "triggeringElementRef"
            }, _ctx.buttonProps, {
              role: "button",
              size: _ctx.dropdownSize,
              type: _ctx.type,
              class: _ctx.ns.e("caret-button"),
              disabled: _ctx.disabled,
              tabindex: _ctx.tabindex,
              "aria-label": _ctx.t("el.dropdown.toggleDropdown")
            }), {
              default: withCtx(() => [
                createVNode(_component_el_icon, {
                  class: normalizeClass(_ctx.ns.e("icon"))
                }, {
                  default: withCtx(() => [
                    createVNode(_component_arrow_down)
                  ]),
                  _: 1
                }, 8, ["class"])
              ]),
              _: 1
            }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
          ]),
          _: 3
        })) : createCommentVNode("v-if", true)
      ], 2);
    }
    var Dropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$a], ["__file", "dropdown.vue"]]);
    const _sfc_main$u = /* @__PURE__ */ defineComponent({
      name: "DropdownItemImpl",
      components: {
        ElIcon
      },
      props: dropdownItemProps,
      emits: ["pointermove", "pointerleave", "click", "clickimpl"],
      setup(_2, { emit: emit2 }) {
        const ns = useNamespace("dropdown");
        const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
        const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
        const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
        const {
          rovingFocusGroupItemRef,
          tabIndex,
          handleFocus,
          handleKeydown: handleItemKeydown,
          handleMousedown
        } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
        const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
        const role = computed(() => {
          if (menuRole.value === "menu") {
            return "menuitem";
          } else if (menuRole.value === "navigation") {
            return "link";
          }
          return "button";
        });
        const handleKeydown = composeEventHandlers((e) => {
          const { code } = e;
          if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
            e.preventDefault();
            e.stopImmediatePropagation();
            emit2("clickimpl", e);
            return true;
          }
        }, handleItemKeydown);
        return {
          ns,
          itemRef,
          dataset: {
            [COLLECTION_ITEM_SIGN]: ""
          },
          role,
          tabIndex,
          handleFocus,
          handleKeydown,
          handleMousedown
        };
      }
    });
    const _hoisted_1$n = ["aria-disabled", "tabindex", "role"];
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_icon = resolveComponent("el-icon");
      return openBlock(), createElementBlock(Fragment, null, [
        _ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          role: "separator",
          class: _ctx.ns.bem("menu", "item", "divided")
        }, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true),
        createBaseVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
          "aria-disabled": _ctx.disabled,
          class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
          tabindex: _ctx.tabIndex,
          role: _ctx.role,
          onClick: _cache[0] || (_cache[0] = (e) => _ctx.$emit("clickimpl", e)),
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
          onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
          onPointermove: _cache[4] || (_cache[4] = (e) => _ctx.$emit("pointermove", e)),
          onPointerleave: _cache[5] || (_cache[5] = (e) => _ctx.$emit("pointerleave", e))
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
            ]),
            _: 1
          })) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default")
        ], 16, _hoisted_1$n)
      ], 64);
    }
    var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$9], ["__file", "dropdown-item-impl.vue"]]);
    const useDropdown = () => {
      const elDropdown = inject("elDropdown", {});
      const _elDropdownSize = computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
      return {
        elDropdown,
        _elDropdownSize
      };
    };
    const _sfc_main$t = /* @__PURE__ */ defineComponent({
      name: "ElDropdownItem",
      components: {
        ElDropdownCollectionItem: ElCollectionItem,
        ElRovingFocusItem,
        ElDropdownItemImpl
      },
      inheritAttrs: false,
      props: dropdownItemProps,
      emits: ["pointermove", "pointerleave", "click"],
      setup(props, { emit: emit2, attrs }) {
        const { elDropdown } = useDropdown();
        const _instance = getCurrentInstance();
        const itemRef = ref(null);
        const textContent = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = unref(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
        });
        const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
        const handlePointerMove = composeEventHandlers((e) => {
          emit2("pointermove", e);
          return e.defaultPrevented;
        }, whenMouse((e) => {
          if (props.disabled) {
            onItemLeave(e);
            return;
          }
          const target = e.currentTarget;
          if (target === document.activeElement || target.contains(document.activeElement)) {
            return;
          }
          onItemEnter(e);
          if (!e.defaultPrevented) {
            target == null ? void 0 : target.focus();
          }
        }));
        const handlePointerLeave = composeEventHandlers((e) => {
          emit2("pointerleave", e);
          return e.defaultPrevented;
        }, whenMouse((e) => {
          onItemLeave(e);
        }));
        const handleClick = composeEventHandlers((e) => {
          if (props.disabled) {
            return;
          }
          emit2("click", e);
          return e.type !== "keydown" && e.defaultPrevented;
        }, (e) => {
          var _a2, _b, _c;
          if (props.disabled) {
            e.stopImmediatePropagation();
            return;
          }
          if ((_a2 = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a2.value) {
            (_b = elDropdown.handleClick) == null ? void 0 : _b.call(elDropdown);
          }
          (_c = elDropdown.commandHandler) == null ? void 0 : _c.call(elDropdown, props.command, _instance, e);
        });
        const propsAndAttrs = computed(() => {
          return { ...props, ...attrs };
        });
        return {
          handleClick,
          handlePointerMove,
          handlePointerLeave,
          textContent,
          propsAndAttrs
        };
      }
    });
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2;
      const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
      const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
      const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
      return openBlock(), createBlock(_component_el_dropdown_collection_item, {
        disabled: _ctx.disabled,
        "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
      }, {
        default: withCtx(() => [
          createVNode(_component_el_roving_focus_item, {
            focusable: !_ctx.disabled
          }, {
            default: withCtx(() => [
              createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
                onPointerleave: _ctx.handlePointerLeave,
                onPointermove: _ctx.handlePointerMove,
                onClickimpl: _ctx.handleClick
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
            ]),
            _: 3
          }, 8, ["focusable"])
        ]),
        _: 3
      }, 8, ["disabled", "text-value"]);
    }
    var DropdownItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$8], ["__file", "dropdown-item.vue"]]);
    const _sfc_main$s = /* @__PURE__ */ defineComponent({
      name: "ElDropdownMenu",
      props: dropdownMenuProps,
      setup(props) {
        const ns = useNamespace("dropdown");
        const { _elDropdownSize } = useDropdown();
        const size2 = _elDropdownSize.value;
        const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
        const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
        const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
        const {
          rovingFocusGroupRef,
          rovingFocusGroupRootStyle,
          tabIndex,
          onBlur,
          onFocus,
          onMousedown
        } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
        const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
        const dropdownKls = computed(() => {
          return [ns.b("menu"), ns.bm("menu", size2 == null ? void 0 : size2.value)];
        });
        const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
        const composedKeydown = composeEventHandlers((e) => {
          var _a2;
          (_a2 = props.onKeydown) == null ? void 0 : _a2.call(props, e);
        }, (e) => {
          const { currentTarget, code, target } = e;
          currentTarget.contains(target);
          if (EVENT_CODE.tab === code) {
            e.stopImmediatePropagation();
          }
          e.preventDefault();
          if (target !== unref(contentRef))
            return;
          if (!FIRST_LAST_KEYS.includes(code))
            return;
          const items = getItems().filter((item) => !item.disabled);
          const targets = items.map((item) => item.ref);
          if (LAST_KEYS.includes(code)) {
            targets.reverse();
          }
          focusFirst(targets);
        });
        const handleKeydown = (e) => {
          composedKeydown(e);
          onKeydown(e);
        };
        return {
          size: size2,
          rovingFocusGroupRootStyle,
          tabIndex,
          dropdownKls,
          role,
          triggerId,
          dropdownListWrapperRef,
          handleKeydown,
          onBlur,
          onFocus,
          onMousedown
        };
      }
    });
    const _hoisted_1$m = ["role", "aria-labelledby"];
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("ul", {
        ref: _ctx.dropdownListWrapperRef,
        class: normalizeClass(_ctx.dropdownKls),
        style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
        tabindex: -1,
        role: _ctx.role,
        "aria-labelledby": _ctx.triggerId,
        onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
        onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.onMousedown && _ctx.onMousedown(...args), ["self"]))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 46, _hoisted_1$m);
    }
    var DropdownMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$7], ["__file", "dropdown-menu.vue"]]);
    const ElDropdown = withInstall(Dropdown, {
      DropdownItem,
      DropdownMenu
    });
    const ElDropdownItem = withNoopInstall(DropdownItem);
    const ElDropdownMenu = withNoopInstall(DropdownMenu);
    const elPaginationKey = Symbol("elPaginationKey");
    const paginationPrevProps = buildProps({
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1
      },
      prevText: {
        type: String
      },
      prevIcon: {
        type: iconPropType
      }
    });
    const paginationPrevEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const _hoisted_1$l = ["disabled", "aria-label", "aria-disabled"];
    const _hoisted_2$d = { key: 0 };
    const __default__$e = /* @__PURE__ */ defineComponent({
      name: "ElPaginationPrev"
    });
    const _sfc_main$r = /* @__PURE__ */ defineComponent({
      ...__default__$e,
      props: paginationPrevProps,
      emits: paginationPrevEmits,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const internalDisabled = computed(() => props.disabled || props.currentPage <= 1);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            type: "button",
            class: "btn-prev",
            disabled: unref(internalDisabled),
            "aria-label": _ctx.prevText || unref(t)("el.pagination.prev"),
            "aria-disabled": unref(internalDisabled),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
          }, [
            _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$d, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))
              ]),
              _: 1
            }))
          ], 8, _hoisted_1$l);
        };
      }
    });
    var Prev = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "prev.vue"]]);
    const paginationNextProps = buildProps({
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1
      },
      pageCount: {
        type: Number,
        default: 50
      },
      nextText: {
        type: String
      },
      nextIcon: {
        type: iconPropType
      }
    });
    const _hoisted_1$k = ["disabled", "aria-label", "aria-disabled"];
    const _hoisted_2$c = { key: 0 };
    const __default__$d = /* @__PURE__ */ defineComponent({
      name: "ElPaginationNext"
    });
    const _sfc_main$q = /* @__PURE__ */ defineComponent({
      ...__default__$d,
      props: paginationNextProps,
      emits: ["click"],
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const internalDisabled = computed(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            type: "button",
            class: "btn-next",
            disabled: unref(internalDisabled),
            "aria-label": _ctx.nextText || unref(t)("el.pagination.next"),
            "aria-disabled": unref(internalDisabled),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
          }, [
            _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$c, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))
              ]),
              _: 1
            }))
          ], 8, _hoisted_1$k);
        };
      }
    });
    var Next = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__file", "next.vue"]]);
    const selectGroupKey = Symbol("ElSelectGroup");
    const selectKey = Symbol("ElSelect");
    function useOption(props, states) {
      const select = inject(selectKey);
      const selectGroup = inject(selectGroupKey, { disabled: false });
      const itemSelected = computed(() => {
        if (!select.props.multiple) {
          return isEqual(props.value, select.props.modelValue);
        } else {
          return contains(select.props.modelValue, props.value);
        }
      });
      const limitReached = computed(() => {
        if (select.props.multiple) {
          const modelValue = select.props.modelValue || [];
          return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
        } else {
          return false;
        }
      });
      const currentLabel = computed(() => {
        return props.label || (isObject$1(props.value) ? "" : props.value);
      });
      const currentValue = computed(() => {
        return props.value || props.label || "";
      });
      const isDisabled = computed(() => {
        return props.disabled || states.groupDisabled || limitReached.value;
      });
      const instance = getCurrentInstance();
      const contains = (arr = [], target) => {
        if (!isObject$1(props.value)) {
          return arr && arr.includes(target);
        } else {
          const valueKey = select.props.valueKey;
          return arr && arr.some((item) => {
            return toRaw(get(item, valueKey)) === get(target, valueKey);
          });
        }
      };
      const hoverItem = () => {
        if (!props.disabled && !selectGroup.disabled) {
          select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
        }
      };
      const updateOption = (query) => {
        const regexp = new RegExp(escapeStringRegexp(query), "i");
        states.visible = regexp.test(currentLabel.value) || props.created;
      };
      watch(() => currentLabel.value, () => {
        if (!props.created && !select.props.remote)
          select.setSelected();
      });
      watch(() => props.value, (val, oldVal) => {
        const { remote, valueKey } = select.props;
        if (!isEqual(val, oldVal)) {
          select.onOptionDestroy(oldVal, instance.proxy);
          select.onOptionCreate(instance.proxy);
        }
        if (!props.created && !remote) {
          if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
            return;
          }
          select.setSelected();
        }
      });
      watch(() => selectGroup.disabled, () => {
        states.groupDisabled = selectGroup.disabled;
      }, { immediate: true });
      return {
        select,
        currentLabel,
        currentValue,
        itemSelected,
        isDisabled,
        hoverItem,
        updateOption
      };
    }
    const _sfc_main$p = /* @__PURE__ */ defineComponent({
      name: "ElOption",
      componentName: "ElOption",
      props: {
        value: {
          required: true,
          type: [String, Number, Boolean, Object]
        },
        label: [String, Number],
        created: Boolean,
        disabled: Boolean
      },
      setup(props) {
        const ns = useNamespace("select");
        const id = useId();
        const containerKls = computed(() => [
          ns.be("dropdown", "item"),
          ns.is("disabled", unref(isDisabled)),
          ns.is("selected", unref(itemSelected)),
          ns.is("hovering", unref(hover))
        ]);
        const states = reactive({
          index: -1,
          groupDisabled: false,
          visible: true,
          hover: false
        });
        const {
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          updateOption
        } = useOption(props, states);
        const { visible, hover } = toRefs(states);
        const vm = getCurrentInstance().proxy;
        select.onOptionCreate(vm);
        onBeforeUnmount(() => {
          const key = vm.value;
          const { selected } = select.states;
          const selectedOptions = select.props.multiple ? selected : [selected];
          const doesSelected = selectedOptions.some((item) => {
            return item.value === vm.value;
          });
          nextTick(() => {
            if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
              select.states.cachedOptions.delete(key);
            }
          });
          select.onOptionDestroy(key, vm);
        });
        function selectOptionClick() {
          if (props.disabled !== true && states.groupDisabled !== true) {
            select.handleOptionSelect(vm);
          }
        }
        return {
          ns,
          id,
          containerKls,
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          updateOption,
          visible,
          hover,
          selectOptionClick,
          states
        };
      }
    });
    const _hoisted_1$j = ["id", "aria-disabled", "aria-selected"];
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("li", {
        id: _ctx.id,
        class: normalizeClass(_ctx.containerKls),
        role: "option",
        "aria-disabled": _ctx.isDisabled || void 0,
        "aria-selected": _ctx.itemSelected,
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
        ])
      ], 42, _hoisted_1$j)), [
        [vShow, _ctx.visible]
      ]);
    }
    var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$6], ["__file", "option.vue"]]);
    const _sfc_main$o = /* @__PURE__ */ defineComponent({
      name: "ElSelectDropdown",
      componentName: "ElSelectDropdown",
      setup() {
        const select = inject(selectKey);
        const ns = useNamespace("select");
        const popperClass = computed(() => select.props.popperClass);
        const isMultiple = computed(() => select.props.multiple);
        const isFitInputWidth = computed(() => select.props.fitInputWidth);
        const minWidth = ref("");
        function updateMinWidth() {
          var _a2;
          minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
        }
        onMounted(() => {
          updateMinWidth();
          useResizeObserver(select.selectRef, updateMinWidth);
        });
        return {
          ns,
          minWidth,
          popperClass,
          isMultiple,
          isFitInputWidth
        };
      }
    });
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
        style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
      }, [
        _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("dropdown", "header"))
        }, [
          renderSlot(_ctx.$slots, "header")
        ], 2)) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
        }, [
          renderSlot(_ctx.$slots, "footer")
        ], 2)) : createCommentVNode("v-if", true)
      ], 6);
    }
    var ElSelectMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$5], ["__file", "select-dropdown.vue"]]);
    function useInput(handleInput) {
      const isComposing = ref(false);
      const handleCompositionStart = () => {
        isComposing.value = true;
      };
      const handleCompositionUpdate = (event) => {
        const text = event.target.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !isKorean(lastCharacter);
      };
      const handleCompositionEnd = (event) => {
        if (isComposing.value) {
          isComposing.value = false;
          if (isFunction$2(handleInput)) {
            handleInput(event);
          }
        }
      };
      return {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      };
    }
    const MINIMUM_INPUT_WIDTH = 11;
    const useSelect = (props, emit2) => {
      const { t } = useLocale();
      const contentId = useId();
      const nsSelect = useNamespace("select");
      const nsInput = useNamespace("input");
      const states = reactive({
        inputValue: "",
        options: /* @__PURE__ */ new Map(),
        cachedOptions: /* @__PURE__ */ new Map(),
        disabledOptions: /* @__PURE__ */ new Map(),
        optionValues: [],
        selected: props.multiple ? [] : {},
        selectionWidth: 0,
        calculatorWidth: 0,
        collapseItemWidth: 0,
        selectedLabel: "",
        hoveringIndex: -1,
        previousQuery: null,
        inputHovering: false,
        menuVisibleOnFocus: false,
        isBeforeHide: false
      });
      useDeprecated({
        from: "suffixTransition",
        replacement: "override style scheme",
        version: "2.3.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
      }, computed(() => props.suffixTransition === false));
      const selectRef = ref(null);
      const selectionRef = ref(null);
      const tooltipRef = ref(null);
      const tagTooltipRef = ref(null);
      const inputRef = ref(null);
      const calculatorRef = ref(null);
      const prefixRef = ref(null);
      const suffixRef = ref(null);
      const menuRef = ref(null);
      const tagMenuRef = ref(null);
      const collapseItemRef = ref(null);
      const scrollbarRef = ref(null);
      const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
        afterFocus() {
          if (props.automaticDropdown && !expanded.value) {
            expanded.value = true;
            states.menuVisibleOnFocus = true;
          }
        },
        beforeBlur(event) {
          var _a2, _b;
          return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
        },
        afterBlur() {
          expanded.value = false;
          states.menuVisibleOnFocus = false;
        }
      });
      const expanded = ref(false);
      const hoverOption = ref();
      const { form, formItem } = useFormItem();
      const { inputId } = useFormItemInputId(props, {
        formItemContext: formItem
      });
      const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
      const hasModelValue = computed(() => {
        return props.multiple ? isArray$1(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
      });
      const showClose = computed(() => {
        const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        return criteria;
      });
      const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
      const iconReverse = computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value && props.suffixTransition));
      const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
      const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
      const debounce$1 = computed(() => props.remote ? 300 : 0);
      const emptyText = computed(() => {
        if (props.loading) {
          return props.loadingText || t("el.select.loading");
        } else {
          if (props.remote && !states.inputValue && states.options.size === 0)
            return false;
          if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
            return props.noMatchText || t("el.select.noMatch");
          }
          if (states.options.size === 0) {
            return props.noDataText || t("el.select.noData");
          }
        }
        return null;
      });
      const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
      const optionsArray = computed(() => {
        const list = Array.from(states.options.values());
        const newList = [];
        states.optionValues.forEach((item) => {
          const index = list.findIndex((i) => i.value === item);
          if (index > -1) {
            newList.push(list[index]);
          }
        });
        return newList.length >= list.length ? newList : list;
      });
      const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
      const showNewOption = computed(() => {
        const hasExistingOption = optionsArray.value.filter((option) => {
          return !option.created;
        }).some((option) => {
          return option.currentLabel === states.inputValue;
        });
        return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
      });
      const updateOptions2 = () => {
        if (props.filterable && isFunction$2(props.filterMethod))
          return;
        if (props.filterable && props.remote && isFunction$2(props.remoteMethod))
          return;
        optionsArray.value.forEach((option) => {
          option.updateOption(states.inputValue);
        });
      };
      const selectSize = useFormSize();
      const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
      const dropdownMenuVisible = computed({
        get() {
          return expanded.value && emptyText.value !== false;
        },
        set(val) {
          expanded.value = val;
        }
      });
      const shouldShowPlaceholder = computed(() => {
        if (isArray$1(props.modelValue)) {
          return props.modelValue.length === 0 && !states.inputValue;
        }
        return props.filterable ? !states.inputValue : true;
      });
      const currentPlaceholder = computed(() => {
        var _a2;
        const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t("el.select.placeholder");
        return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
      });
      watch(() => props.modelValue, (val, oldVal) => {
        if (props.multiple) {
          if (props.filterable && !props.reserveKeyword) {
            states.inputValue = "";
            handleQueryChange("");
          }
        }
        setSelected();
        if (!isEqual(val, oldVal) && props.validateEvent) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
        }
      }, {
        flush: "post",
        deep: true
      });
      watch(() => expanded.value, (val) => {
        if (val) {
          handleQueryChange(states.inputValue);
        } else {
          states.inputValue = "";
          states.previousQuery = null;
          states.isBeforeHide = true;
        }
        emit2("visible-change", val);
      });
      watch(() => states.options.entries(), () => {
        var _a2;
        if (!isClient)
          return;
        const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
        if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
          setSelected();
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
          checkDefaultFirstOption();
        }
      }, {
        flush: "post"
      });
      watch(() => states.hoveringIndex, (val) => {
        if (isNumber(val) && val > -1) {
          hoverOption.value = optionsArray.value[val] || {};
        } else {
          hoverOption.value = {};
        }
        optionsArray.value.forEach((option) => {
          option.hover = hoverOption.value === option;
        });
      });
      watchEffect(() => {
        if (states.isBeforeHide)
          return;
        updateOptions2();
      });
      const handleQueryChange = (val) => {
        if (states.previousQuery === val) {
          return;
        }
        states.previousQuery = val;
        if (props.filterable && isFunction$2(props.filterMethod)) {
          props.filterMethod(val);
        } else if (props.filterable && props.remote && isFunction$2(props.remoteMethod)) {
          props.remoteMethod(val);
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
          nextTick(checkDefaultFirstOption);
        } else {
          nextTick(updateHoveringIndex);
        }
      };
      const checkDefaultFirstOption = () => {
        const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
        const userCreatedOption = optionsInDropdown.find((n) => n.created);
        const firstOriginOption = optionsInDropdown[0];
        states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
      };
      const setSelected = () => {
        if (!props.multiple) {
          const option = getOption(props.modelValue);
          states.selectedLabel = option.currentLabel;
          states.selected = option;
          return;
        } else {
          states.selectedLabel = "";
        }
        const result = [];
        if (isArray$1(props.modelValue)) {
          props.modelValue.forEach((value) => {
            result.push(getOption(value));
          });
        }
        states.selected = result;
      };
      const getOption = (value) => {
        let option;
        const isObjectValue = toRawType(value).toLowerCase() === "object";
        const isNull = toRawType(value).toLowerCase() === "null";
        const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
        for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
          const cachedOption = cachedOptionsArray.value[i];
          const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
          if (isEqualValue) {
            option = {
              value,
              currentLabel: cachedOption.currentLabel,
              isDisabled: cachedOption.isDisabled
            };
            break;
          }
        }
        if (option)
          return option;
        const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
        const newOption = {
          value,
          currentLabel: label
        };
        return newOption;
      };
      const updateHoveringIndex = () => {
        if (!props.multiple) {
          states.hoveringIndex = optionsArray.value.findIndex((item) => {
            return getValueKey(item) === getValueKey(states.selected);
          });
        } else {
          if (states.selected.length > 0) {
            states.hoveringIndex = Math.min(...states.selected.map((selected) => {
              return optionsArray.value.findIndex((item) => {
                return getValueKey(item) === getValueKey(selected);
              });
            }));
          } else {
            states.hoveringIndex = -1;
          }
        }
      };
      const resetSelectionWidth = () => {
        states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
      };
      const resetCalculatorWidth = () => {
        states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
      };
      const resetCollapseItemWidth = () => {
        states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
      };
      const updateTooltip = () => {
        var _a2, _b;
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const updateTagTooltip = () => {
        var _a2, _b;
        (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const onInputChange = () => {
        if (states.inputValue.length > 0 && !expanded.value) {
          expanded.value = true;
        }
        handleQueryChange(states.inputValue);
      };
      const onInput = (event) => {
        states.inputValue = event.target.value;
        if (props.remote) {
          debouncedOnInputChange();
        } else {
          return onInputChange();
        }
      };
      const debouncedOnInputChange = debounce(() => {
        onInputChange();
      }, debounce$1.value);
      const emitChange = (val) => {
        if (!isEqual(props.modelValue, val)) {
          emit2(CHANGE_EVENT, val);
        }
      };
      const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
      const deletePrevTag = (e) => {
        if (!props.multiple)
          return;
        if (e.code === EVENT_CODE.delete)
          return;
        if (e.target.value.length <= 0) {
          const value = props.modelValue.slice();
          const lastNotDisabledIndex = getLastNotDisabledIndex(value);
          if (lastNotDisabledIndex < 0)
            return;
          value.splice(lastNotDisabledIndex, 1);
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
        }
      };
      const deleteTag = (event, tag) => {
        const index = states.selected.indexOf(tag);
        if (index > -1 && !selectDisabled.value) {
          const value = props.modelValue.slice();
          value.splice(index, 1);
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          emit2("remove-tag", tag.value);
        }
        event.stopPropagation();
        focus();
      };
      const deleteSelected = (event) => {
        event.stopPropagation();
        const value = props.multiple ? [] : "";
        if (!isString$1(value)) {
          for (const item of states.selected) {
            if (item.isDisabled)
              value.push(item.value);
          }
        }
        emit2(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        states.hoveringIndex = -1;
        expanded.value = false;
        emit2("clear");
        focus();
      };
      const handleOptionSelect = (option) => {
        if (props.multiple) {
          const value = (props.modelValue || []).slice();
          const optionIndex = getValueIndex(value, option.value);
          if (optionIndex > -1) {
            value.splice(optionIndex, 1);
          } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
            value.push(option.value);
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          if (option.created) {
            handleQueryChange("");
          }
          if (props.filterable && !props.reserveKeyword) {
            states.inputValue = "";
          }
        } else {
          emit2(UPDATE_MODEL_EVENT, option.value);
          emitChange(option.value);
          expanded.value = false;
        }
        focus();
        if (expanded.value)
          return;
        nextTick(() => {
          scrollToOption(option);
        });
      };
      const getValueIndex = (arr = [], value) => {
        if (!isObject$1(value))
          return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index = -1;
        arr.some((item, i) => {
          if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
            index = i;
            return true;
          }
          return false;
        });
        return index;
      };
      const scrollToOption = (option) => {
        var _a2, _b, _c, _d, _e;
        const targetOption = isArray$1(option) ? option[0] : option;
        let target = null;
        if (targetOption == null ? void 0 : targetOption.value) {
          const options = optionsArray.value.filter((item) => item.value === targetOption.value);
          if (options.length > 0) {
            target = options[0].$el;
          }
        }
        if (tooltipRef.value && target) {
          const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
          if (menu) {
            scrollIntoView(menu, target);
          }
        }
        (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
      };
      const onOptionCreate = (vm) => {
        states.options.set(vm.value, vm);
        states.cachedOptions.set(vm.value, vm);
        vm.disabled && states.disabledOptions.set(vm.value, vm);
      };
      const onOptionDestroy = (key, vm) => {
        if (states.options.get(key) === vm) {
          states.options.delete(key);
        }
      };
      const {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      } = useInput((e) => onInput(e));
      const popperRef = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
      });
      const handleMenuEnter = () => {
        nextTick(() => scrollToOption(states.selected));
      };
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
      };
      const blur = () => {
        handleClickOutside();
      };
      const handleClearClick = (event) => {
        deleteSelected(event);
      };
      const handleClickOutside = (event) => {
        expanded.value = false;
        if (isFocused.value) {
          const _event2 = new FocusEvent("focus", event);
          nextTick(() => handleBlur(_event2));
        }
      };
      const handleEsc = () => {
        if (states.inputValue.length > 0) {
          states.inputValue = "";
        } else {
          expanded.value = false;
        }
      };
      const toggleMenu = () => {
        if (selectDisabled.value)
          return;
        if (props.filterable && props.remote && isFunction$2(props.remoteMethod))
          return;
        if (states.menuVisibleOnFocus) {
          states.menuVisibleOnFocus = false;
        } else {
          expanded.value = !expanded.value;
        }
      };
      const selectOption = () => {
        if (!expanded.value) {
          toggleMenu();
        } else {
          if (optionsArray.value[states.hoveringIndex]) {
            handleOptionSelect(optionsArray.value[states.hoveringIndex]);
          }
        }
      };
      const getValueKey = (item) => {
        return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
      };
      const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
      const showTagList = computed(() => {
        if (!props.multiple) {
          return [];
        }
        return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
      });
      const collapseTagList = computed(() => {
        if (!props.multiple) {
          return [];
        }
        return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
      });
      const navigateOptions = (direction) => {
        if (!expanded.value) {
          expanded.value = true;
          return;
        }
        if (states.options.size === 0 || filteredOptionsCount.value === 0)
          return;
        if (!optionsAllDisabled.value) {
          if (direction === "next") {
            states.hoveringIndex++;
            if (states.hoveringIndex === states.options.size) {
              states.hoveringIndex = 0;
            }
          } else if (direction === "prev") {
            states.hoveringIndex--;
            if (states.hoveringIndex < 0) {
              states.hoveringIndex = states.options.size - 1;
            }
          }
          const option = optionsArray.value[states.hoveringIndex];
          if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
            navigateOptions(direction);
          }
          nextTick(() => scrollToOption(hoverOption.value));
        }
      };
      const getGapWidth = () => {
        if (!selectionRef.value)
          return 0;
        const style = window.getComputedStyle(selectionRef.value);
        return Number.parseFloat(style.gap || "6px");
      };
      const tagStyle = computed(() => {
        const gapWidth = getGapWidth();
        const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
        return { maxWidth: `${maxWidth}px` };
      });
      const collapseTagStyle = computed(() => {
        return { maxWidth: `${states.selectionWidth}px` };
      });
      const inputStyle = computed(() => ({
        width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
      }));
      if (props.multiple && !isArray$1(props.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, []);
      }
      if (!props.multiple && isArray$1(props.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, "");
      }
      useResizeObserver(selectionRef, resetSelectionWidth);
      useResizeObserver(calculatorRef, resetCalculatorWidth);
      useResizeObserver(menuRef, updateTooltip);
      useResizeObserver(wrapperRef, updateTooltip);
      useResizeObserver(tagMenuRef, updateTagTooltip);
      useResizeObserver(collapseItemRef, resetCollapseItemWidth);
      onMounted(() => {
        setSelected();
      });
      return {
        inputId,
        contentId,
        nsSelect,
        nsInput,
        states,
        isFocused,
        expanded,
        optionsArray,
        hoverOption,
        selectSize,
        filteredOptionsCount,
        resetCalculatorWidth,
        updateTooltip,
        updateTagTooltip,
        debouncedOnInputChange,
        onInput,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        hasModelValue,
        shouldShowPlaceholder,
        currentPlaceholder,
        showClose,
        iconComponent,
        iconReverse,
        validateState,
        validateIcon,
        showNewOption,
        updateOptions: updateOptions2,
        collapseTagSize,
        setSelected,
        selectDisabled,
        emptyText,
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        focus,
        blur,
        handleBlur,
        handleClearClick,
        handleClickOutside,
        handleEsc,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropdownMenuVisible,
        showTagList,
        collapseTagList,
        tagStyle,
        collapseTagStyle,
        inputStyle,
        popperRef,
        inputRef,
        tooltipRef,
        tagTooltipRef,
        calculatorRef,
        prefixRef,
        suffixRef,
        selectRef,
        wrapperRef,
        selectionRef,
        scrollbarRef,
        menuRef,
        tagMenuRef,
        collapseItemRef
      };
    };
    var ElOptions = /* @__PURE__ */ defineComponent({
      name: "ElOptions",
      setup(_2, { slots }) {
        const select = inject(selectKey);
        let cachedValueList = [];
        return () => {
          var _a2, _b;
          const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          const valueList = [];
          function filterOptions(children2) {
            if (!isArray$1(children2))
              return;
            children2.forEach((item) => {
              var _a22, _b2, _c, _d;
              const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
              if (name === "ElOptionGroup") {
                filterOptions(!isString$1(item.children) && !isArray$1(item.children) && isFunction$2((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
              } else if (name === "ElOption") {
                valueList.push((_d = item.props) == null ? void 0 : _d.value);
              } else if (isArray$1(item.children)) {
                filterOptions(item.children);
              }
            });
          }
          if (children.length) {
            filterOptions((_b = children[0]) == null ? void 0 : _b.children);
          }
          if (!isEqual(valueList, cachedValueList)) {
            cachedValueList = valueList;
            if (select) {
              select.states.optionValues = valueList;
            }
          }
          return children;
        };
      }
    });
    const SelectProps = buildProps({
      name: String,
      id: String,
      modelValue: {
        type: [Array, String, Number, Boolean, Object],
        default: void 0
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      automaticDropdown: Boolean,
      size: useSizeProp,
      effect: {
        type: definePropType(String),
        default: "light"
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: {
        type: String,
        default: ""
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: {
        type: String
      },
      defaultFirstOption: Boolean,
      reserveKeyword: {
        type: Boolean,
        default: true
      },
      valueKey: {
        type: String,
        default: "value"
      },
      collapseTags: Boolean,
      collapseTagsTooltip: Boolean,
      maxCollapseTags: {
        type: Number,
        default: 1
      },
      teleported: useTooltipContentProps.teleported,
      persistent: {
        type: Boolean,
        default: true
      },
      clearIcon: {
        type: iconPropType,
        default: circle_close_default
      },
      fitInputWidth: Boolean,
      suffixIcon: {
        type: iconPropType,
        default: arrow_down_default
      },
      tagType: { ...tagProps.type, default: "info" },
      validateEvent: {
        type: Boolean,
        default: true
      },
      remoteShowSuffix: Boolean,
      suffixTransition: {
        type: Boolean,
        default: true
      },
      placement: {
        type: definePropType(String),
        values: Ee,
        default: "bottom-start"
      },
      ariaLabel: {
        type: String,
        default: void 0
      }
    });
    const COMPONENT_NAME$2 = "ElSelect";
    const _sfc_main$n = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$2,
      componentName: COMPONENT_NAME$2,
      components: {
        ElInput,
        ElSelectMenu,
        ElOption: Option,
        ElOptions,
        ElTag,
        ElScrollbar,
        ElTooltip,
        ElIcon
      },
      directives: { ClickOutside },
      props: SelectProps,
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
      ],
      setup(props, { emit: emit2 }) {
        const API = useSelect(props, emit2);
        provide(selectKey, reactive({
          props,
          states: API.states,
          optionsArray: API.optionsArray,
          handleOptionSelect: API.handleOptionSelect,
          onOptionCreate: API.onOptionCreate,
          onOptionDestroy: API.onOptionDestroy,
          selectRef: API.selectRef,
          setSelected: API.setSelected
        }));
        return {
          ...API
        };
      }
    });
    const _hoisted_1$i = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
    const _hoisted_2$b = ["textContent"];
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_option = resolveComponent("el-option");
      const _component_el_options = resolveComponent("el-options");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select_menu = resolveComponent("el-select-menu");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "selectRef",
        class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
        onMouseenter: _cache[14] || (_cache[14] = ($event) => _ctx.states.inputHovering = true),
        onMouseleave: _cache[15] || (_cache[15] = ($event) => _ctx.states.inputHovering = false),
        onClick: _cache[16] || (_cache[16] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
      }, [
        createVNode(_component_el_tooltip, {
          ref: "tooltipRef",
          visible: _ctx.dropdownMenuVisible,
          placement: _ctx.placement,
          teleported: _ctx.teleported,
          "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
          "popper-options": _ctx.popperOptions,
          "fallback-placements": ["bottom-start", "top-start", "right", "left"],
          effect: _ctx.effect,
          pure: "",
          trigger: "click",
          transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
          "stop-popper-mouse-event": false,
          "gpu-acceleration": false,
          persistent: _ctx.persistent,
          onBeforeShow: _ctx.handleMenuEnter,
          onHide: _cache[13] || (_cache[13] = ($event) => _ctx.states.isBeforeHide = false)
        }, {
          default: withCtx(() => {
            var _a2;
            return [
              createBaseVNode("div", {
                ref: "wrapperRef",
                class: normalizeClass([
                  _ctx.nsSelect.e("wrapper"),
                  _ctx.nsSelect.is("focused", _ctx.isFocused),
                  _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                  _ctx.nsSelect.is("filterable", _ctx.filterable),
                  _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "prefixRef",
                  class: normalizeClass(_ctx.nsSelect.e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref: "selectionRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("selection"),
                    _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                  ])
                }, [
                  _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(item),
                        class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !item.isDisabled,
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          "disable-transitions": "",
                          style: normalizeStyle(_ctx.tagStyle),
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, toDisplayString(item.currentLabel), 3)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "style", "onClose"])
                      ], 2);
                    }), 128)),
                    _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                      key: 0,
                      ref: "tagTooltipRef",
                      disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      effect: _ctx.effect,
                      placement: "bottom",
                      teleported: _ctx.teleported
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          ref: "collapseItemRef",
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: false,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.collapseTagStyle)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                            ]),
                            _: 1
                          }, 8, ["size", "type", "style"])
                        ], 2)
                      ]),
                      content: withCtx(() => [
                        createBaseVNode("div", {
                          ref: "tagMenuRef",
                          class: normalizeClass(_ctx.nsSelect.e("selection"))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                            return openBlock(), createElementBlock("div", {
                              key: _ctx.getValueKey(item),
                              class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                            }, [
                              createVNode(_component_el_tag, {
                                class: "in-tooltip",
                                closable: !_ctx.selectDisabled && !item.isDisabled,
                                size: _ctx.collapseTagSize,
                                type: _ctx.tagType,
                                "disable-transitions": "",
                                onClose: ($event) => _ctx.deleteTag($event, item)
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("span", {
                                    class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                  }, toDisplayString(item.currentLabel), 3)
                                ]),
                                _: 2
                              }, 1032, ["closable", "size", "type", "onClose"])
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 1
                    }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true),
                  !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("input-wrapper"),
                      _ctx.nsSelect.is("hidden", !_ctx.filterable)
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.inputId,
                      ref: "inputRef",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                      type: "text",
                      class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                      disabled: _ctx.selectDisabled,
                      autocomplete: _ctx.autocomplete,
                      style: normalizeStyle(_ctx.inputStyle),
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                      "aria-controls": _ctx.contentId,
                      "aria-expanded": _ctx.dropdownMenuVisible,
                      "aria-label": _ctx.ariaLabel,
                      "aria-autocomplete": "none",
                      "aria-haspopup": "listbox",
                      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onKeydown: [
                        _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                        _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                        _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                      ],
                      onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onClick: _cache[12] || (_cache[12] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                    }, null, 46, _hoisted_1$i), [
                      [vModelText, _ctx.states.inputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.inputValue)
                    }, null, 10, _hoisted_2$b)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("placeholder"),
                      _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                    ])
                  }, [
                    createBaseVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createBaseVNode("div", {
                  ref: "suffixRef",
                  class: normalizeClass(_ctx.nsSelect.e("suffix"))
                }, [
                  _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                    onClick: _ctx.handleClearClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ];
          }),
          content: withCtx(() => [
            createVNode(_component_el_select_menu, { ref: "menuRef" }, {
              default: withCtx(() => [
                _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "header"))
                }, [
                  renderSlot(_ctx.$slots, "header")
                ], 2)) : createCommentVNode("v-if", true),
                withDirectives(createVNode(_component_el_scrollbar, {
                  id: _ctx.contentId,
                  ref: "scrollbarRef",
                  tag: "ul",
                  "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                  "view-class": _ctx.nsSelect.be("dropdown", "list"),
                  class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                  role: "listbox",
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": "vertical"
                }, {
                  default: withCtx(() => [
                    _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                      key: 0,
                      value: _ctx.states.inputValue,
                      created: true
                    }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                    createVNode(_component_el_options, null, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                  [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                ]),
                _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                }, [
                  renderSlot(_ctx.$slots, "loading")
                ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                }, [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                  key: 3,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer"))
                }, [
                  renderSlot(_ctx.$slots, "footer")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 512)
          ]),
          _: 3
        }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onBeforeShow"])
      ], 34)), [
        [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
      ]);
    }
    var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["render", _sfc_render$4], ["__file", "select.vue"]]);
    const _sfc_main$m = /* @__PURE__ */ defineComponent({
      name: "ElOptionGroup",
      componentName: "ElOptionGroup",
      props: {
        label: String,
        disabled: Boolean
      },
      setup(props) {
        const ns = useNamespace("select");
        const groupRef = ref(null);
        const instance = getCurrentInstance();
        const children = ref([]);
        provide(selectGroupKey, reactive({
          ...toRefs(props)
        }));
        const visible = computed(() => children.value.some((option) => option.visible === true));
        const flattedChildren = (node) => {
          const children2 = [];
          if (isArray$1(node.children)) {
            node.children.forEach((child) => {
              var _a2;
              if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                children2.push(child.component.proxy);
              } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                children2.push(...flattedChildren(child));
              }
            });
          }
          return children2;
        };
        const updateChildren = () => {
          children.value = flattedChildren(instance.subTree);
        };
        onMounted(() => {
          updateChildren();
        });
        useMutationObserver(groupRef, updateChildren, {
          attributes: true,
          subtree: true,
          childList: true
        });
        return {
          groupRef,
          visible,
          ns
        };
      }
    });
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("ul", {
        ref: "groupRef",
        class: normalizeClass(_ctx.ns.be("group", "wrap"))
      }, [
        createBaseVNode("li", {
          class: normalizeClass(_ctx.ns.be("group", "title"))
        }, toDisplayString(_ctx.label), 3),
        createBaseVNode("li", null, [
          createBaseVNode("ul", {
            class: normalizeClass(_ctx.ns.b("group"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ])
      ], 2)), [
        [vShow, _ctx.visible]
      ]);
    }
    var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$3], ["__file", "option-group.vue"]]);
    const ElSelect = withInstall(Select, {
      Option,
      OptionGroup
    });
    const ElOption = withNoopInstall(Option);
    withNoopInstall(OptionGroup);
    const usePagination = () => inject(elPaginationKey, {});
    const paginationSizesProps = buildProps({
      pageSize: {
        type: Number,
        required: true
      },
      pageSizes: {
        type: definePropType(Array),
        default: () => mutable([10, 20, 30, 40, 50, 100])
      },
      popperClass: {
        type: String
      },
      disabled: Boolean,
      teleported: Boolean,
      size: {
        type: String,
        values: componentSizes
      }
    });
    const __default__$c = /* @__PURE__ */ defineComponent({
      name: "ElPaginationSizes"
    });
    const _sfc_main$l = /* @__PURE__ */ defineComponent({
      ...__default__$c,
      props: paginationSizesProps,
      emits: ["page-size-change"],
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const pagination = usePagination();
        const innerPageSize = ref(props.pageSize);
        watch(() => props.pageSizes, (newVal, oldVal) => {
          if (isEqual(newVal, oldVal))
            return;
          if (Array.isArray(newVal)) {
            const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
            emit2("page-size-change", pageSize);
          }
        });
        watch(() => props.pageSize, (newVal) => {
          innerPageSize.value = newVal;
        });
        const innerPageSizes = computed(() => props.pageSizes);
        function handleChange(val) {
          var _a2;
          if (val !== innerPageSize.value) {
            innerPageSize.value = val;
            (_a2 = pagination.handleSizeChange) == null ? void 0 : _a2.call(pagination, Number(val));
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns).e("sizes"))
          }, [
            createVNode(unref(ElSelect), {
              "model-value": innerPageSize.value,
              disabled: _ctx.disabled,
              "popper-class": _ctx.popperClass,
              size: _ctx.size,
              teleported: _ctx.teleported,
              "validate-event": false,
              onChange: handleChange
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item) => {
                  return openBlock(), createBlock(unref(ElOption), {
                    key: item,
                    value: item,
                    label: item + unref(t)("el.pagination.pagesize")
                  }, null, 8, ["value", "label"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
          ], 2);
        };
      }
    });
    var Sizes = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "sizes.vue"]]);
    const paginationJumperProps = buildProps({
      size: {
        type: String,
        values: componentSizes
      }
    });
    const _hoisted_1$h = ["disabled"];
    const __default__$b = /* @__PURE__ */ defineComponent({
      name: "ElPaginationJumper"
    });
    const _sfc_main$k = /* @__PURE__ */ defineComponent({
      ...__default__$b,
      props: paginationJumperProps,
      setup(__props) {
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const { pageCount, disabled, currentPage, changeEvent } = usePagination();
        const userInput = ref();
        const innerValue = computed(() => {
          var _a2;
          return (_a2 = userInput.value) != null ? _a2 : currentPage == null ? void 0 : currentPage.value;
        });
        function handleInput(val) {
          userInput.value = val ? +val : "";
        }
        function handleChange(val) {
          val = Math.trunc(+val);
          changeEvent == null ? void 0 : changeEvent(val);
          userInput.value = void 0;
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns).e("jump")),
            disabled: unref(disabled)
          }, [
            createBaseVNode("span", {
              class: normalizeClass([unref(ns).e("goto")])
            }, toDisplayString(unref(t)("el.pagination.goto")), 3),
            createVNode(unref(ElInput), {
              size: _ctx.size,
              class: normalizeClass([unref(ns).e("editor"), unref(ns).is("in-pagination")]),
              min: 1,
              max: unref(pageCount),
              disabled: unref(disabled),
              "model-value": unref(innerValue),
              "validate-event": false,
              label: unref(t)("el.pagination.page"),
              type: "number",
              "onUpdate:modelValue": handleInput,
              onChange: handleChange
            }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
            createBaseVNode("span", {
              class: normalizeClass([unref(ns).e("classifier")])
            }, toDisplayString(unref(t)("el.pagination.pageClassifier")), 3)
          ], 10, _hoisted_1$h);
        };
      }
    });
    var Jumper = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "jumper.vue"]]);
    const paginationTotalProps = buildProps({
      total: {
        type: Number,
        default: 1e3
      }
    });
    const _hoisted_1$g = ["disabled"];
    const __default__$a = /* @__PURE__ */ defineComponent({
      name: "ElPaginationTotal"
    });
    const _sfc_main$j = /* @__PURE__ */ defineComponent({
      ...__default__$a,
      props: paginationTotalProps,
      setup(__props) {
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const { disabled } = usePagination();
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns).e("total")),
            disabled: unref(disabled)
          }, toDisplayString(unref(t)("el.pagination.total", {
            total: _ctx.total
          })), 11, _hoisted_1$g);
        };
      }
    });
    var Total = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "total.vue"]]);
    const paginationPagerProps = buildProps({
      currentPage: {
        type: Number,
        default: 1
      },
      pageCount: {
        type: Number,
        required: true
      },
      pagerCount: {
        type: Number,
        default: 7
      },
      disabled: Boolean
    });
    const _hoisted_1$f = ["onKeyup"];
    const _hoisted_2$a = ["aria-current", "aria-label", "tabindex"];
    const _hoisted_3$7 = ["tabindex", "aria-label"];
    const _hoisted_4$5 = ["aria-current", "aria-label", "tabindex"];
    const _hoisted_5$5 = ["tabindex", "aria-label"];
    const _hoisted_6$2 = ["aria-current", "aria-label", "tabindex"];
    const __default__$9 = /* @__PURE__ */ defineComponent({
      name: "ElPaginationPager"
    });
    const _sfc_main$i = /* @__PURE__ */ defineComponent({
      ...__default__$9,
      props: paginationPagerProps,
      emits: ["change"],
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const nsPager = useNamespace("pager");
        const nsIcon = useNamespace("icon");
        const { t } = useLocale();
        const showPrevMore = ref(false);
        const showNextMore = ref(false);
        const quickPrevHover = ref(false);
        const quickNextHover = ref(false);
        const quickPrevFocus = ref(false);
        const quickNextFocus = ref(false);
        const pagers = computed(() => {
          const pagerCount = props.pagerCount;
          const halfPagerCount = (pagerCount - 1) / 2;
          const currentPage = Number(props.currentPage);
          const pageCount = Number(props.pageCount);
          let showPrevMore2 = false;
          let showNextMore2 = false;
          if (pageCount > pagerCount) {
            if (currentPage > pagerCount - halfPagerCount) {
              showPrevMore2 = true;
            }
            if (currentPage < pageCount - halfPagerCount) {
              showNextMore2 = true;
            }
          }
          const array = [];
          if (showPrevMore2 && !showNextMore2) {
            const startPage = pageCount - (pagerCount - 2);
            for (let i = startPage; i < pageCount; i++) {
              array.push(i);
            }
          } else if (!showPrevMore2 && showNextMore2) {
            for (let i = 2; i < pagerCount; i++) {
              array.push(i);
            }
          } else if (showPrevMore2 && showNextMore2) {
            const offset = Math.floor(pagerCount / 2) - 1;
            for (let i = currentPage - offset; i <= currentPage + offset; i++) {
              array.push(i);
            }
          } else {
            for (let i = 2; i < pageCount; i++) {
              array.push(i);
            }
          }
          return array;
        });
        const prevMoreKls = computed(() => [
          "more",
          "btn-quickprev",
          nsIcon.b(),
          nsPager.is("disabled", props.disabled)
        ]);
        const nextMoreKls = computed(() => [
          "more",
          "btn-quicknext",
          nsIcon.b(),
          nsPager.is("disabled", props.disabled)
        ]);
        const tabindex = computed(() => props.disabled ? -1 : 0);
        watchEffect(() => {
          const halfPagerCount = (props.pagerCount - 1) / 2;
          showPrevMore.value = false;
          showNextMore.value = false;
          if (props.pageCount > props.pagerCount) {
            if (props.currentPage > props.pagerCount - halfPagerCount) {
              showPrevMore.value = true;
            }
            if (props.currentPage < props.pageCount - halfPagerCount) {
              showNextMore.value = true;
            }
          }
        });
        function onMouseEnter(forward = false) {
          if (props.disabled)
            return;
          if (forward) {
            quickPrevHover.value = true;
          } else {
            quickNextHover.value = true;
          }
        }
        function onFocus(forward = false) {
          if (forward) {
            quickPrevFocus.value = true;
          } else {
            quickNextFocus.value = true;
          }
        }
        function onEnter(e) {
          const target = e.target;
          if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
            const newPage = Number(target.textContent);
            if (newPage !== props.currentPage) {
              emit2("change", newPage);
            }
          } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
            onPagerClick(e);
          }
        }
        function onPagerClick(event) {
          const target = event.target;
          if (target.tagName.toLowerCase() === "ul" || props.disabled) {
            return;
          }
          let newPage = Number(target.textContent);
          const pageCount = props.pageCount;
          const currentPage = props.currentPage;
          const pagerCountOffset = props.pagerCount - 2;
          if (target.className.includes("more")) {
            if (target.className.includes("quickprev")) {
              newPage = currentPage - pagerCountOffset;
            } else if (target.className.includes("quicknext")) {
              newPage = currentPage + pagerCountOffset;
            }
          }
          if (!Number.isNaN(+newPage)) {
            if (newPage < 1) {
              newPage = 1;
            }
            if (newPage > pageCount) {
              newPage = pageCount;
            }
          }
          if (newPage !== currentPage) {
            emit2("change", newPage);
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("ul", {
            class: normalizeClass(unref(nsPager).b()),
            onClick: onPagerClick,
            onKeyup: withKeys(onEnter, ["enter"])
          }, [
            _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
              key: 0,
              class: normalizeClass([[
                unref(nsPager).is("active", _ctx.currentPage === 1),
                unref(nsPager).is("disabled", _ctx.disabled)
              ], "number"]),
              "aria-current": _ctx.currentPage === 1,
              "aria-label": unref(t)("el.pagination.currentPage", { pager: 1 }),
              tabindex: unref(tabindex)
            }, " 1 ", 10, _hoisted_2$a)) : createCommentVNode("v-if", true),
            showPrevMore.value ? (openBlock(), createElementBlock("li", {
              key: 1,
              class: normalizeClass(unref(prevMoreKls)),
              tabindex: unref(tabindex),
              "aria-label": unref(t)("el.pagination.prevPages", { pager: _ctx.pagerCount - 2 }),
              onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
              onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
              onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
            }, [
              (quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_left_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
            ], 42, _hoisted_3$7)) : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager) => {
              return openBlock(), createElementBlock("li", {
                key: pager,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === pager),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === pager,
                "aria-label": unref(t)("el.pagination.currentPage", { pager }),
                tabindex: unref(tabindex)
              }, toDisplayString(pager), 11, _hoisted_4$5);
            }), 128)),
            showNextMore.value ? (openBlock(), createElementBlock("li", {
              key: 2,
              class: normalizeClass(unref(nextMoreKls)),
              tabindex: unref(tabindex),
              "aria-label": unref(t)("el.pagination.nextPages", { pager: _ctx.pagerCount - 2 }),
              onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
              onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
              onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
              onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
            }, [
              (quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_right_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
            ], 42, _hoisted_5$5)) : createCommentVNode("v-if", true),
            _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
              key: 3,
              class: normalizeClass([[
                unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
                unref(nsPager).is("disabled", _ctx.disabled)
              ], "number"]),
              "aria-current": _ctx.currentPage === _ctx.pageCount,
              "aria-label": unref(t)("el.pagination.currentPage", { pager: _ctx.pageCount }),
              tabindex: unref(tabindex)
            }, toDisplayString(_ctx.pageCount), 11, _hoisted_6$2)) : createCommentVNode("v-if", true)
          ], 42, _hoisted_1$f);
        };
      }
    });
    var Pager = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "pager.vue"]]);
    const isAbsent = (v2) => typeof v2 !== "number";
    const paginationProps = buildProps({
      pageSize: Number,
      defaultPageSize: Number,
      total: Number,
      pageCount: Number,
      pagerCount: {
        type: Number,
        validator: (value) => {
          return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
        },
        default: 7
      },
      currentPage: Number,
      defaultCurrentPage: Number,
      layout: {
        type: String,
        default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
      },
      pageSizes: {
        type: definePropType(Array),
        default: () => mutable([10, 20, 30, 40, 50, 100])
      },
      popperClass: {
        type: String,
        default: ""
      },
      prevText: {
        type: String,
        default: ""
      },
      prevIcon: {
        type: iconPropType,
        default: () => arrow_left_default
      },
      nextText: {
        type: String,
        default: ""
      },
      nextIcon: {
        type: iconPropType,
        default: () => arrow_right_default
      },
      teleported: {
        type: Boolean,
        default: true
      },
      small: Boolean,
      background: Boolean,
      disabled: Boolean,
      hideOnSinglePage: Boolean
    });
    const paginationEmits = {
      "update:current-page": (val) => isNumber(val),
      "update:page-size": (val) => isNumber(val),
      "size-change": (val) => isNumber(val),
      change: (currentPage, pageSize) => isNumber(currentPage) && isNumber(pageSize),
      "current-change": (val) => isNumber(val),
      "prev-click": (val) => isNumber(val),
      "next-click": (val) => isNumber(val)
    };
    const componentName = "ElPagination";
    var Pagination = /* @__PURE__ */ defineComponent({
      name: componentName,
      props: paginationProps,
      emits: paginationEmits,
      setup(props, { emit: emit2, slots }) {
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const vnodeProps = getCurrentInstance().vnode.props || {};
        const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
        const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
        const assertValidUsage = computed(() => {
          if (isAbsent(props.total) && isAbsent(props.pageCount))
            return false;
          if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
            return false;
          if (props.layout.includes("sizes")) {
            if (!isAbsent(props.pageCount)) {
              if (!hasPageSizeListener)
                return false;
            } else if (!isAbsent(props.total)) {
              if (!isAbsent(props.pageSize)) {
                if (!hasPageSizeListener) {
                  return false;
                }
              }
            }
          }
          return true;
        });
        const innerPageSize = ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
        const innerCurrentPage = ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
        const pageSizeBridge = computed({
          get() {
            return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
          },
          set(v2) {
            if (isAbsent(props.pageSize)) {
              innerPageSize.value = v2;
            }
            if (hasPageSizeListener) {
              emit2("update:page-size", v2);
              emit2("size-change", v2);
            }
          }
        });
        const pageCountBridge = computed(() => {
          let pageCount = 0;
          if (!isAbsent(props.pageCount)) {
            pageCount = props.pageCount;
          } else if (!isAbsent(props.total)) {
            pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
          }
          return pageCount;
        });
        const currentPageBridge = computed({
          get() {
            return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
          },
          set(v2) {
            let newCurrentPage = v2;
            if (v2 < 1) {
              newCurrentPage = 1;
            } else if (v2 > pageCountBridge.value) {
              newCurrentPage = pageCountBridge.value;
            }
            if (isAbsent(props.currentPage)) {
              innerCurrentPage.value = newCurrentPage;
            }
            if (hasCurrentPageListener) {
              emit2("update:current-page", newCurrentPage);
              emit2("current-change", newCurrentPage);
            }
          }
        });
        watch(pageCountBridge, (val) => {
          if (currentPageBridge.value > val)
            currentPageBridge.value = val;
        });
        watch([currentPageBridge, pageSizeBridge], (value) => {
          emit2("change", ...value);
        }, { flush: "post" });
        function handleCurrentChange(val) {
          currentPageBridge.value = val;
        }
        function handleSizeChange(val) {
          pageSizeBridge.value = val;
          const newPageCount = pageCountBridge.value;
          if (currentPageBridge.value > newPageCount) {
            currentPageBridge.value = newPageCount;
          }
        }
        function prev() {
          if (props.disabled)
            return;
          currentPageBridge.value -= 1;
          emit2("prev-click", currentPageBridge.value);
        }
        function next() {
          if (props.disabled)
            return;
          currentPageBridge.value += 1;
          emit2("next-click", currentPageBridge.value);
        }
        function addClass2(element, cls) {
          if (element) {
            if (!element.props) {
              element.props = {};
            }
            element.props.class = [element.props.class, cls].join(" ");
          }
        }
        provide(elPaginationKey, {
          pageCount: pageCountBridge,
          disabled: computed(() => props.disabled),
          currentPage: currentPageBridge,
          changeEvent: handleCurrentChange,
          handleSizeChange
        });
        return () => {
          var _a2, _b;
          if (!assertValidUsage.value) {
            debugWarn(componentName, t("el.pagination.deprecationWarning"));
            return null;
          }
          if (!props.layout)
            return null;
          if (props.hideOnSinglePage && pageCountBridge.value <= 1)
            return null;
          const rootChildren = [];
          const rightWrapperChildren = [];
          const rightWrapperRoot = h$1("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
          const TEMPLATE_MAP = {
            prev: h$1(Prev, {
              disabled: props.disabled,
              currentPage: currentPageBridge.value,
              prevText: props.prevText,
              prevIcon: props.prevIcon,
              onClick: prev
            }),
            jumper: h$1(Jumper, {
              size: props.small ? "small" : "default"
            }),
            pager: h$1(Pager, {
              currentPage: currentPageBridge.value,
              pageCount: pageCountBridge.value,
              pagerCount: props.pagerCount,
              onChange: handleCurrentChange,
              disabled: props.disabled
            }),
            next: h$1(Next, {
              disabled: props.disabled,
              currentPage: currentPageBridge.value,
              pageCount: pageCountBridge.value,
              nextText: props.nextText,
              nextIcon: props.nextIcon,
              onClick: next
            }),
            sizes: h$1(Sizes, {
              pageSize: pageSizeBridge.value,
              pageSizes: props.pageSizes,
              popperClass: props.popperClass,
              disabled: props.disabled,
              teleported: props.teleported,
              size: props.small ? "small" : "default"
            }),
            slot: (_b = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : null,
            total: h$1(Total, { total: isAbsent(props.total) ? 0 : props.total })
          };
          const components = props.layout.split(",").map((item) => item.trim());
          let haveRightWrapper = false;
          components.forEach((c2) => {
            if (c2 === "->") {
              haveRightWrapper = true;
              return;
            }
            if (!haveRightWrapper) {
              rootChildren.push(TEMPLATE_MAP[c2]);
            } else {
              rightWrapperChildren.push(TEMPLATE_MAP[c2]);
            }
          });
          addClass2(rootChildren[0], ns.is("first"));
          addClass2(rootChildren[rootChildren.length - 1], ns.is("last"));
          if (haveRightWrapper && rightWrapperChildren.length > 0) {
            addClass2(rightWrapperChildren[0], ns.is("first"));
            addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
            rootChildren.push(rightWrapperRoot);
          }
          return h$1("div", {
            class: [
              ns.b(),
              ns.is("background", props.background),
              {
                [ns.m("small")]: props.small
              }
            ]
          }, rootChildren);
        };
      }
    });
    const ElPagination = withInstall(Pagination);
    const progressProps = buildProps({
      type: {
        type: String,
        default: "line",
        values: ["line", "circle", "dashboard"]
      },
      percentage: {
        type: Number,
        default: 0,
        validator: (val) => val >= 0 && val <= 100
      },
      status: {
        type: String,
        default: "",
        values: ["", "success", "exception", "warning"]
      },
      indeterminate: {
        type: Boolean,
        default: false
      },
      duration: {
        type: Number,
        default: 3
      },
      strokeWidth: {
        type: Number,
        default: 6
      },
      strokeLinecap: {
        type: definePropType(String),
        default: "round"
      },
      textInside: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 126
      },
      showText: {
        type: Boolean,
        default: true
      },
      color: {
        type: definePropType([
          String,
          Array,
          Function
        ]),
        default: ""
      },
      striped: Boolean,
      stripedFlow: Boolean,
      format: {
        type: definePropType(Function),
        default: (percentage) => `${percentage}%`
      }
    });
    const _hoisted_1$e = ["aria-valuenow"];
    const _hoisted_2$9 = { viewBox: "0 0 100 100" };
    const _hoisted_3$6 = ["d", "stroke", "stroke-linecap", "stroke-width"];
    const _hoisted_4$4 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
    const _hoisted_5$4 = { key: 0 };
    const __default__$8 = /* @__PURE__ */ defineComponent({
      name: "ElProgress"
    });
    const _sfc_main$h = /* @__PURE__ */ defineComponent({
      ...__default__$8,
      props: progressProps,
      setup(__props) {
        const props = __props;
        const STATUS_COLOR_MAP = {
          success: "#13ce66",
          exception: "#ff4949",
          warning: "#e6a23c",
          default: "#20a0ff"
        };
        const ns = useNamespace("progress");
        const barStyle = computed(() => ({
          width: `${props.percentage}%`,
          animationDuration: `${props.duration}s`,
          backgroundColor: getCurrentColor(props.percentage)
        }));
        const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
        const radius = computed(() => {
          if (["circle", "dashboard"].includes(props.type)) {
            return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
          }
          return 0;
        });
        const trackPath = computed(() => {
          const r = radius.value;
          const isDashboard = props.type === "dashboard";
          return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
        });
        const perimeter = computed(() => 2 * Math.PI * radius.value);
        const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
        const strokeDashoffset = computed(() => {
          const offset = -1 * perimeter.value * (1 - rate.value) / 2;
          return `${offset}px`;
        });
        const trailPathStyle = computed(() => ({
          strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value
        }));
        const circlePathStyle = computed(() => ({
          strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value,
          transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
        }));
        const stroke = computed(() => {
          let ret;
          if (props.color) {
            ret = getCurrentColor(props.percentage);
          } else {
            ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
          }
          return ret;
        });
        const statusIcon = computed(() => {
          if (props.status === "warning") {
            return warning_filled_default;
          }
          if (props.type === "line") {
            return props.status === "success" ? circle_check_default : circle_close_default;
          } else {
            return props.status === "success" ? check_default : close_default;
          }
        });
        const progressTextSize = computed(() => {
          return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
        });
        const content = computed(() => props.format(props.percentage));
        function getColors(color) {
          const span = 100 / color.length;
          const seriesColors = color.map((seriesColor, index) => {
            if (isString$1(seriesColor)) {
              return {
                color: seriesColor,
                percentage: (index + 1) * span
              };
            }
            return seriesColor;
          });
          return seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
        }
        const getCurrentColor = (percentage) => {
          var _a2;
          const { color } = props;
          if (isFunction$2(color)) {
            return color(percentage);
          } else if (isString$1(color)) {
            return color;
          } else {
            const colors = getColors(color);
            for (const color2 of colors) {
              if (color2.percentage > percentage)
                return color2.color;
            }
            return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns).b(),
              unref(ns).m(_ctx.type),
              unref(ns).is(_ctx.status),
              {
                [unref(ns).m("without-text")]: !_ctx.showText,
                [unref(ns).m("text-inside")]: _ctx.textInside
              }
            ]),
            role: "progressbar",
            "aria-valuenow": _ctx.percentage,
            "aria-valuemin": "0",
            "aria-valuemax": "100"
          }, [
            _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns).b("bar"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).be("bar", "outer")),
                style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
              }, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    unref(ns).be("bar", "inner"),
                    { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                    { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                    { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                  ]),
                  style: normalizeStyle(unref(barStyle))
                }, [
                  (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns).be("bar", "innerText"))
                  }, [
                    renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                      createBaseVNode("span", null, toDisplayString(unref(content)), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true)
                ], 6)
              ], 6)
            ], 2)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns).b("circle")),
              style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
            }, [
              (openBlock(), createElementBlock("svg", _hoisted_2$9, [
                createBaseVNode("path", {
                  class: normalizeClass(unref(ns).be("circle", "track")),
                  d: unref(trackPath),
                  stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                  "stroke-linecap": _ctx.strokeLinecap,
                  "stroke-width": unref(relativeStrokeWidth),
                  fill: "none",
                  style: normalizeStyle(unref(trailPathStyle))
                }, null, 14, _hoisted_3$6),
                createBaseVNode("path", {
                  class: normalizeClass(unref(ns).be("circle", "path")),
                  d: unref(trackPath),
                  stroke: unref(stroke),
                  fill: "none",
                  opacity: _ctx.percentage ? 1 : 0,
                  "stroke-linecap": _ctx.strokeLinecap,
                  "stroke-width": unref(relativeStrokeWidth),
                  style: normalizeStyle(unref(circlePathStyle))
                }, null, 14, _hoisted_4$4)
              ]))
            ], 6)),
            (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(unref(ns).e("text")),
              style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
            }, [
              renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$4, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                  ]),
                  _: 1
                }))
              ])
            ], 6)) : createCommentVNode("v-if", true)
          ], 10, _hoisted_1$e);
        };
      }
    });
    var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "progress.vue"]]);
    const ElProgress = withInstall(Progress);
    const switchProps = buildProps({
      modelValue: {
        type: [Boolean, String, Number],
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        validator: isValidComponentSize
      },
      width: {
        type: [String, Number],
        default: ""
      },
      inlinePrompt: {
        type: Boolean,
        default: false
      },
      inactiveActionIcon: {
        type: iconPropType
      },
      activeActionIcon: {
        type: iconPropType
      },
      activeIcon: {
        type: iconPropType
      },
      inactiveIcon: {
        type: iconPropType
      },
      activeText: {
        type: String,
        default: ""
      },
      inactiveText: {
        type: String,
        default: ""
      },
      activeValue: {
        type: [Boolean, String, Number],
        default: true
      },
      inactiveValue: {
        type: [Boolean, String, Number],
        default: false
      },
      activeColor: {
        type: String,
        default: ""
      },
      inactiveColor: {
        type: String,
        default: ""
      },
      borderColor: {
        type: String,
        default: ""
      },
      name: {
        type: String,
        default: ""
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      beforeChange: {
        type: definePropType(Function)
      },
      id: String,
      tabindex: {
        type: [String, Number]
      },
      value: {
        type: [Boolean, String, Number],
        default: false
      },
      label: {
        type: String,
        default: void 0
      }
    });
    const switchEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
      [CHANGE_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
      [INPUT_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val)
    };
    const _hoisted_1$d = ["onClick"];
    const _hoisted_2$8 = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
    const _hoisted_3$5 = ["aria-hidden"];
    const _hoisted_4$3 = ["aria-hidden"];
    const _hoisted_5$3 = ["aria-hidden"];
    const COMPONENT_NAME$1 = "ElSwitch";
    const __default__$7 = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$1
    });
    const _sfc_main$g = /* @__PURE__ */ defineComponent({
      ...__default__$7,
      props: switchProps,
      emits: switchEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const vm = getCurrentInstance();
        const { formItem } = useFormItem();
        const switchSize = useFormSize();
        const ns = useNamespace("switch");
        const useBatchDeprecated = (list) => {
          list.forEach((param) => {
            useDeprecated({
              from: param[0],
              replacement: param[1],
              scope: COMPONENT_NAME$1,
              version: "2.3.0",
              ref: "https://element-plus.org/en-US/component/switch.html#attributes",
              type: "Attribute"
            }, computed(() => {
              var _a2;
              return !!((_a2 = vm.vnode.props) == null ? void 0 : _a2[param[2]]);
            }));
          });
        };
        useBatchDeprecated([
          ['"value"', '"model-value" or "v-model"', "value"],
          ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"],
          ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"],
          ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]
        ]);
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const switchDisabled = useFormDisabled(computed(() => props.loading));
        const isControlled = ref(props.modelValue !== false);
        const input = ref();
        const core = ref();
        const switchKls = computed(() => [
          ns.b(),
          ns.m(switchSize.value),
          ns.is("disabled", switchDisabled.value),
          ns.is("checked", checked.value)
        ]);
        const labelLeftKls = computed(() => [
          ns.e("label"),
          ns.em("label", "left"),
          ns.is("active", !checked.value)
        ]);
        const labelRightKls = computed(() => [
          ns.e("label"),
          ns.em("label", "right"),
          ns.is("active", checked.value)
        ]);
        const coreStyle = computed(() => ({
          width: addUnit(props.width)
        }));
        watch(() => props.modelValue, () => {
          isControlled.value = true;
        });
        watch(() => props.value, () => {
          isControlled.value = false;
        });
        const actualValue = computed(() => {
          return isControlled.value ? props.modelValue : props.value;
        });
        const checked = computed(() => actualValue.value === props.activeValue);
        if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
          emit2(UPDATE_MODEL_EVENT, props.inactiveValue);
          emit2(CHANGE_EVENT, props.inactiveValue);
          emit2(INPUT_EVENT, props.inactiveValue);
        }
        watch(checked, (val) => {
          var _a2;
          input.value.checked = val;
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
        });
        const handleChange = () => {
          const val = checked.value ? props.inactiveValue : props.activeValue;
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(CHANGE_EVENT, val);
          emit2(INPUT_EVENT, val);
          nextTick(() => {
            input.value.checked = checked.value;
          });
        };
        const switchValue = () => {
          if (switchDisabled.value)
            return;
          const { beforeChange } = props;
          if (!beforeChange) {
            handleChange();
            return;
          }
          const shouldChange = beforeChange();
          const isPromiseOrBool = [
            isPromise(shouldChange),
            isBoolean(shouldChange)
          ].includes(true);
          if (!isPromiseOrBool) {
            throwError(COMPONENT_NAME$1, "beforeChange must return type `Promise<boolean>` or `boolean`");
          }
          if (isPromise(shouldChange)) {
            shouldChange.then((result) => {
              if (result) {
                handleChange();
              }
            }).catch((e) => {
            });
          } else if (shouldChange) {
            handleChange();
          }
        };
        const styles = computed(() => {
          return ns.cssVarBlock({
            ...props.activeColor ? { "on-color": props.activeColor } : null,
            ...props.inactiveColor ? { "off-color": props.inactiveColor } : null,
            ...props.borderColor ? { "border-color": props.borderColor } : null
          });
        });
        const focus = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        };
        onMounted(() => {
          input.value.checked = checked.value;
        });
        expose({
          focus,
          checked
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(switchKls)),
            style: normalizeStyle(unref(styles)),
            onClick: withModifiers(switchValue, ["prevent"])
          }, [
            createBaseVNode("input", {
              id: unref(inputId),
              ref_key: "input",
              ref: input,
              class: normalizeClass(unref(ns).e("input")),
              type: "checkbox",
              role: "switch",
              "aria-checked": unref(checked),
              "aria-disabled": unref(switchDisabled),
              "aria-label": _ctx.label,
              name: _ctx.name,
              "true-value": _ctx.activeValue,
              "false-value": _ctx.inactiveValue,
              disabled: unref(switchDisabled),
              tabindex: _ctx.tabindex,
              onChange: handleChange,
              onKeydown: withKeys(switchValue, ["enter"])
            }, null, 42, _hoisted_2$8),
            !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(labelLeftKls))
            }, [
              _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                key: 1,
                "aria-hidden": unref(checked)
              }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$5)) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("span", {
              ref_key: "core",
              ref: core,
              class: normalizeClass(unref(ns).e("core")),
              style: normalizeStyle(unref(coreStyle))
            }, [
              _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("inner"))
              }, [
                _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).is("icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(ns).is("text")),
                  "aria-hidden": !unref(checked)
                }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_4$3)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("action"))
              }, [
                _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(loading_default))
                  ]),
                  _: 1
                }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                  _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                    ]),
                    _: 1
                  })) : createCommentVNode("v-if", true)
                ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                  _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                    ]),
                    _: 1
                  })) : createCommentVNode("v-if", true)
                ]) : createCommentVNode("v-if", true)
              ], 2)
            ], 6),
            !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(labelRightKls))
            }, [
              _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                key: 1,
                "aria-hidden": !unref(checked)
              }, toDisplayString(_ctx.activeText), 9, _hoisted_5$3)) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true)
          ], 14, _hoisted_1$d);
        };
      }
    });
    var Switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "switch.vue"]]);
    const ElSwitch = withInstall(Switch);
    const getCell = function(event) {
      var _a2;
      return (_a2 = event.target) == null ? void 0 : _a2.closest("td");
    };
    const orderBy = function(array, sortKey, reverse, sortMethod, sortBy) {
      if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
        return array;
      }
      if (typeof reverse === "string") {
        reverse = reverse === "descending" ? -1 : 1;
      } else {
        reverse = reverse && reverse < 0 ? -1 : 1;
      }
      const getKey = sortMethod ? null : function(value, index) {
        if (sortBy) {
          if (!Array.isArray(sortBy)) {
            sortBy = [sortBy];
          }
          return sortBy.map((by) => {
            if (typeof by === "string") {
              return get(value, by);
            } else {
              return by(value, index, array);
            }
          });
        }
        if (sortKey !== "$key") {
          if (isObject$1(value) && "$value" in value)
            value = value.$value;
        }
        return [isObject$1(value) ? get(value, sortKey) : value];
      };
      const compare = function(a2, b2) {
        if (sortMethod) {
          return sortMethod(a2.value, b2.value);
        }
        for (let i = 0, len = a2.key.length; i < len; i++) {
          if (a2.key[i] < b2.key[i]) {
            return -1;
          }
          if (a2.key[i] > b2.key[i]) {
            return 1;
          }
        }
        return 0;
      };
      return array.map((value, index) => {
        return {
          value,
          index,
          key: getKey ? getKey(value, index) : null
        };
      }).sort((a2, b2) => {
        let order = compare(a2, b2);
        if (!order) {
          order = a2.index - b2.index;
        }
        return order * +reverse;
      }).map((item) => item.value);
    };
    const getColumnById = function(table, columnId) {
      let column = null;
      table.columns.forEach((item) => {
        if (item.id === columnId) {
          column = item;
        }
      });
      return column;
    };
    const getColumnByKey = function(table, columnKey) {
      let column = null;
      for (let i = 0; i < table.columns.length; i++) {
        const item = table.columns[i];
        if (item.columnKey === columnKey) {
          column = item;
          break;
        }
      }
      if (!column)
        throwError("ElTable", `No column matching with column-key: ${columnKey}`);
      return column;
    };
    const getColumnByCell = function(table, cell, namespace) {
      const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
      if (matches) {
        return getColumnById(table, matches[0]);
      }
      return null;
    };
    const getRowIdentity = (row, rowKey) => {
      if (!row)
        throw new Error("Row is required when get row identity");
      if (typeof rowKey === "string") {
        if (!rowKey.includes(".")) {
          return `${row[rowKey]}`;
        }
        const key = rowKey.split(".");
        let current = row;
        for (const element of key) {
          current = current[element];
        }
        return `${current}`;
      } else if (typeof rowKey === "function") {
        return rowKey.call(null, row);
      }
    };
    const getKeysMap = function(array, rowKey) {
      const arrayMap2 = {};
      (array || []).forEach((row, index) => {
        arrayMap2[getRowIdentity(row, rowKey)] = { row, index };
      });
      return arrayMap2;
    };
    function mergeOptions(defaults, config) {
      const options = {};
      let key;
      for (key in defaults) {
        options[key] = defaults[key];
      }
      for (key in config) {
        if (hasOwn(config, key)) {
          const value = config[key];
          if (typeof value !== "undefined") {
            options[key] = value;
          }
        }
      }
      return options;
    }
    function parseWidth(width) {
      if (width === "")
        return width;
      if (width !== void 0) {
        width = Number.parseInt(width, 10);
        if (Number.isNaN(width)) {
          width = "";
        }
      }
      return width;
    }
    function parseMinWidth(minWidth) {
      if (minWidth === "")
        return minWidth;
      if (minWidth !== void 0) {
        minWidth = parseWidth(minWidth);
        if (Number.isNaN(minWidth)) {
          minWidth = 80;
        }
      }
      return minWidth;
    }
    function parseHeight(height) {
      if (typeof height === "number") {
        return height;
      }
      if (typeof height === "string") {
        if (/^\d+(?:px)?$/.test(height)) {
          return Number.parseInt(height, 10);
        } else {
          return height;
        }
      }
      return null;
    }
    function compose(...funcs) {
      if (funcs.length === 0) {
        return (arg) => arg;
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
    }
    function toggleRowStatus(statusArr, row, newVal) {
      let changed = false;
      const index = statusArr.indexOf(row);
      const included = index !== -1;
      const toggleStatus = (type) => {
        if (type === "add") {
          statusArr.push(row);
        } else {
          statusArr.splice(index, 1);
        }
        changed = true;
        if (isArray$1(row.children)) {
          row.children.forEach((item) => {
            toggleRowStatus(statusArr, item, newVal != null ? newVal : !included);
          });
        }
      };
      if (isBoolean(newVal)) {
        if (newVal && !included) {
          toggleStatus("add");
        } else if (!newVal && included) {
          toggleStatus("remove");
        }
      } else {
        included ? toggleStatus("remove") : toggleStatus("add");
      }
      return changed;
    }
    function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
      const isNil2 = (array) => !(Array.isArray(array) && array.length);
      function _walker(parent, children, level) {
        cb(parent, children, level);
        children.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, level + 1);
            return;
          }
          const children2 = item[childrenKey];
          if (!isNil2(children2)) {
            _walker(item, children2, level + 1);
          }
        });
      }
      root2.forEach((item) => {
        if (item[lazyKey]) {
          cb(item, null, 0);
          return;
        }
        const children = item[childrenKey];
        if (!isNil2(children)) {
          _walker(item, children, 0);
        }
      });
    }
    let removePopper = null;
    function createTablePopper(props, popperContent, trigger2, table) {
      if ((removePopper == null ? void 0 : removePopper.trigger) === trigger2) {
        return;
      }
      removePopper == null ? void 0 : removePopper();
      const parentNode = table == null ? void 0 : table.refs.tableWrapper;
      const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
      const popperOptions = {
        strategy: "fixed",
        ...props.popperOptions
      };
      const vm = createVNode(ElTooltip, {
        content: popperContent,
        virtualTriggering: true,
        virtualRef: trigger2,
        appendTo: parentNode,
        placement: "top",
        transition: "none",
        offset: 0,
        hideAfter: 0,
        ...props,
        popperOptions,
        onHide: () => {
          removePopper == null ? void 0 : removePopper();
        }
      });
      vm.appContext = table.appContext;
      const container = document.createElement("div");
      render(vm, container);
      vm.component.exposed.onOpen();
      const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
      removePopper = () => {
        render(null, container);
        scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
        removePopper = null;
      };
      removePopper.trigger = trigger2;
      scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
    }
    function getCurrentColumns(column) {
      if (column.children) {
        return flatMap(column.children, getCurrentColumns);
      } else {
        return [column];
      }
    }
    function getColSpan(colSpan, column) {
      return colSpan + column.colSpan;
    }
    const isFixedColumn = (index, fixed, store, realColumns) => {
      let start = 0;
      let after = index;
      const columns = store.states.columns.value;
      if (realColumns) {
        const curColumns = getCurrentColumns(realColumns[index]);
        const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));
        start = preColumns.reduce(getColSpan, 0);
        after = start + curColumns.reduce(getColSpan, 0) - 1;
      } else {
        start = index;
      }
      let fixedLayout;
      switch (fixed) {
        case "left":
          if (after < store.states.fixedLeafColumnsLength.value) {
            fixedLayout = "left";
          }
          break;
        case "right":
          if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
            fixedLayout = "right";
          }
          break;
        default:
          if (after < store.states.fixedLeafColumnsLength.value) {
            fixedLayout = "left";
          } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
            fixedLayout = "right";
          }
      }
      return fixedLayout ? {
        direction: fixedLayout,
        start,
        after
      } : {};
    };
    const getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {
      const classes = [];
      const { direction, start, after } = isFixedColumn(index, fixed, store, realColumns);
      if (direction) {
        const isLeft = direction === "left";
        classes.push(`${namespace}-fixed-column--${direction}`);
        if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {
          classes.push("is-last-column");
        } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
          classes.push("is-first-column");
        }
      }
      return classes;
    };
    function getOffset(offset, column) {
      return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
    }
    const getFixedColumnOffset = (index, fixed, store, realColumns) => {
      const {
        direction,
        start = 0,
        after = 0
      } = isFixedColumn(index, fixed, store, realColumns);
      if (!direction) {
        return;
      }
      const styles = {};
      const isLeft = direction === "left";
      const columns = store.states.columns.value;
      if (isLeft) {
        styles.left = columns.slice(0, start).reduce(getOffset, 0);
      } else {
        styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);
      }
      return styles;
    };
    const ensurePosition = (style, key) => {
      if (!style)
        return;
      if (!Number.isNaN(style[key])) {
        style[key] = `${style[key]}px`;
      }
    };
    function useExpand(watcherData) {
      const instance = getCurrentInstance();
      const defaultExpandAll = ref(false);
      const expandRows = ref([]);
      const updateExpandRows = () => {
        const data = watcherData.data.value || [];
        const rowKey = watcherData.rowKey.value;
        if (defaultExpandAll.value) {
          expandRows.value = data.slice();
        } else if (rowKey) {
          const expandRowsMap = getKeysMap(expandRows.value, rowKey);
          expandRows.value = data.reduce((prev, row) => {
            const rowId = getRowIdentity(row, rowKey);
            const rowInfo = expandRowsMap[rowId];
            if (rowInfo) {
              prev.push(row);
            }
            return prev;
          }, []);
        } else {
          expandRows.value = [];
        }
      };
      const toggleRowExpansion = (row, expanded) => {
        const changed = toggleRowStatus(expandRows.value, row, expanded);
        if (changed) {
          instance.emit("expand-change", row, expandRows.value.slice());
        }
      };
      const setExpandRowKeys = (rowKeys) => {
        instance.store.assertRowKey();
        const data = watcherData.data.value || [];
        const rowKey = watcherData.rowKey.value;
        const keysMap = getKeysMap(data, rowKey);
        expandRows.value = rowKeys.reduce((prev, cur) => {
          const info = keysMap[cur];
          if (info) {
            prev.push(info.row);
          }
          return prev;
        }, []);
      };
      const isRowExpanded = (row) => {
        const rowKey = watcherData.rowKey.value;
        if (rowKey) {
          const expandMap = getKeysMap(expandRows.value, rowKey);
          return !!expandMap[getRowIdentity(row, rowKey)];
        }
        return expandRows.value.includes(row);
      };
      return {
        updateExpandRows,
        toggleRowExpansion,
        setExpandRowKeys,
        isRowExpanded,
        states: {
          expandRows,
          defaultExpandAll
        }
      };
    }
    function useCurrent(watcherData) {
      const instance = getCurrentInstance();
      const _currentRowKey = ref(null);
      const currentRow = ref(null);
      const setCurrentRowKey = (key) => {
        instance.store.assertRowKey();
        _currentRowKey.value = key;
        setCurrentRowByKey(key);
      };
      const restoreCurrentRowKey = () => {
        _currentRowKey.value = null;
      };
      const setCurrentRowByKey = (key) => {
        const { data, rowKey } = watcherData;
        let _currentRow = null;
        if (rowKey.value) {
          _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key);
        }
        currentRow.value = _currentRow;
        instance.emit("current-change", currentRow.value, null);
      };
      const updateCurrentRow = (_currentRow) => {
        const oldCurrentRow = currentRow.value;
        if (_currentRow && _currentRow !== oldCurrentRow) {
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, oldCurrentRow);
          return;
        }
        if (!_currentRow && oldCurrentRow) {
          currentRow.value = null;
          instance.emit("current-change", null, oldCurrentRow);
        }
      };
      const updateCurrentRowData = () => {
        const rowKey = watcherData.rowKey.value;
        const data = watcherData.data.value || [];
        const oldCurrentRow = currentRow.value;
        if (!data.includes(oldCurrentRow) && oldCurrentRow) {
          if (rowKey) {
            const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
            setCurrentRowByKey(currentRowKey);
          } else {
            currentRow.value = null;
          }
          if (currentRow.value === null) {
            instance.emit("current-change", null, oldCurrentRow);
          }
        } else if (_currentRowKey.value) {
          setCurrentRowByKey(_currentRowKey.value);
          restoreCurrentRowKey();
        }
      };
      return {
        setCurrentRowKey,
        restoreCurrentRowKey,
        setCurrentRowByKey,
        updateCurrentRow,
        updateCurrentRowData,
        states: {
          _currentRowKey,
          currentRow
        }
      };
    }
    function useTree(watcherData) {
      const expandRowKeys = ref([]);
      const treeData = ref({});
      const indent = ref(16);
      const lazy = ref(false);
      const lazyTreeNodeMap = ref({});
      const lazyColumnIdentifier = ref("hasChildren");
      const childrenColumnName = ref("children");
      const instance = getCurrentInstance();
      const normalizedData = computed(() => {
        if (!watcherData.rowKey.value)
          return {};
        const data = watcherData.data.value || [];
        return normalize(data);
      });
      const normalizedLazyNode = computed(() => {
        const rowKey = watcherData.rowKey.value;
        const keys2 = Object.keys(lazyTreeNodeMap.value);
        const res = {};
        if (!keys2.length)
          return res;
        keys2.forEach((key) => {
          if (lazyTreeNodeMap.value[key].length) {
            const item = { children: [] };
            lazyTreeNodeMap.value[key].forEach((row) => {
              const currentRowKey = getRowIdentity(row, rowKey);
              item.children.push(currentRowKey);
              if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                res[currentRowKey] = { children: [] };
              }
            });
            res[key] = item;
          }
        });
        return res;
      });
      const normalize = (data) => {
        const rowKey = watcherData.rowKey.value;
        const res = {};
        walkTreeNode(data, (parent, children, level) => {
          const parentId = getRowIdentity(parent, rowKey);
          if (Array.isArray(children)) {
            res[parentId] = {
              children: children.map((row) => getRowIdentity(row, rowKey)),
              level
            };
          } else if (lazy.value) {
            res[parentId] = {
              children: [],
              lazy: true,
              level
            };
          }
        }, childrenColumnName.value, lazyColumnIdentifier.value);
        return res;
      };
      const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
        var _a2;
        const nested = normalizedData.value;
        const normalizedLazyNode_ = normalizedLazyNode.value;
        const keys2 = Object.keys(nested);
        const newTreeData = {};
        if (keys2.length) {
          const oldTreeData = unref(treeData);
          const rootLazyRowKeys = [];
          const getExpanded = (oldValue, key) => {
            if (ifChangeExpandRowKeys) {
              if (expandRowKeys.value) {
                return ifExpandAll || expandRowKeys.value.includes(key);
              } else {
                return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
              }
            } else {
              const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
              return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
            }
          };
          keys2.forEach((key) => {
            const oldValue = oldTreeData[key];
            const newValue = { ...nested[key] };
            newValue.expanded = getExpanded(oldValue, key);
            if (newValue.lazy) {
              const { loaded = false, loading = false } = oldValue || {};
              newValue.loaded = !!loaded;
              newValue.loading = !!loading;
              rootLazyRowKeys.push(key);
            }
            newTreeData[key] = newValue;
          });
          const lazyKeys = Object.keys(normalizedLazyNode_);
          if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
            lazyKeys.forEach((key) => {
              const oldValue = oldTreeData[key];
              const lazyNodeChildren = normalizedLazyNode_[key].children;
              if (rootLazyRowKeys.includes(key)) {
                if (newTreeData[key].children.length !== 0) {
                  throw new Error("[ElTable]children must be an empty array.");
                }
                newTreeData[key].children = lazyNodeChildren;
              } else {
                const { loaded = false, loading = false } = oldValue || {};
                newTreeData[key] = {
                  lazy: true,
                  loaded: !!loaded,
                  loading: !!loading,
                  expanded: getExpanded(oldValue, key),
                  children: lazyNodeChildren,
                  level: ""
                };
              }
            });
          }
        }
        treeData.value = newTreeData;
        (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
      };
      watch(() => expandRowKeys.value, () => {
        updateTreeData(true);
      });
      watch(() => normalizedData.value, () => {
        updateTreeData();
      });
      watch(() => normalizedLazyNode.value, () => {
        updateTreeData();
      });
      const updateTreeExpandKeys = (value) => {
        expandRowKeys.value = value;
        updateTreeData();
      };
      const toggleTreeExpansion = (row, expanded) => {
        instance.store.assertRowKey();
        const rowKey = watcherData.rowKey.value;
        const id = getRowIdentity(row, rowKey);
        const data = id && treeData.value[id];
        if (id && data && "expanded" in data) {
          const oldExpanded = data.expanded;
          expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
          treeData.value[id].expanded = expanded;
          if (oldExpanded !== expanded) {
            instance.emit("expand-change", row, expanded);
          }
          instance.store.updateTableScrollY();
        }
      };
      const loadOrToggle = (row) => {
        instance.store.assertRowKey();
        const rowKey = watcherData.rowKey.value;
        const id = getRowIdentity(row, rowKey);
        const data = treeData.value[id];
        if (lazy.value && data && "loaded" in data && !data.loaded) {
          loadData(row, id, data);
        } else {
          toggleTreeExpansion(row, void 0);
        }
      };
      const loadData = (row, key, treeNode) => {
        const { load } = instance.props;
        if (load && !treeData.value[key].loaded) {
          treeData.value[key].loading = true;
          load(row, treeNode, (data) => {
            if (!Array.isArray(data)) {
              throw new TypeError("[ElTable] data must be an array");
            }
            treeData.value[key].loading = false;
            treeData.value[key].loaded = true;
            treeData.value[key].expanded = true;
            if (data.length) {
              lazyTreeNodeMap.value[key] = data;
            }
            instance.emit("expand-change", row, true);
          });
        }
      };
      return {
        loadData,
        loadOrToggle,
        toggleTreeExpansion,
        updateTreeExpandKeys,
        updateTreeData,
        normalize,
        states: {
          expandRowKeys,
          treeData,
          indent,
          lazy,
          lazyTreeNodeMap,
          lazyColumnIdentifier,
          childrenColumnName
        }
      };
    }
    const sortData = (data, states) => {
      const sortingColumn = states.sortingColumn;
      if (!sortingColumn || typeof sortingColumn.sortable === "string") {
        return data;
      }
      return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
    };
    const doFlattenColumns = (columns) => {
      const result = [];
      columns.forEach((column) => {
        if (column.children && column.children.length > 0) {
          result.push.apply(result, doFlattenColumns(column.children));
        } else {
          result.push(column);
        }
      });
      return result;
    };
    function useWatcher$1() {
      var _a2;
      const instance = getCurrentInstance();
      const { size: tableSize } = toRefs((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
      const rowKey = ref(null);
      const data = ref([]);
      const _data = ref([]);
      const isComplex = ref(false);
      const _columns = ref([]);
      const originColumns = ref([]);
      const columns = ref([]);
      const fixedColumns = ref([]);
      const rightFixedColumns = ref([]);
      const leafColumns = ref([]);
      const fixedLeafColumns = ref([]);
      const rightFixedLeafColumns = ref([]);
      const updateOrderFns = [];
      const leafColumnsLength = ref(0);
      const fixedLeafColumnsLength = ref(0);
      const rightFixedLeafColumnsLength = ref(0);
      const isAllSelected = ref(false);
      const selection = ref([]);
      const reserveSelection = ref(false);
      const selectOnIndeterminate = ref(false);
      const selectable = ref(null);
      const filters = ref({});
      const filteredData = ref(null);
      const sortingColumn = ref(null);
      const sortProp = ref(null);
      const sortOrder = ref(null);
      const hoverRow = ref(null);
      watch(data, () => instance.state && scheduleLayout(false), {
        deep: true
      });
      const assertRowKey = () => {
        if (!rowKey.value)
          throw new Error("[ElTable] prop row-key is required");
      };
      const updateChildFixed = (column) => {
        var _a22;
        (_a22 = column.children) == null ? void 0 : _a22.forEach((childColumn) => {
          childColumn.fixed = column.fixed;
          updateChildFixed(childColumn);
        });
      };
      const updateColumns = () => {
        _columns.value.forEach((column) => {
          updateChildFixed(column);
        });
        fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
        rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
        if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
          _columns.value[0].fixed = true;
          fixedColumns.value.unshift(_columns.value[0]);
        }
        const notFixedColumns = _columns.value.filter((column) => !column.fixed);
        originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
        const leafColumns2 = doFlattenColumns(notFixedColumns);
        const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
        const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
        leafColumnsLength.value = leafColumns2.length;
        fixedLeafColumnsLength.value = fixedLeafColumns2.length;
        rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
        columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
        isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
      };
      const scheduleLayout = (needUpdateColumns, immediate = false) => {
        if (needUpdateColumns) {
          updateColumns();
        }
        if (immediate) {
          instance.state.doLayout();
        } else {
          instance.state.debouncedUpdateLayout();
        }
      };
      const isSelected = (row) => {
        return selection.value.includes(row);
      };
      const clearSelection = () => {
        isAllSelected.value = false;
        const oldSelection = selection.value;
        if (oldSelection.length) {
          selection.value = [];
          instance.emit("selection-change", []);
        }
      };
      const cleanSelection = () => {
        let deleted;
        if (rowKey.value) {
          deleted = [];
          const selectedMap = getKeysMap(selection.value, rowKey.value);
          const dataMap = getKeysMap(data.value, rowKey.value);
          for (const key in selectedMap) {
            if (hasOwn(selectedMap, key) && !dataMap[key]) {
              deleted.push(selectedMap[key].row);
            }
          }
        } else {
          deleted = selection.value.filter((item) => !data.value.includes(item));
        }
        if (deleted.length) {
          const newSelection = selection.value.filter((item) => !deleted.includes(item));
          selection.value = newSelection;
          instance.emit("selection-change", newSelection.slice());
        }
      };
      const getSelectionRows = () => {
        return (selection.value || []).slice();
      };
      const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
        const changed = toggleRowStatus(selection.value, row, selected);
        if (changed) {
          const newSelection = (selection.value || []).slice();
          if (emitChange) {
            instance.emit("select", newSelection, row);
          }
          instance.emit("selection-change", newSelection);
        }
      };
      const _toggleAllSelection = () => {
        var _a22, _b;
        const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
        isAllSelected.value = value;
        let selectionChanged = false;
        let childrenCount = 0;
        const rowKey2 = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.rowKey.value;
        data.value.forEach((row, index) => {
          const rowIndex = index + childrenCount;
          if (selectable.value) {
            if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
              selectionChanged = true;
            }
          } else {
            if (toggleRowStatus(selection.value, row, value)) {
              selectionChanged = true;
            }
          }
          childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
        });
        if (selectionChanged) {
          instance.emit("selection-change", selection.value ? selection.value.slice() : []);
        }
        instance.emit("select-all", selection.value);
      };
      const updateSelectionByRowKey = () => {
        const selectedMap = getKeysMap(selection.value, rowKey.value);
        data.value.forEach((row) => {
          const rowId = getRowIdentity(row, rowKey.value);
          const rowInfo = selectedMap[rowId];
          if (rowInfo) {
            selection.value[rowInfo.index] = row;
          }
        });
      };
      const updateAllSelected = () => {
        var _a22, _b, _c;
        if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
          isAllSelected.value = false;
          return;
        }
        let selectedMap;
        if (rowKey.value) {
          selectedMap = getKeysMap(selection.value, rowKey.value);
        }
        const isSelected2 = function(row) {
          if (selectedMap) {
            return !!selectedMap[getRowIdentity(row, rowKey.value)];
          } else {
            return selection.value.includes(row);
          }
        };
        let isAllSelected_ = true;
        let selectedCount = 0;
        let childrenCount = 0;
        for (let i = 0, j = (data.value || []).length; i < j; i++) {
          const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
          const rowIndex = i + childrenCount;
          const item = data.value[i];
          const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
          if (!isSelected2(item)) {
            if (!selectable.value || isRowSelectable) {
              isAllSelected_ = false;
              break;
            }
          } else {
            selectedCount++;
          }
          childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
        }
        if (selectedCount === 0)
          isAllSelected_ = false;
        isAllSelected.value = isAllSelected_;
      };
      const getChildrenCount = (rowKey2) => {
        var _a22;
        if (!instance || !instance.store)
          return 0;
        const { treeData } = instance.store.states;
        let count = 0;
        const children = (_a22 = treeData.value[rowKey2]) == null ? void 0 : _a22.children;
        if (children) {
          count += children.length;
          children.forEach((childKey) => {
            count += getChildrenCount(childKey);
          });
        }
        return count;
      };
      const updateFilters = (columns2, values) => {
        if (!Array.isArray(columns2)) {
          columns2 = [columns2];
        }
        const filters_ = {};
        columns2.forEach((col) => {
          filters.value[col.id] = values;
          filters_[col.columnKey || col.id] = values;
        });
        return filters_;
      };
      const updateSort = (column, prop, order) => {
        if (sortingColumn.value && sortingColumn.value !== column) {
          sortingColumn.value.order = null;
        }
        sortingColumn.value = column;
        sortProp.value = prop;
        sortOrder.value = order;
      };
      const execFilter = () => {
        let sourceData = unref(_data);
        Object.keys(filters.value).forEach((columnId) => {
          const values = filters.value[columnId];
          if (!values || values.length === 0)
            return;
          const column = getColumnById({
            columns: columns.value
          }, columnId);
          if (column && column.filterMethod) {
            sourceData = sourceData.filter((row) => {
              return values.some((value) => column.filterMethod.call(null, value, row, column));
            });
          }
        });
        filteredData.value = sourceData;
      };
      const execSort = () => {
        data.value = sortData(filteredData.value, {
          sortingColumn: sortingColumn.value,
          sortProp: sortProp.value,
          sortOrder: sortOrder.value
        });
      };
      const execQuery = (ignore = void 0) => {
        if (!(ignore && ignore.filter)) {
          execFilter();
        }
        execSort();
      };
      const clearFilter = (columnKeys) => {
        const { tableHeaderRef } = instance.refs;
        if (!tableHeaderRef)
          return;
        const panels = Object.assign({}, tableHeaderRef.filterPanels);
        const keys2 = Object.keys(panels);
        if (!keys2.length)
          return;
        if (typeof columnKeys === "string") {
          columnKeys = [columnKeys];
        }
        if (Array.isArray(columnKeys)) {
          const columns_ = columnKeys.map((key) => getColumnByKey({
            columns: columns.value
          }, key));
          keys2.forEach((key) => {
            const column = columns_.find((col) => col.id === key);
            if (column) {
              column.filteredValue = [];
            }
          });
          instance.store.commit("filterChange", {
            column: columns_,
            values: [],
            silent: true,
            multi: true
          });
        } else {
          keys2.forEach((key) => {
            const column = columns.value.find((col) => col.id === key);
            if (column) {
              column.filteredValue = [];
            }
          });
          filters.value = {};
          instance.store.commit("filterChange", {
            column: {},
            values: [],
            silent: true
          });
        }
      };
      const clearSort = () => {
        if (!sortingColumn.value)
          return;
        updateSort(null, null, null);
        instance.store.commit("changeSortCondition", {
          silent: true
        });
      };
      const {
        setExpandRowKeys,
        toggleRowExpansion,
        updateExpandRows,
        states: expandStates,
        isRowExpanded
      } = useExpand({
        data,
        rowKey
      });
      const {
        updateTreeExpandKeys,
        toggleTreeExpansion,
        updateTreeData,
        loadOrToggle,
        states: treeStates
      } = useTree({
        data,
        rowKey
      });
      const {
        updateCurrentRowData,
        updateCurrentRow,
        setCurrentRowKey,
        states: currentData
      } = useCurrent({
        data,
        rowKey
      });
      const setExpandRowKeysAdapter = (val) => {
        setExpandRowKeys(val);
        updateTreeExpandKeys(val);
      };
      const toggleRowExpansionAdapter = (row, expanded) => {
        const hasExpandColumn = columns.value.some(({ type }) => type === "expand");
        if (hasExpandColumn) {
          toggleRowExpansion(row, expanded);
        } else {
          toggleTreeExpansion(row, expanded);
        }
      };
      return {
        assertRowKey,
        updateColumns,
        scheduleLayout,
        isSelected,
        clearSelection,
        cleanSelection,
        getSelectionRows,
        toggleRowSelection,
        _toggleAllSelection,
        toggleAllSelection: null,
        updateSelectionByRowKey,
        updateAllSelected,
        updateFilters,
        updateCurrentRow,
        updateSort,
        execFilter,
        execSort,
        execQuery,
        clearFilter,
        clearSort,
        toggleRowExpansion,
        setExpandRowKeysAdapter,
        setCurrentRowKey,
        toggleRowExpansionAdapter,
        isRowExpanded,
        updateExpandRows,
        updateCurrentRowData,
        loadOrToggle,
        updateTreeData,
        states: {
          tableSize,
          rowKey,
          data,
          _data,
          isComplex,
          _columns,
          originColumns,
          columns,
          fixedColumns,
          rightFixedColumns,
          leafColumns,
          fixedLeafColumns,
          rightFixedLeafColumns,
          updateOrderFns,
          leafColumnsLength,
          fixedLeafColumnsLength,
          rightFixedLeafColumnsLength,
          isAllSelected,
          selection,
          reserveSelection,
          selectOnIndeterminate,
          selectable,
          filters,
          filteredData,
          sortingColumn,
          sortProp,
          sortOrder,
          hoverRow,
          ...expandStates,
          ...treeStates,
          ...currentData
        }
      };
    }
    function replaceColumn(array, column) {
      return array.map((item) => {
        var _a2;
        if (item.id === column.id) {
          return column;
        } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
          item.children = replaceColumn(item.children, column);
        }
        return item;
      });
    }
    function sortColumn(array) {
      array.forEach((item) => {
        var _a2, _b;
        item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
        if ((_b = item.children) == null ? void 0 : _b.length) {
          sortColumn(item.children);
        }
      });
      array.sort((cur, pre) => cur.no - pre.no);
    }
    function useStore() {
      const instance = getCurrentInstance();
      const watcher = useWatcher$1();
      const ns = useNamespace("table");
      const mutations = {
        setData(states, data) {
          const dataInstanceChanged = unref(states._data) !== data;
          states.data.value = data;
          states._data.value = data;
          instance.store.execQuery();
          instance.store.updateCurrentRowData();
          instance.store.updateExpandRows();
          instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
          if (unref(states.reserveSelection)) {
            instance.store.assertRowKey();
            instance.store.updateSelectionByRowKey();
          } else {
            if (dataInstanceChanged) {
              instance.store.clearSelection();
            } else {
              instance.store.cleanSelection();
            }
          }
          instance.store.updateAllSelected();
          if (instance.$ready) {
            instance.store.scheduleLayout();
          }
        },
        insertColumn(states, column, parent, updateColumnOrder) {
          const array = unref(states._columns);
          let newColumns = [];
          if (!parent) {
            array.push(column);
            newColumns = array;
          } else {
            if (parent && !parent.children) {
              parent.children = [];
            }
            parent.children.push(column);
            newColumns = replaceColumn(array, parent);
          }
          sortColumn(newColumns);
          states._columns.value = newColumns;
          states.updateOrderFns.push(updateColumnOrder);
          if (column.type === "selection") {
            states.selectable.value = column.selectable;
            states.reserveSelection.value = column.reserveSelection;
          }
          if (instance.$ready) {
            instance.store.updateColumns();
            instance.store.scheduleLayout();
          }
        },
        updateColumnOrder(states, column) {
          var _a2;
          const newColumnIndex = (_a2 = column.getColumnIndex) == null ? void 0 : _a2.call(column);
          if (newColumnIndex === column.no)
            return;
          sortColumn(states._columns.value);
          if (instance.$ready) {
            instance.store.updateColumns();
          }
        },
        removeColumn(states, column, parent, updateColumnOrder) {
          const array = unref(states._columns) || [];
          if (parent) {
            parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
            nextTick(() => {
              var _a2;
              if (((_a2 = parent.children) == null ? void 0 : _a2.length) === 0) {
                delete parent.children;
              }
            });
            states._columns.value = replaceColumn(array, parent);
          } else {
            const index = array.indexOf(column);
            if (index > -1) {
              array.splice(index, 1);
              states._columns.value = array;
            }
          }
          const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
          updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
          if (instance.$ready) {
            instance.store.updateColumns();
            instance.store.scheduleLayout();
          }
        },
        sort(states, options) {
          const { prop, order, init } = options;
          if (prop) {
            const column = unref(states.columns).find((column2) => column2.property === prop);
            if (column) {
              column.order = order;
              instance.store.updateSort(column, prop, order);
              instance.store.commit("changeSortCondition", { init });
            }
          }
        },
        changeSortCondition(states, options) {
          const { sortingColumn, sortProp, sortOrder } = states;
          const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
          if (orderValue === null) {
            states.sortingColumn.value = null;
            states.sortProp.value = null;
          }
          const ignore = { filter: true };
          instance.store.execQuery(ignore);
          if (!options || !(options.silent || options.init)) {
            instance.emit("sort-change", {
              column: columnValue,
              prop: propValue,
              order: orderValue
            });
          }
          instance.store.updateTableScrollY();
        },
        filterChange(_states, options) {
          const { column, values, silent } = options;
          const newFilters = instance.store.updateFilters(column, values);
          instance.store.execQuery();
          if (!silent) {
            instance.emit("filter-change", newFilters);
          }
          instance.store.updateTableScrollY();
        },
        toggleAllSelection() {
          instance.store.toggleAllSelection();
        },
        rowSelectedChanged(_states, row) {
          instance.store.toggleRowSelection(row);
          instance.store.updateAllSelected();
        },
        setHoverRow(states, row) {
          states.hoverRow.value = row;
        },
        setCurrentRow(_states, row) {
          instance.store.updateCurrentRow(row);
        }
      };
      const commit = function(name, ...args) {
        const mutations2 = instance.store.mutations;
        if (mutations2[name]) {
          mutations2[name].apply(instance, [instance.store.states].concat(args));
        } else {
          throw new Error(`Action not found: ${name}`);
        }
      };
      const updateTableScrollY = function() {
        nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
      };
      return {
        ns,
        ...watcher,
        mutations,
        commit,
        updateTableScrollY
      };
    }
    const InitialStateMap = {
      rowKey: "rowKey",
      defaultExpandAll: "defaultExpandAll",
      selectOnIndeterminate: "selectOnIndeterminate",
      indent: "indent",
      lazy: "lazy",
      data: "data",
      ["treeProps.hasChildren"]: {
        key: "lazyColumnIdentifier",
        default: "hasChildren"
      },
      ["treeProps.children"]: {
        key: "childrenColumnName",
        default: "children"
      }
    };
    function createStore(table, props) {
      if (!table) {
        throw new Error("Table is required.");
      }
      const store = useStore();
      store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
      Object.keys(InitialStateMap).forEach((key) => {
        handleValue(getArrKeysValue(props, key), key, store);
      });
      proxyTableProps(store, props);
      return store;
    }
    function proxyTableProps(store, props) {
      Object.keys(InitialStateMap).forEach((key) => {
        watch(() => getArrKeysValue(props, key), (value) => {
          handleValue(value, key, store);
        });
      });
    }
    function handleValue(value, propsKey, store) {
      let newVal = value;
      let storeKey = InitialStateMap[propsKey];
      if (typeof InitialStateMap[propsKey] === "object") {
        storeKey = storeKey.key;
        newVal = newVal || InitialStateMap[propsKey].default;
      }
      store.states[storeKey].value = newVal;
    }
    function getArrKeysValue(props, keys2) {
      if (keys2.includes(".")) {
        const keyList = keys2.split(".");
        let value = props;
        keyList.forEach((key) => {
          value = value[key];
        });
        return value;
      } else {
        return props[keys2];
      }
    }
    class TableLayout {
      constructor(options) {
        this.observers = [];
        this.table = null;
        this.store = null;
        this.columns = [];
        this.fit = true;
        this.showHeader = true;
        this.height = ref(null);
        this.scrollX = ref(false);
        this.scrollY = ref(false);
        this.bodyWidth = ref(null);
        this.fixedWidth = ref(null);
        this.rightFixedWidth = ref(null);
        this.gutterWidth = 0;
        for (const name in options) {
          if (hasOwn(options, name)) {
            if (isRef(this[name])) {
              this[name].value = options[name];
            } else {
              this[name] = options[name];
            }
          }
        }
        if (!this.table) {
          throw new Error("Table is required for Table Layout");
        }
        if (!this.store) {
          throw new Error("Store is required for Table Layout");
        }
      }
      updateScrollY() {
        const height = this.height.value;
        if (height === null)
          return false;
        const scrollBarRef = this.table.refs.scrollBarRef;
        if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
          let scrollY = true;
          const prevScrollY = this.scrollY.value;
          scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
          this.scrollY.value = scrollY;
          return prevScrollY !== scrollY;
        }
        return false;
      }
      setHeight(value, prop = "height") {
        if (!isClient)
          return;
        const el = this.table.vnode.el;
        value = parseHeight(value);
        this.height.value = Number(value);
        if (!el && (value || value === 0))
          return nextTick(() => this.setHeight(value, prop));
        if (typeof value === "number") {
          el.style[prop] = `${value}px`;
          this.updateElsHeight();
        } else if (typeof value === "string") {
          el.style[prop] = value;
          this.updateElsHeight();
        }
      }
      setMaxHeight(value) {
        this.setHeight(value, "max-height");
      }
      getFlattenColumns() {
        const flattenColumns = [];
        const columns = this.table.store.states.columns.value;
        columns.forEach((column) => {
          if (column.isColumnGroup) {
            flattenColumns.push.apply(flattenColumns, column.columns);
          } else {
            flattenColumns.push(column);
          }
        });
        return flattenColumns;
      }
      updateElsHeight() {
        this.updateScrollY();
        this.notifyObservers("scrollable");
      }
      headerDisplayNone(elm) {
        if (!elm)
          return true;
        let headerChild = elm;
        while (headerChild.tagName !== "DIV") {
          if (getComputedStyle(headerChild).display === "none") {
            return true;
          }
          headerChild = headerChild.parentElement;
        }
        return false;
      }
      updateColumnsWidth() {
        if (!isClient)
          return;
        const fit = this.fit;
        const bodyWidth = this.table.vnode.el.clientWidth;
        let bodyMinWidth = 0;
        const flattenColumns = this.getFlattenColumns();
        const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
        flattenColumns.forEach((column) => {
          if (typeof column.width === "number" && column.realWidth)
            column.realWidth = null;
        });
        if (flexColumns.length > 0 && fit) {
          flattenColumns.forEach((column) => {
            bodyMinWidth += Number(column.width || column.minWidth || 80);
          });
          if (bodyMinWidth <= bodyWidth) {
            this.scrollX.value = false;
            const totalFlexWidth = bodyWidth - bodyMinWidth;
            if (flexColumns.length === 1) {
              flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
            } else {
              const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
              const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
              let noneFirstWidth = 0;
              flexColumns.forEach((column, index) => {
                if (index === 0)
                  return;
                const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                noneFirstWidth += flexWidth;
                column.realWidth = Number(column.minWidth || 80) + flexWidth;
              });
              flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
            }
          } else {
            this.scrollX.value = true;
            flexColumns.forEach((column) => {
              column.realWidth = Number(column.minWidth);
            });
          }
          this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
          this.table.state.resizeState.value.width = this.bodyWidth.value;
        } else {
          flattenColumns.forEach((column) => {
            if (!column.width && !column.minWidth) {
              column.realWidth = 80;
            } else {
              column.realWidth = Number(column.width || column.minWidth);
            }
            bodyMinWidth += column.realWidth;
          });
          this.scrollX.value = bodyMinWidth > bodyWidth;
          this.bodyWidth.value = bodyMinWidth;
        }
        const fixedColumns = this.store.states.fixedColumns.value;
        if (fixedColumns.length > 0) {
          let fixedWidth = 0;
          fixedColumns.forEach((column) => {
            fixedWidth += Number(column.realWidth || column.width);
          });
          this.fixedWidth.value = fixedWidth;
        }
        const rightFixedColumns = this.store.states.rightFixedColumns.value;
        if (rightFixedColumns.length > 0) {
          let rightFixedWidth = 0;
          rightFixedColumns.forEach((column) => {
            rightFixedWidth += Number(column.realWidth || column.width);
          });
          this.rightFixedWidth.value = rightFixedWidth;
        }
        this.notifyObservers("columns");
      }
      addObserver(observer) {
        this.observers.push(observer);
      }
      removeObserver(observer) {
        const index = this.observers.indexOf(observer);
        if (index !== -1) {
          this.observers.splice(index, 1);
        }
      }
      notifyObservers(event) {
        const observers = this.observers;
        observers.forEach((observer) => {
          var _a2, _b;
          switch (event) {
            case "columns":
              (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
              break;
            case "scrollable":
              (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
              break;
            default:
              throw new Error(`Table Layout don't have event ${event}.`);
          }
        });
      }
    }
    const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
    const _sfc_main$f = /* @__PURE__ */ defineComponent({
      name: "ElTableFilterPanel",
      components: {
        ElCheckbox,
        ElCheckboxGroup,
        ElScrollbar,
        ElTooltip,
        ElIcon,
        ArrowDown: arrow_down_default,
        ArrowUp: arrow_up_default
      },
      directives: { ClickOutside },
      props: {
        placement: {
          type: String,
          default: "bottom-start"
        },
        store: {
          type: Object
        },
        column: {
          type: Object
        },
        upDataColumn: {
          type: Function
        }
      },
      setup(props) {
        const instance = getCurrentInstance();
        const { t } = useLocale();
        const ns = useNamespace("table-filter");
        const parent = instance == null ? void 0 : instance.parent;
        if (!parent.filterPanels.value[props.column.id]) {
          parent.filterPanels.value[props.column.id] = instance;
        }
        const tooltipVisible = ref(false);
        const tooltip = ref(null);
        const filters = computed(() => {
          return props.column && props.column.filters;
        });
        const filterClassName = computed(() => {
          if (props.column.filterClassName) {
            return `${ns.b()} ${props.column.filterClassName}`;
          }
          return ns.b();
        });
        const filterValue = computed({
          get: () => {
            var _a2;
            return (((_a2 = props.column) == null ? void 0 : _a2.filteredValue) || [])[0];
          },
          set: (value) => {
            if (filteredValue.value) {
              if (typeof value !== "undefined" && value !== null) {
                filteredValue.value.splice(0, 1, value);
              } else {
                filteredValue.value.splice(0, 1);
              }
            }
          }
        });
        const filteredValue = computed({
          get() {
            if (props.column) {
              return props.column.filteredValue || [];
            }
            return [];
          },
          set(value) {
            if (props.column) {
              props.upDataColumn("filteredValue", value);
            }
          }
        });
        const multiple = computed(() => {
          if (props.column) {
            return props.column.filterMultiple;
          }
          return true;
        });
        const isActive = (filter) => {
          return filter.value === filterValue.value;
        };
        const hidden = () => {
          tooltipVisible.value = false;
        };
        const showFilterPanel = (e) => {
          e.stopPropagation();
          tooltipVisible.value = !tooltipVisible.value;
        };
        const hideFilterPanel = () => {
          tooltipVisible.value = false;
        };
        const handleConfirm = () => {
          confirmFilter(filteredValue.value);
          hidden();
        };
        const handleReset = () => {
          filteredValue.value = [];
          confirmFilter(filteredValue.value);
          hidden();
        };
        const handleSelect = (_filterValue) => {
          filterValue.value = _filterValue;
          if (typeof _filterValue !== "undefined" && _filterValue !== null) {
            confirmFilter(filteredValue.value);
          } else {
            confirmFilter([]);
          }
          hidden();
        };
        const confirmFilter = (filteredValue2) => {
          props.store.commit("filterChange", {
            column: props.column,
            values: filteredValue2
          });
          props.store.updateAllSelected();
        };
        watch(tooltipVisible, (value) => {
          if (props.column) {
            props.upDataColumn("filterOpened", value);
          }
        }, {
          immediate: true
        });
        const popperPaneRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        return {
          tooltipVisible,
          multiple,
          filterClassName,
          filteredValue,
          filterValue,
          filters,
          handleConfirm,
          handleReset,
          handleSelect,
          isActive,
          t,
          ns,
          showFilterPanel,
          hideFilterPanel,
          popperPaneRef,
          tooltip
        };
      }
    });
    const _hoisted_1$c = { key: 0 };
    const _hoisted_2$7 = ["disabled"];
    const _hoisted_3$4 = ["label", "onClick"];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_arrow_up = resolveComponent("arrow-up");
      const _component_arrow_down = resolveComponent("arrow-down");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _directive_click_outside = resolveDirective("click-outside");
      return openBlock(), createBlock(_component_el_tooltip, {
        ref: "tooltip",
        visible: _ctx.tooltipVisible,
        offset: 0,
        placement: _ctx.placement,
        "show-arrow": false,
        "stop-popper-mouse-event": false,
        teleported: "",
        effect: "light",
        pure: "",
        "popper-class": _ctx.filterClassName,
        persistent: ""
      }, {
        content: withCtx(() => [
          _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.e("content"))
            }, [
              createVNode(_component_el_scrollbar, {
                "wrap-class": _ctx.ns.e("wrap")
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_checkbox_group, {
                    modelValue: _ctx.filteredValue,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                    class: normalizeClass(_ctx.ns.e("checkbox-group"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                        return openBlock(), createBlock(_component_el_checkbox, {
                          key: filter.value,
                          label: filter.value
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(filter.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["label"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue", "class"])
                ]),
                _: 1
              }, 8, ["wrap-class"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.e("bottom"))
            }, [
              createBaseVNode("button", {
                class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                disabled: _ctx.filteredValue.length === 0,
                type: "button",
                onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
              }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2$7),
              createBaseVNode("button", {
                type: "button",
                onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
              }, toDisplayString(_ctx.t("el.table.resetFilter")), 1)
            ], 2)
          ])) : (openBlock(), createElementBlock("ul", {
            key: 1,
            class: normalizeClass(_ctx.ns.e("list"))
          }, [
            createBaseVNode("li", {
              class: normalizeClass([
                _ctx.ns.e("list-item"),
                {
                  [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
                }
              ]),
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
            }, toDisplayString(_ctx.t("el.table.clearFilter")), 3),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
              return openBlock(), createElementBlock("li", {
                key: filter.value,
                class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
                label: filter.value,
                onClick: ($event) => _ctx.handleSelect(filter.value)
              }, toDisplayString(filter.text), 11, _hoisted_3$4);
            }), 128))
          ], 2))
        ]),
        default: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("span", {
            class: normalizeClass([
              `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
              `${_ctx.ns.namespace.value}-none-outline`
            ]),
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
          }, [
            createVNode(_component_el_icon, null, {
              default: withCtx(() => [
                _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
              ]),
              _: 1
            })
          ], 2)), [
            [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
          ])
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class"]);
    }
    var FilterPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$2], ["__file", "filter-panel.vue"]]);
    function useLayoutObserver(root2) {
      const instance = getCurrentInstance();
      onBeforeMount(() => {
        tableLayout.value.addObserver(instance);
      });
      onMounted(() => {
        onColumnsChange(tableLayout.value);
        onScrollableChange(tableLayout.value);
      });
      onUpdated(() => {
        onColumnsChange(tableLayout.value);
        onScrollableChange(tableLayout.value);
      });
      onUnmounted(() => {
        tableLayout.value.removeObserver(instance);
      });
      const tableLayout = computed(() => {
        const layout = root2.layout;
        if (!layout) {
          throw new Error("Can not find table layout.");
        }
        return layout;
      });
      const onColumnsChange = (layout) => {
        var _a2;
        const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
        if (!cols.length)
          return;
        const flattenColumns = layout.getFlattenColumns();
        const columnsMap = {};
        flattenColumns.forEach((column) => {
          columnsMap[column.id] = column;
        });
        for (let i = 0, j = cols.length; i < j; i++) {
          const col = cols[i];
          const name = col.getAttribute("name");
          const column = columnsMap[name];
          if (column) {
            col.setAttribute("width", column.realWidth || column.width);
          }
        }
      };
      const onScrollableChange = (layout) => {
        var _a2, _b;
        const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
        for (let i = 0, j = cols.length; i < j; i++) {
          const col = cols[i];
          col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
        }
        const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
        for (let i = 0, j = ths.length; i < j; i++) {
          const th = ths[i];
          th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
          th.style.display = layout.scrollY.value ? "" : "none";
        }
      };
      return {
        tableLayout: tableLayout.value,
        onColumnsChange,
        onScrollableChange
      };
    }
    const TABLE_INJECTION_KEY = Symbol("ElTable");
    function useEvent(props, emit2) {
      const instance = getCurrentInstance();
      const parent = inject(TABLE_INJECTION_KEY);
      const handleFilterClick = (event) => {
        event.stopPropagation();
        return;
      };
      const handleHeaderClick = (event, column) => {
        if (!column.filters && column.sortable) {
          handleSortClick(event, column, false);
        } else if (column.filterable && !column.sortable) {
          handleFilterClick(event);
        }
        parent == null ? void 0 : parent.emit("header-click", column, event);
      };
      const handleHeaderContextMenu = (event, column) => {
        parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
      };
      const draggingColumn = ref(null);
      const dragging = ref(false);
      const dragState = ref({});
      const handleMouseDown = (event, column) => {
        if (!isClient)
          return;
        if (column.children && column.children.length > 0)
          return;
        if (draggingColumn.value && props.border) {
          dragging.value = true;
          const table = parent;
          emit2("set-drag-visible", true);
          const tableEl = table == null ? void 0 : table.vnode.el;
          const tableLeft = tableEl.getBoundingClientRect().left;
          const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
          const columnRect = columnEl.getBoundingClientRect();
          const minLeft = columnRect.left - tableLeft + 30;
          addClass(columnEl, "noclick");
          dragState.value = {
            startMouseLeft: event.clientX,
            startLeft: columnRect.right - tableLeft,
            startColumnLeft: columnRect.left - tableLeft,
            tableLeft
          };
          const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
          resizeProxy.style.left = `${dragState.value.startLeft}px`;
          document.onselectstart = function() {
            return false;
          };
          document.ondragstart = function() {
            return false;
          };
          const handleMouseMove2 = (event2) => {
            const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
            const proxyLeft = dragState.value.startLeft + deltaLeft;
            resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
          };
          const handleMouseUp = () => {
            if (dragging.value) {
              const { startColumnLeft, startLeft } = dragState.value;
              const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
              const columnWidth = finalLeft - startColumnLeft;
              column.width = column.realWidth = columnWidth;
              table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
              requestAnimationFrame(() => {
                props.store.scheduleLayout(false, true);
              });
              document.body.style.cursor = "";
              dragging.value = false;
              draggingColumn.value = null;
              dragState.value = {};
              emit2("set-drag-visible", false);
            }
            document.removeEventListener("mousemove", handleMouseMove2);
            document.removeEventListener("mouseup", handleMouseUp);
            document.onselectstart = null;
            document.ondragstart = null;
            setTimeout(() => {
              removeClass(columnEl, "noclick");
            }, 0);
          };
          document.addEventListener("mousemove", handleMouseMove2);
          document.addEventListener("mouseup", handleMouseUp);
        }
      };
      const handleMouseMove = (event, column) => {
        if (column.children && column.children.length > 0)
          return;
        const el = event.target;
        if (!isElement(el)) {
          return;
        }
        const target = el == null ? void 0 : el.closest("th");
        if (!column || !column.resizable)
          return;
        if (!dragging.value && props.border) {
          const rect = target.getBoundingClientRect();
          const bodyStyle = document.body.style;
          if (rect.width > 12 && rect.right - event.pageX < 8) {
            bodyStyle.cursor = "col-resize";
            if (hasClass(target, "is-sortable")) {
              target.style.cursor = "col-resize";
            }
            draggingColumn.value = column;
          } else if (!dragging.value) {
            bodyStyle.cursor = "";
            if (hasClass(target, "is-sortable")) {
              target.style.cursor = "pointer";
            }
            draggingColumn.value = null;
          }
        }
      };
      const handleMouseOut = () => {
        if (!isClient)
          return;
        document.body.style.cursor = "";
      };
      const toggleOrder = ({ order, sortOrders }) => {
        if (order === "")
          return sortOrders[0];
        const index = sortOrders.indexOf(order || null);
        return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
      };
      const handleSortClick = (event, column, givenOrder) => {
        var _a2;
        event.stopPropagation();
        const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
        const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
        if (target) {
          if (hasClass(target, "noclick")) {
            removeClass(target, "noclick");
            return;
          }
        }
        if (!column.sortable)
          return;
        const states = props.store.states;
        let sortProp = states.sortProp.value;
        let sortOrder;
        const sortingColumn = states.sortingColumn.value;
        if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
          if (sortingColumn) {
            sortingColumn.order = null;
          }
          states.sortingColumn.value = column;
          sortProp = column.property;
        }
        if (!order) {
          sortOrder = column.order = null;
        } else {
          sortOrder = column.order = order;
        }
        states.sortProp.value = sortProp;
        states.sortOrder.value = sortOrder;
        parent == null ? void 0 : parent.store.commit("changeSortCondition");
      };
      return {
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick
      };
    }
    function useStyle$2(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const ns = useNamespace("table");
      const getHeaderRowStyle = (rowIndex) => {
        const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
        if (typeof headerRowStyle === "function") {
          return headerRowStyle.call(null, { rowIndex });
        }
        return headerRowStyle;
      };
      const getHeaderRowClass = (rowIndex) => {
        const classes = [];
        const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
        if (typeof headerRowClassName === "string") {
          classes.push(headerRowClassName);
        } else if (typeof headerRowClassName === "function") {
          classes.push(headerRowClassName.call(null, { rowIndex }));
        }
        return classes.join(" ");
      };
      const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
        var _a2;
        let headerCellStyles = (_a2 = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a2 : {};
        if (typeof headerCellStyles === "function") {
          headerCellStyles = headerCellStyles.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          });
        }
        const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
        ensurePosition(fixedStyle, "left");
        ensurePosition(fixedStyle, "right");
        return Object.assign({}, headerCellStyles, fixedStyle);
      };
      const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
        const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
        const classes = [
          column.id,
          column.order,
          column.headerAlign,
          column.className,
          column.labelClassName,
          ...fixedClasses
        ];
        if (!column.children) {
          classes.push("is-leaf");
        }
        if (column.sortable) {
          classes.push("is-sortable");
        }
        const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
        if (typeof headerCellClassName === "string") {
          classes.push(headerCellClassName);
        } else if (typeof headerCellClassName === "function") {
          classes.push(headerCellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          }));
        }
        classes.push(ns.e("cell"));
        return classes.filter((className) => Boolean(className)).join(" ");
      };
      return {
        getHeaderRowStyle,
        getHeaderRowClass,
        getHeaderCellStyle,
        getHeaderCellClass
      };
    }
    const getAllColumns = (columns) => {
      const result = [];
      columns.forEach((column) => {
        if (column.children) {
          result.push(column);
          result.push.apply(result, getAllColumns(column.children));
        } else {
          result.push(column);
        }
      });
      return result;
    };
    const convertToRows = (originColumns) => {
      let maxLevel = 1;
      const traverse2 = (column, parent) => {
        if (parent) {
          column.level = parent.level + 1;
          if (maxLevel < column.level) {
            maxLevel = column.level;
          }
        }
        if (column.children) {
          let colSpan = 0;
          column.children.forEach((subColumn) => {
            traverse2(subColumn, column);
            colSpan += subColumn.colSpan;
          });
          column.colSpan = colSpan;
        } else {
          column.colSpan = 1;
        }
      };
      originColumns.forEach((column) => {
        column.level = 1;
        traverse2(column, void 0);
      });
      const rows = [];
      for (let i = 0; i < maxLevel; i++) {
        rows.push([]);
      }
      const allColumns = getAllColumns(originColumns);
      allColumns.forEach((column) => {
        if (!column.children) {
          column.rowSpan = maxLevel - column.level + 1;
        } else {
          column.rowSpan = 1;
          column.children.forEach((col) => col.isSubColumn = true);
        }
        rows[column.level - 1].push(column);
      });
      return rows;
    };
    function useUtils$1(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const columnRows = computed(() => {
        return convertToRows(props.store.states.originColumns.value);
      });
      const isGroup = computed(() => {
        const result = columnRows.value.length > 1;
        if (result && parent) {
          parent.state.isGroup.value = true;
        }
        return result;
      });
      const toggleAllSelection = (event) => {
        event.stopPropagation();
        parent == null ? void 0 : parent.store.commit("toggleAllSelection");
      };
      return {
        isGroup,
        toggleAllSelection,
        columnRows
      };
    }
    var TableHeader = /* @__PURE__ */ defineComponent({
      name: "ElTableHeader",
      components: {
        ElCheckbox
      },
      props: {
        fixed: {
          type: String,
          default: ""
        },
        store: {
          required: true,
          type: Object
        },
        border: Boolean,
        defaultSort: {
          type: Object,
          default: () => {
            return {
              prop: "",
              order: ""
            };
          }
        }
      },
      setup(props, { emit: emit2 }) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const filterPanels = ref({});
        const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
        onMounted(async () => {
          await nextTick();
          await nextTick();
          const { prop, order } = props.defaultSort;
          parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
        });
        const {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        } = useEvent(props, emit2);
        const {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        } = useStyle$2(props);
        const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
        instance.state = {
          onColumnsChange,
          onScrollableChange
        };
        instance.filterPanels = filterPanels;
        return {
          ns,
          filterPanels,
          onColumnsChange,
          onScrollableChange,
          columnRows,
          getHeaderRowClass,
          getHeaderRowStyle,
          getHeaderCellClass,
          getHeaderCellStyle,
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick,
          isGroup,
          toggleAllSelection
        };
      },
      render() {
        const {
          ns,
          isGroup,
          columnRows,
          getHeaderCellStyle,
          getHeaderCellClass,
          getHeaderRowClass,
          getHeaderRowStyle,
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleSortClick,
          handleMouseOut,
          store,
          $parent
        } = this;
        let rowSpan = 1;
        return h$1("thead", {
          class: { [ns.is("group")]: isGroup }
        }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
          class: getHeaderRowClass(rowIndex),
          key: rowIndex,
          style: getHeaderRowStyle(rowIndex)
        }, subColumns.map((column, cellIndex) => {
          if (column.rowSpan > rowSpan) {
            rowSpan = column.rowSpan;
          }
          return h$1("th", {
            class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
            colspan: column.colSpan,
            key: `${column.id}-thead`,
            rowspan: column.rowSpan,
            style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
            onClick: ($event) => handleHeaderClick($event, column),
            onContextmenu: ($event) => handleHeaderContextMenu($event, column),
            onMousedown: ($event) => handleMouseDown($event, column),
            onMousemove: ($event) => handleMouseMove($event, column),
            onMouseout: handleMouseOut
          }, [
            h$1("div", {
              class: [
                "cell",
                column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
              ]
            }, [
              column.renderHeader ? column.renderHeader({
                column,
                $index: cellIndex,
                store,
                _self: $parent
              }) : column.label,
              column.sortable && h$1("span", {
                onClick: ($event) => handleSortClick($event, column),
                class: "caret-wrapper"
              }, [
                h$1("i", {
                  onClick: ($event) => handleSortClick($event, column, "ascending"),
                  class: "sort-caret ascending"
                }),
                h$1("i", {
                  onClick: ($event) => handleSortClick($event, column, "descending"),
                  class: "sort-caret descending"
                })
              ]),
              column.filterable && h$1(FilterPanel, {
                store,
                placement: column.filterPlacement || "bottom-start",
                column,
                upDataColumn: (key, value) => {
                  column[key] = value;
                }
              })
            ])
          ]);
        }))));
      }
    });
    function useEvents(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const tooltipContent = ref("");
      const tooltipTrigger = ref(h$1("div"));
      const handleEvent = (event, row, name) => {
        var _a2;
        const table = parent;
        const cell = getCell(event);
        let column;
        const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
        if (cell) {
          column = getColumnByCell({
            columns: props.store.states.columns.value
          }, cell, namespace);
          if (column) {
            table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
          }
        }
        table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
      };
      const handleDoubleClick = (event, row) => {
        handleEvent(event, row, "dblclick");
      };
      const handleClick = (event, row) => {
        props.store.commit("setCurrentRow", row);
        handleEvent(event, row, "click");
      };
      const handleContextMenu = (event, row) => {
        handleEvent(event, row, "contextmenu");
      };
      const handleMouseEnter = debounce((index) => {
        props.store.commit("setHoverRow", index);
      }, 30);
      const handleMouseLeave = debounce(() => {
        props.store.commit("setHoverRow", null);
      }, 30);
      const getPadding = (el) => {
        const style = window.getComputedStyle(el, null);
        const paddingLeft = Number.parseInt(style.paddingLeft, 10) || 0;
        const paddingRight = Number.parseInt(style.paddingRight, 10) || 0;
        const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
        const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
        return {
          left: paddingLeft,
          right: paddingRight,
          top: paddingTop,
          bottom: paddingBottom
        };
      };
      const handleCellMouseEnter = (event, row, tooltipOptions) => {
        var _a2;
        const table = parent;
        const cell = getCell(event);
        const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
        if (cell) {
          const column = getColumnByCell({
            columns: props.store.states.columns.value
          }, cell, namespace);
          const hoverState = table.hoverState = { cell, column, row };
          table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
        }
        if (!tooltipOptions) {
          return;
        }
        const cellChild = event.target.querySelector(".cell");
        if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
          return;
        }
        const range2 = document.createRange();
        range2.setStart(cellChild, 0);
        range2.setEnd(cellChild, cellChild.childNodes.length);
        let rangeWidth = range2.getBoundingClientRect().width;
        let rangeHeight = range2.getBoundingClientRect().height;
        const offsetWidth = rangeWidth - Math.floor(rangeWidth);
        if (offsetWidth < 1e-3) {
          rangeWidth = Math.floor(rangeWidth);
        }
        const offsetHeight = rangeHeight - Math.floor(rangeHeight);
        if (offsetHeight < 1e-3) {
          rangeHeight = Math.floor(rangeHeight);
        }
        const { top, left, right, bottom } = getPadding(cellChild);
        const horizontalPadding = left + right;
        const verticalPadding = top + bottom;
        if (rangeWidth + horizontalPadding > cellChild.offsetWidth || rangeHeight + verticalPadding > cellChild.offsetHeight || cellChild.scrollWidth > cellChild.offsetWidth) {
          createTablePopper(tooltipOptions, cell.innerText || cell.textContent, cell, table);
        }
      };
      const handleCellMouseLeave = (event) => {
        const cell = getCell(event);
        if (!cell)
          return;
        const oldHoverState = parent == null ? void 0 : parent.hoverState;
        parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
      };
      return {
        handleDoubleClick,
        handleClick,
        handleContextMenu,
        handleMouseEnter,
        handleMouseLeave,
        handleCellMouseEnter,
        handleCellMouseLeave,
        tooltipContent,
        tooltipTrigger
      };
    }
    function useStyles(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const ns = useNamespace("table");
      const getRowStyle = (row, rowIndex) => {
        const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
        if (typeof rowStyle === "function") {
          return rowStyle.call(null, {
            row,
            rowIndex
          });
        }
        return rowStyle || null;
      };
      const getRowClass = (row, rowIndex) => {
        const classes = [ns.e("row")];
        if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
          classes.push("current-row");
        }
        if (props.stripe && rowIndex % 2 === 1) {
          classes.push(ns.em("row", "striped"));
        }
        const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
        if (typeof rowClassName === "string") {
          classes.push(rowClassName);
        } else if (typeof rowClassName === "function") {
          classes.push(rowClassName.call(null, {
            row,
            rowIndex
          }));
        }
        return classes;
      };
      const getCellStyle = (rowIndex, columnIndex, row, column) => {
        const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
        let cellStyles = cellStyle != null ? cellStyle : {};
        if (typeof cellStyle === "function") {
          cellStyles = cellStyle.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          });
        }
        const fixedStyle = getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
        ensurePosition(fixedStyle, "left");
        ensurePosition(fixedStyle, "right");
        return Object.assign({}, cellStyles, fixedStyle);
      };
      const getCellClass = (rowIndex, columnIndex, row, column, offset) => {
        const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store, void 0, offset);
        const classes = [column.id, column.align, column.className, ...fixedClasses];
        const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
        if (typeof cellClassName === "string") {
          classes.push(cellClassName);
        } else if (typeof cellClassName === "function") {
          classes.push(cellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          }));
        }
        classes.push(ns.e("cell"));
        return classes.filter((className) => Boolean(className)).join(" ");
      };
      const getSpan = (row, column, rowIndex, columnIndex) => {
        let rowspan = 1;
        let colspan = 1;
        const fn2 = parent == null ? void 0 : parent.props.spanMethod;
        if (typeof fn2 === "function") {
          const result = fn2({
            row,
            column,
            rowIndex,
            columnIndex
          });
          if (Array.isArray(result)) {
            rowspan = result[0];
            colspan = result[1];
          } else if (typeof result === "object") {
            rowspan = result.rowspan;
            colspan = result.colspan;
          }
        }
        return { rowspan, colspan };
      };
      const getColspanRealWidth = (columns, colspan, index) => {
        if (colspan < 1) {
          return columns[index].realWidth;
        }
        const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index, index + colspan);
        return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
      };
      return {
        getRowStyle,
        getRowClass,
        getCellStyle,
        getCellClass,
        getSpan,
        getColspanRealWidth
      };
    }
    function useRender$1(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const ns = useNamespace("table");
      const {
        handleDoubleClick,
        handleClick,
        handleContextMenu,
        handleMouseEnter,
        handleMouseLeave,
        handleCellMouseEnter,
        handleCellMouseLeave,
        tooltipContent,
        tooltipTrigger
      } = useEvents(props);
      const {
        getRowStyle,
        getRowClass,
        getCellStyle,
        getCellClass,
        getSpan,
        getColspanRealWidth
      } = useStyles(props);
      const firstDefaultColumnIndex = computed(() => {
        return props.store.states.columns.value.findIndex(({ type }) => type === "default");
      });
      const getKeyOfRow = (row, index) => {
        const rowKey = parent.props.rowKey;
        if (rowKey) {
          return getRowIdentity(row, rowKey);
        }
        return index;
      };
      const rowRender = (row, $index, treeRowData, expanded = false) => {
        const { tooltipEffect, tooltipOptions, store } = props;
        const { indent, columns } = store.states;
        const rowClasses = getRowClass(row, $index);
        let display = true;
        if (treeRowData) {
          rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
          display = treeRowData.display;
        }
        const displayStyle = display ? null : {
          display: "none"
        };
        return h$1("tr", {
          style: [displayStyle, getRowStyle(row, $index)],
          class: rowClasses,
          key: getKeyOfRow(row, $index),
          onDblclick: ($event) => handleDoubleClick($event, row),
          onClick: ($event) => handleClick($event, row),
          onContextmenu: ($event) => handleContextMenu($event, row),
          onMouseenter: () => handleMouseEnter($index),
          onMouseleave: handleMouseLeave
        }, columns.value.map((column, cellIndex) => {
          const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
          if (!rowspan || !colspan) {
            return null;
          }
          const columnData = Object.assign({}, column);
          columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
          const data = {
            store: props.store,
            _self: props.context || parent,
            column: columnData,
            row,
            $index,
            cellIndex,
            expanded
          };
          if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
            data.treeNode = {
              indent: treeRowData.level * indent.value,
              level: treeRowData.level
            };
            if (typeof treeRowData.expanded === "boolean") {
              data.treeNode.expanded = treeRowData.expanded;
              if ("loading" in treeRowData) {
                data.treeNode.loading = treeRowData.loading;
              }
              if ("noLazyChildren" in treeRowData) {
                data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
              }
            }
          }
          const baseKey = `${$index},${cellIndex}`;
          const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
          const tdChildren = cellChildren(cellIndex, column, data);
          const mergedTooltipOptions = column.showOverflowTooltip && merge$1({
            effect: tooltipEffect
          }, tooltipOptions, column.showOverflowTooltip);
          return h$1("td", {
            style: getCellStyle($index, cellIndex, row, column),
            class: getCellClass($index, cellIndex, row, column, colspan - 1),
            key: `${patchKey}${baseKey}`,
            rowspan,
            colspan,
            onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
            onMouseleave: handleCellMouseLeave
          }, [tdChildren]);
        }));
      };
      const cellChildren = (cellIndex, column, data) => {
        return column.renderCell(data);
      };
      const wrappedRowRender = (row, $index) => {
        const store = props.store;
        const { isRowExpanded, assertRowKey } = store;
        const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
        const columns = store.states.columns.value;
        const hasExpandColumn = columns.some(({ type }) => type === "expand");
        if (hasExpandColumn) {
          const expanded = isRowExpanded(row);
          const tr = rowRender(row, $index, void 0, expanded);
          const renderExpanded = parent.renderExpanded;
          if (expanded) {
            if (!renderExpanded) {
              console.error("[Element Error]renderExpanded is required.");
              return tr;
            }
            return [
              [
                tr,
                h$1("tr", {
                  key: `expanded-row__${tr.key}`
                }, [
                  h$1("td", {
                    colspan: columns.length,
                    class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                  }, [renderExpanded({ row, $index, store, expanded })])
                ])
              ]
            ];
          } else {
            return [[tr]];
          }
        } else if (Object.keys(treeData.value).length) {
          assertRowKey();
          const key = getRowIdentity(row, rowKey.value);
          let cur = treeData.value[key];
          let treeRowData = null;
          if (cur) {
            treeRowData = {
              expanded: cur.expanded,
              level: cur.level,
              display: true
            };
            if (typeof cur.lazy === "boolean") {
              if (typeof cur.loaded === "boolean" && cur.loaded) {
                treeRowData.noLazyChildren = !(cur.children && cur.children.length);
              }
              treeRowData.loading = cur.loading;
            }
          }
          const tmp = [rowRender(row, $index, treeRowData)];
          if (cur) {
            let i = 0;
            const traverse2 = (children, parent2) => {
              if (!(children && children.length && parent2))
                return;
              children.forEach((node) => {
                const innerTreeRowData = {
                  display: parent2.display && parent2.expanded,
                  level: parent2.level + 1,
                  expanded: false,
                  noLazyChildren: false,
                  loading: false
                };
                const childKey = getRowIdentity(node, rowKey.value);
                if (childKey === void 0 || childKey === null) {
                  throw new Error("For nested data item, row-key is required.");
                }
                cur = { ...treeData.value[childKey] };
                if (cur) {
                  innerTreeRowData.expanded = cur.expanded;
                  cur.level = cur.level || innerTreeRowData.level;
                  cur.display = !!(cur.expanded && innerTreeRowData.display);
                  if (typeof cur.lazy === "boolean") {
                    if (typeof cur.loaded === "boolean" && cur.loaded) {
                      innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                    }
                    innerTreeRowData.loading = cur.loading;
                  }
                }
                i++;
                tmp.push(rowRender(node, $index + i, innerTreeRowData));
                if (cur) {
                  const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                  traverse2(nodes2, cur);
                }
              });
            };
            cur.display = true;
            const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
            traverse2(nodes, cur);
          }
          return tmp;
        } else {
          return rowRender(row, $index, void 0);
        }
      };
      return {
        wrappedRowRender,
        tooltipContent,
        tooltipTrigger
      };
    }
    const defaultProps$2 = {
      store: {
        required: true,
        type: Object
      },
      stripe: Boolean,
      tooltipEffect: String,
      tooltipOptions: {
        type: Object
      },
      context: {
        default: () => ({}),
        type: Object
      },
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      fixed: {
        type: String,
        default: ""
      },
      highlight: Boolean
    };
    var TableBody = /* @__PURE__ */ defineComponent({
      name: "ElTableBody",
      props: defaultProps$2,
      setup(props) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props);
        const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
        watch(props.store.states.hoverRow, (newVal, oldVal) => {
          if (!props.store.states.isComplex.value || !isClient)
            return;
          rAF(() => {
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            const oldRow = rows[oldVal];
            const newRow = rows[newVal];
            if (oldRow) {
              removeClass(oldRow, "hover-row");
            }
            if (newRow) {
              addClass(newRow, "hover-row");
            }
          });
        });
        onUnmounted(() => {
          var _a2;
          (_a2 = removePopper) == null ? void 0 : _a2();
        });
        return {
          ns,
          onColumnsChange,
          onScrollableChange,
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      },
      render() {
        const { wrappedRowRender, store } = this;
        const data = store.states.data.value || [];
        return h$1("tbody", { tabIndex: -1 }, [
          data.reduce((acc, row) => {
            return acc.concat(wrappedRowRender(row, acc.length));
          }, [])
        ]);
      }
    });
    function useMapState() {
      const table = inject(TABLE_INJECTION_KEY);
      const store = table == null ? void 0 : table.store;
      const leftFixedLeafCount = computed(() => {
        return store.states.fixedLeafColumnsLength.value;
      });
      const rightFixedLeafCount = computed(() => {
        return store.states.rightFixedColumns.value.length;
      });
      const columnsCount = computed(() => {
        return store.states.columns.value.length;
      });
      const leftFixedCount = computed(() => {
        return store.states.fixedColumns.value.length;
      });
      const rightFixedCount = computed(() => {
        return store.states.rightFixedColumns.value.length;
      });
      return {
        leftFixedLeafCount,
        rightFixedLeafCount,
        columnsCount,
        leftFixedCount,
        rightFixedCount,
        columns: store.states.columns
      };
    }
    function useStyle$1(props) {
      const { columns } = useMapState();
      const ns = useNamespace("table");
      const getCellClasses = (columns2, cellIndex) => {
        const column = columns2[cellIndex];
        const classes = [
          ns.e("cell"),
          column.id,
          column.align,
          column.labelClassName,
          ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)
        ];
        if (column.className) {
          classes.push(column.className);
        }
        if (!column.children) {
          classes.push(ns.is("leaf"));
        }
        return classes;
      };
      const getCellStyles = (column, cellIndex) => {
        const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
        ensurePosition(fixedStyle, "left");
        ensurePosition(fixedStyle, "right");
        return fixedStyle;
      };
      return {
        getCellClasses,
        getCellStyles,
        columns
      };
    }
    var TableFooter = /* @__PURE__ */ defineComponent({
      name: "ElTableFooter",
      props: {
        fixed: {
          type: String,
          default: ""
        },
        store: {
          required: true,
          type: Object
        },
        summaryMethod: Function,
        sumText: String,
        border: Boolean,
        defaultSort: {
          type: Object,
          default: () => {
            return {
              prop: "",
              order: ""
            };
          }
        }
      },
      setup(props) {
        const { getCellClasses, getCellStyles, columns } = useStyle$1(props);
        const ns = useNamespace("table");
        return {
          ns,
          getCellClasses,
          getCellStyles,
          columns
        };
      },
      render() {
        const { columns, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
        const data = this.store.states.data.value;
        let sums = [];
        if (summaryMethod) {
          sums = summaryMethod({
            columns,
            data
          });
        } else {
          columns.forEach((column, index) => {
            if (index === 0) {
              sums[index] = sumText;
              return;
            }
            const values = data.map((item) => Number(item[column.property]));
            const precisions = [];
            let notNumber = true;
            values.forEach((value) => {
              if (!Number.isNaN(+value)) {
                notNumber = false;
                const decimal = `${value}`.split(".")[1];
                precisions.push(decimal ? decimal.length : 0);
              }
            });
            const precision = Math.max.apply(null, precisions);
            if (!notNumber) {
              sums[index] = values.reduce((prev, curr) => {
                const value = Number(curr);
                if (!Number.isNaN(+value)) {
                  return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                } else {
                  return prev;
                }
              }, 0);
            } else {
              sums[index] = "";
            }
          });
        }
        return h$1(h$1("tfoot", [
          h$1("tr", {}, [
            ...columns.map((column, cellIndex) => h$1("td", {
              key: cellIndex,
              colspan: column.colSpan,
              rowspan: column.rowSpan,
              class: getCellClasses(columns, cellIndex),
              style: getCellStyles(column, cellIndex)
            }, [
              h$1("div", {
                class: ["cell", column.labelClassName]
              }, [sums[cellIndex]])
            ]))
          ])
        ]));
      }
    });
    function useUtils(store) {
      const setCurrentRow = (row) => {
        store.commit("setCurrentRow", row);
      };
      const getSelectionRows = () => {
        return store.getSelectionRows();
      };
      const toggleRowSelection = (row, selected) => {
        store.toggleRowSelection(row, selected, false);
        store.updateAllSelected();
      };
      const clearSelection = () => {
        store.clearSelection();
      };
      const clearFilter = (columnKeys) => {
        store.clearFilter(columnKeys);
      };
      const toggleAllSelection = () => {
        store.commit("toggleAllSelection");
      };
      const toggleRowExpansion = (row, expanded) => {
        store.toggleRowExpansionAdapter(row, expanded);
      };
      const clearSort = () => {
        store.clearSort();
      };
      const sort = (prop, order) => {
        store.commit("sort", { prop, order });
      };
      return {
        setCurrentRow,
        getSelectionRows,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        sort
      };
    }
    function useStyle(props, layout, store, table) {
      const isHidden2 = ref(false);
      const renderExpanded = ref(null);
      const resizeProxyVisible = ref(false);
      const setDragVisible = (visible) => {
        resizeProxyVisible.value = visible;
      };
      const resizeState = ref({
        width: null,
        height: null,
        headerHeight: null
      });
      const isGroup = ref(false);
      const scrollbarViewStyle = {
        display: "inline-block",
        verticalAlign: "middle"
      };
      const tableWidth = ref();
      const tableScrollHeight = ref(0);
      const bodyScrollHeight = ref(0);
      const headerScrollHeight = ref(0);
      const footerScrollHeight = ref(0);
      const appendScrollHeight = ref(0);
      watchEffect(() => {
        layout.setHeight(props.height);
      });
      watchEffect(() => {
        layout.setMaxHeight(props.maxHeight);
      });
      watch(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
        if (!unref(rowKey) || !unref(currentRowKey))
          return;
        store.setCurrentRowKey(`${currentRowKey}`);
      }, {
        immediate: true
      });
      watch(() => props.data, (data) => {
        table.store.commit("setData", data);
      }, {
        immediate: true,
        deep: true
      });
      watchEffect(() => {
        if (props.expandRowKeys) {
          store.setExpandRowKeysAdapter(props.expandRowKeys);
        }
      });
      const handleMouseLeave = () => {
        table.store.commit("setHoverRow", null);
        if (table.hoverState)
          table.hoverState = null;
      };
      const handleHeaderFooterMousewheel = (event, data) => {
        const { pixelX, pixelY } = data;
        if (Math.abs(pixelX) >= Math.abs(pixelY)) {
          table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
        }
      };
      const shouldUpdateHeight = computed(() => {
        return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
      });
      const tableBodyStyles = computed(() => {
        return {
          width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
        };
      });
      const doLayout = () => {
        if (shouldUpdateHeight.value) {
          layout.updateElsHeight();
        }
        layout.updateColumnsWidth();
        requestAnimationFrame(syncPosition);
      };
      onMounted(async () => {
        await nextTick();
        store.updateColumns();
        bindEvents();
        requestAnimationFrame(doLayout);
        const el = table.vnode.el;
        const tableHeader = table.refs.headerWrapper;
        if (props.flexible && el && el.parentElement) {
          el.parentElement.style.minWidth = "0";
        }
        resizeState.value = {
          width: tableWidth.value = el.offsetWidth,
          height: el.offsetHeight,
          headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
        };
        store.states.columns.value.forEach((column) => {
          if (column.filteredValue && column.filteredValue.length) {
            table.store.commit("filterChange", {
              column,
              values: column.filteredValue,
              silent: true
            });
          }
        });
        table.$ready = true;
      });
      const setScrollClassByEl = (el, className) => {
        if (!el)
          return;
        const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
        classList.push(layout.scrollX.value ? className : "is-scrolling-none");
        el.className = classList.join(" ");
      };
      const setScrollClass = (className) => {
        const { tableWrapper } = table.refs;
        setScrollClassByEl(tableWrapper, className);
      };
      const hasScrollClass = (className) => {
        const { tableWrapper } = table.refs;
        return !!(tableWrapper && tableWrapper.classList.contains(className));
      };
      const syncPosition = function() {
        if (!table.refs.scrollBarRef)
          return;
        if (!layout.scrollX.value) {
          const scrollingNoneClass = "is-scrolling-none";
          if (!hasScrollClass(scrollingNoneClass)) {
            setScrollClass(scrollingNoneClass);
          }
          return;
        }
        const scrollContainer = table.refs.scrollBarRef.wrapRef;
        if (!scrollContainer)
          return;
        const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
        const { headerWrapper, footerWrapper } = table.refs;
        if (headerWrapper)
          headerWrapper.scrollLeft = scrollLeft;
        if (footerWrapper)
          footerWrapper.scrollLeft = scrollLeft;
        const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
        if (scrollLeft >= maxScrollLeftPosition) {
          setScrollClass("is-scrolling-right");
        } else if (scrollLeft === 0) {
          setScrollClass("is-scrolling-left");
        } else {
          setScrollClass("is-scrolling-middle");
        }
      };
      const bindEvents = () => {
        if (!table.refs.scrollBarRef)
          return;
        if (table.refs.scrollBarRef.wrapRef) {
          useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
            passive: true
          });
        }
        if (props.fit) {
          useResizeObserver(table.vnode.el, resizeListener);
        } else {
          useEventListener(window, "resize", resizeListener);
        }
        useResizeObserver(table.refs.bodyWrapper, () => {
          var _a2, _b;
          resizeListener();
          (_b = (_a2 = table.refs) == null ? void 0 : _a2.scrollBarRef) == null ? void 0 : _b.update();
        });
      };
      const resizeListener = () => {
        var _a2, _b, _c, _d;
        const el = table.vnode.el;
        if (!table.$ready || !el)
          return;
        let shouldUpdateLayout = false;
        const {
          width: oldWidth,
          height: oldHeight,
          headerHeight: oldHeaderHeight
        } = resizeState.value;
        const width = tableWidth.value = el.offsetWidth;
        if (oldWidth !== width) {
          shouldUpdateLayout = true;
        }
        const height = el.offsetHeight;
        if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
          shouldUpdateLayout = true;
        }
        const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a2 = table.refs.tableHeaderRef) == null ? void 0 : _a2.$el;
        if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
          shouldUpdateLayout = true;
        }
        tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
        headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
        footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
        appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
        bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
        if (shouldUpdateLayout) {
          resizeState.value = {
            width,
            height,
            headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
          };
          doLayout();
        }
      };
      const tableSize = useFormSize();
      const bodyWidth = computed(() => {
        const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
        return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
      });
      const tableLayout = computed(() => {
        if (props.maxHeight)
          return "fixed";
        return props.tableLayout;
      });
      const emptyBlockStyle = computed(() => {
        if (props.data && props.data.length)
          return null;
        let height = "100%";
        if (props.height && bodyScrollHeight.value) {
          height = `${bodyScrollHeight.value}px`;
        }
        const width = tableWidth.value;
        return {
          width: width ? `${width}px` : "",
          height
        };
      });
      const tableInnerStyle = computed(() => {
        if (props.height) {
          return {
            height: !Number.isNaN(Number(props.height)) ? `${props.height}px` : props.height
          };
        }
        if (props.maxHeight) {
          return {
            maxHeight: !Number.isNaN(Number(props.maxHeight)) ? `${props.maxHeight}px` : props.maxHeight
          };
        }
        return {};
      });
      const scrollbarStyle = computed(() => {
        if (props.height) {
          return {
            height: "100%"
          };
        }
        if (props.maxHeight) {
          if (!Number.isNaN(Number(props.maxHeight))) {
            return {
              maxHeight: `${props.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
            };
          } else {
            return {
              maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
            };
          }
        }
        return {};
      });
      const handleFixedMousewheel = (event, data) => {
        const bodyWrapper = table.refs.bodyWrapper;
        if (Math.abs(data.spinY) > 0) {
          const currentScrollTop = bodyWrapper.scrollTop;
          if (data.pixelY < 0 && currentScrollTop !== 0) {
            event.preventDefault();
          }
          if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
            event.preventDefault();
          }
          bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
        } else {
          bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
        }
      };
      return {
        isHidden: isHidden2,
        renderExpanded,
        setDragVisible,
        isGroup,
        handleMouseLeave,
        handleHeaderFooterMousewheel,
        tableSize,
        emptyBlockStyle,
        handleFixedMousewheel,
        resizeProxyVisible,
        bodyWidth,
        resizeState,
        doLayout,
        tableBodyStyles,
        tableLayout,
        scrollbarViewStyle,
        tableInnerStyle,
        scrollbarStyle
      };
    }
    function useKeyRender(table) {
      const observer = ref();
      const initWatchDom = () => {
        const el = table.vnode.el;
        const columnsWrapper = el.querySelector(".hidden-columns");
        const config = { childList: true, subtree: true };
        const updateOrderFns = table.store.states.updateOrderFns;
        observer.value = new MutationObserver(() => {
          updateOrderFns.forEach((fn2) => fn2());
        });
        observer.value.observe(columnsWrapper, config);
      };
      onMounted(() => {
        initWatchDom();
      });
      onUnmounted(() => {
        var _a2;
        (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
      });
    }
    var defaultProps$1 = {
      data: {
        type: Array,
        default: () => []
      },
      size: useSizeProp,
      width: [String, Number],
      height: [String, Number],
      maxHeight: [String, Number],
      fit: {
        type: Boolean,
        default: true
      },
      stripe: Boolean,
      border: Boolean,
      rowKey: [String, Function],
      showHeader: {
        type: Boolean,
        default: true
      },
      showSummary: Boolean,
      sumText: String,
      summaryMethod: Function,
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      cellClassName: [String, Function],
      cellStyle: [Object, Function],
      headerRowClassName: [String, Function],
      headerRowStyle: [Object, Function],
      headerCellClassName: [String, Function],
      headerCellStyle: [Object, Function],
      highlightCurrentRow: Boolean,
      currentRowKey: [String, Number],
      emptyText: String,
      expandRowKeys: Array,
      defaultExpandAll: Boolean,
      defaultSort: Object,
      tooltipEffect: String,
      tooltipOptions: Object,
      spanMethod: Function,
      selectOnIndeterminate: {
        type: Boolean,
        default: true
      },
      indent: {
        type: Number,
        default: 16
      },
      treeProps: {
        type: Object,
        default: () => {
          return {
            hasChildren: "hasChildren",
            children: "children"
          };
        }
      },
      lazy: Boolean,
      load: Function,
      style: {
        type: Object,
        default: () => ({})
      },
      className: {
        type: String,
        default: ""
      },
      tableLayout: {
        type: String,
        default: "fixed"
      },
      scrollbarAlwaysOn: {
        type: Boolean,
        default: false
      },
      flexible: Boolean,
      showOverflowTooltip: [Boolean, Object]
    };
    function hColgroup(props) {
      const isAuto = props.tableLayout === "auto";
      let columns = props.columns || [];
      if (isAuto) {
        if (columns.every((column) => column.width === void 0)) {
          columns = [];
        }
      }
      const getPropsData = (column) => {
        const propsData = {
          key: `${props.tableLayout}_${column.id}`,
          style: {},
          name: void 0
        };
        if (isAuto) {
          propsData.style = {
            width: `${column.width}px`
          };
        } else {
          propsData.name = column.id;
        }
        return propsData;
      };
      return h$1("colgroup", {}, columns.map((column) => h$1("col", getPropsData(column))));
    }
    hColgroup.props = ["columns", "tableLayout"];
    const useScrollbar = () => {
      const scrollBarRef = ref();
      const scrollTo = (options, yCoord) => {
        const scrollbar = scrollBarRef.value;
        if (scrollbar) {
          scrollbar.scrollTo(options, yCoord);
        }
      };
      const setScrollPosition = (position, offset) => {
        const scrollbar = scrollBarRef.value;
        if (scrollbar && isNumber(offset) && ["Top", "Left"].includes(position)) {
          scrollbar[`setScroll${position}`](offset);
        }
      };
      const setScrollTop = (top) => setScrollPosition("Top", top);
      const setScrollLeft = (left) => setScrollPosition("Left", left);
      return {
        scrollBarRef,
        scrollTo,
        setScrollTop,
        setScrollLeft
      };
    };
    let tableIdSeed = 1;
    const _sfc_main$e = /* @__PURE__ */ defineComponent({
      name: "ElTable",
      directives: {
        Mousewheel
      },
      components: {
        TableHeader,
        TableBody,
        TableFooter,
        ElScrollbar,
        hColgroup
      },
      props: defaultProps$1,
      emits: [
        "select",
        "select-all",
        "selection-change",
        "cell-mouse-enter",
        "cell-mouse-leave",
        "cell-contextmenu",
        "cell-click",
        "cell-dblclick",
        "row-click",
        "row-contextmenu",
        "row-dblclick",
        "header-click",
        "header-contextmenu",
        "sort-change",
        "filter-change",
        "current-change",
        "header-dragend",
        "expand-change"
      ],
      setup(props) {
        const { t } = useLocale();
        const ns = useNamespace("table");
        const table = getCurrentInstance();
        provide(TABLE_INJECTION_KEY, table);
        const store = createStore(table, props);
        table.store = store;
        const layout = new TableLayout({
          store: table.store,
          table,
          fit: props.fit,
          showHeader: props.showHeader
        });
        table.layout = layout;
        const isEmpty = computed(() => (store.states.data.value || []).length === 0);
        const {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort
        } = useUtils(store);
        const {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle
        } = useStyle(props, layout, store, table);
        const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
        const debouncedUpdateLayout = debounce(doLayout, 50);
        const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
        table.tableId = tableId;
        table.state = {
          isGroup,
          resizeState,
          doLayout,
          debouncedUpdateLayout
        };
        const computedSumText = computed(() => props.sumText || t("el.table.sumText"));
        const computedEmptyText = computed(() => {
          return props.emptyText || t("el.table.emptyText");
        });
        useKeyRender(table);
        return {
          ns,
          layout,
          store,
          handleHeaderFooterMousewheel,
          handleMouseLeave,
          tableId,
          tableSize,
          isHidden: isHidden2,
          isEmpty,
          renderExpanded,
          resizeProxyVisible,
          resizeState,
          isGroup,
          bodyWidth,
          tableBodyStyles,
          emptyBlockStyle,
          debouncedUpdateLayout,
          handleFixedMousewheel,
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          doLayout,
          sort,
          t,
          setDragVisible,
          context: table,
          computedSumText,
          computedEmptyText,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle,
          scrollBarRef,
          scrollTo,
          setScrollLeft,
          setScrollTop
        };
      }
    });
    const _hoisted_1$b = ["data-prefix"];
    const _hoisted_2$6 = {
      ref: "hiddenColumns",
      class: "hidden-columns"
    };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_hColgroup = resolveComponent("hColgroup");
      const _component_table_header = resolveComponent("table-header");
      const _component_table_body = resolveComponent("table-body");
      const _component_table_footer = resolveComponent("table-footer");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _directive_mousewheel = resolveDirective("mousewheel");
      return openBlock(), createElementBlock("div", {
        ref: "tableWrapper",
        class: normalizeClass([
          {
            [_ctx.ns.m("fit")]: _ctx.fit,
            [_ctx.ns.m("striped")]: _ctx.stripe,
            [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
            [_ctx.ns.m("hidden")]: _ctx.isHidden,
            [_ctx.ns.m("group")]: _ctx.isGroup,
            [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
            [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
            [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
            [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
            [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
            "has-footer": _ctx.showSummary
          },
          _ctx.ns.m(_ctx.tableSize),
          _ctx.className,
          _ctx.ns.b(),
          _ctx.ns.m(`layout-${_ctx.tableLayout}`)
        ]),
        style: normalizeStyle(_ctx.style),
        "data-prefix": _ctx.ns.namespace.value,
        onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("inner-wrapper")),
          style: normalizeStyle(_ctx.tableInnerStyle)
        }, [
          createBaseVNode("div", _hoisted_2$6, [
            renderSlot(_ctx.$slots, "default")
          ], 512),
          _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            ref: "headerWrapper",
            class: normalizeClass(_ctx.ns.e("header-wrapper"))
          }, [
            createBaseVNode("table", {
              ref: "tableHeader",
              class: normalizeClass(_ctx.ns.e("header")),
              style: normalizeStyle(_ctx.tableBodyStyles),
              border: "0",
              cellpadding: "0",
              cellspacing: "0"
            }, [
              createVNode(_component_hColgroup, {
                columns: _ctx.store.states.columns.value,
                "table-layout": _ctx.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              createVNode(_component_table_header, {
                ref: "tableHeaderRef",
                border: _ctx.border,
                "default-sort": _ctx.defaultSort,
                store: _ctx.store,
                onSetDragVisible: _ctx.setDragVisible
              }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
            ], 6)
          ], 2)), [
            [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
          ]) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            ref: "bodyWrapper",
            class: normalizeClass(_ctx.ns.e("body-wrapper"))
          }, [
            createVNode(_component_el_scrollbar, {
              ref: "scrollBarRef",
              "view-style": _ctx.scrollbarViewStyle,
              "wrap-style": _ctx.scrollbarStyle,
              always: _ctx.scrollbarAlwaysOn
            }, {
              default: withCtx(() => [
                createBaseVNode("table", {
                  ref: "tableBody",
                  class: normalizeClass(_ctx.ns.e("body")),
                  cellspacing: "0",
                  cellpadding: "0",
                  border: "0",
                  style: normalizeStyle({
                    width: _ctx.bodyWidth,
                    tableLayout: _ctx.tableLayout
                  })
                }, [
                  createVNode(_component_hColgroup, {
                    columns: _ctx.store.states.columns.value,
                    "table-layout": _ctx.tableLayout
                  }, null, 8, ["columns", "table-layout"]),
                  _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                    key: 0,
                    ref: "tableHeaderRef",
                    class: normalizeClass(_ctx.ns.e("body-header")),
                    border: _ctx.border,
                    "default-sort": _ctx.defaultSort,
                    store: _ctx.store,
                    onSetDragVisible: _ctx.setDragVisible
                  }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                  createVNode(_component_table_body, {
                    context: _ctx.context,
                    highlight: _ctx.highlightCurrentRow,
                    "row-class-name": _ctx.rowClassName,
                    "tooltip-effect": _ctx.tooltipEffect,
                    "tooltip-options": _ctx.tooltipOptions,
                    "row-style": _ctx.rowStyle,
                    store: _ctx.store,
                    stripe: _ctx.stripe
                  }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                  _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                    key: 1,
                    class: normalizeClass(_ctx.ns.e("body-footer")),
                    border: _ctx.border,
                    "default-sort": _ctx.defaultSort,
                    store: _ctx.store,
                    "sum-text": _ctx.computedSumText,
                    "summary-method": _ctx.summaryMethod
                  }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                ], 6),
                _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "emptyBlock",
                  style: normalizeStyle(_ctx.emptyBlockStyle),
                  class: normalizeClass(_ctx.ns.e("empty-block"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(_ctx.ns.e("empty-text"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                    ])
                  ], 2)
                ], 6)) : createCommentVNode("v-if", true),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  ref: "appendWrapper",
                  class: normalizeClass(_ctx.ns.e("append-wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["view-style", "wrap-style", "always"])
          ], 2),
          _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
            key: 1,
            ref: "footerWrapper",
            class: normalizeClass(_ctx.ns.e("footer-wrapper"))
          }, [
            createBaseVNode("table", {
              class: normalizeClass(_ctx.ns.e("footer")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: normalizeStyle(_ctx.tableBodyStyles)
            }, [
              createVNode(_component_hColgroup, {
                columns: _ctx.store.states.columns.value,
                "table-layout": _ctx.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              createVNode(_component_table_footer, {
                border: _ctx.border,
                "default-sort": _ctx.defaultSort,
                store: _ctx.store,
                "sum-text": _ctx.computedSumText,
                "summary-method": _ctx.summaryMethod
              }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
            ], 6)
          ], 2)), [
            [vShow, !_ctx.isEmpty],
            [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
          ]) : createCommentVNode("v-if", true),
          _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(_ctx.ns.e("border-left-patch"))
          }, null, 2)) : createCommentVNode("v-if", true)
        ], 6),
        withDirectives(createBaseVNode("div", {
          ref: "resizeProxy",
          class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
        }, null, 2), [
          [vShow, _ctx.resizeProxyVisible]
        ])
      ], 46, _hoisted_1$b);
    }
    var Table = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$1], ["__file", "table.vue"]]);
    const defaultClassNames = {
      selection: "table-column--selection",
      expand: "table__expand-column"
    };
    const cellStarts = {
      default: {
        order: ""
      },
      selection: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
      },
      expand: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
      },
      index: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
      }
    };
    const getDefaultClassName = (type) => {
      return defaultClassNames[type] || "";
    };
    const cellForced = {
      selection: {
        renderHeader({ store, column }) {
          function isDisabled() {
            return store.states.data.value && store.states.data.value.length === 0;
          }
          return h$1(ElCheckbox, {
            disabled: isDisabled(),
            size: store.states.tableSize.value,
            indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
            "onUpdate:modelValue": store.toggleAllSelection,
            modelValue: store.states.isAllSelected.value,
            ariaLabel: column.label
          });
        },
        renderCell({
          row,
          column,
          store,
          $index
        }) {
          return h$1(ElCheckbox, {
            disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
            size: store.states.tableSize.value,
            onChange: () => {
              store.commit("rowSelectedChanged", row);
            },
            onClick: (event) => event.stopPropagation(),
            modelValue: store.isSelected(row),
            ariaLabel: column.label
          });
        },
        sortable: false,
        resizable: false
      },
      index: {
        renderHeader({ column }) {
          return column.label || "#";
        },
        renderCell({
          column,
          $index
        }) {
          let i = $index + 1;
          const index = column.index;
          if (typeof index === "number") {
            i = $index + index;
          } else if (typeof index === "function") {
            i = index($index);
          }
          return h$1("div", {}, [i]);
        },
        sortable: false
      },
      expand: {
        renderHeader({ column }) {
          return column.label || "";
        },
        renderCell({
          row,
          store,
          expanded
        }) {
          const { ns } = store;
          const classes = [ns.e("expand-icon")];
          if (expanded) {
            classes.push(ns.em("expand-icon", "expanded"));
          }
          const callback = function(e) {
            e.stopPropagation();
            store.toggleRowExpansion(row);
          };
          return h$1("div", {
            class: classes,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, null, {
                  default: () => {
                    return [h$1(arrow_right_default)];
                  }
                })
              ];
            }
          });
        },
        sortable: false,
        resizable: false
      }
    };
    function defaultRenderCell({
      row,
      column,
      $index
    }) {
      var _a2;
      const property2 = column.property;
      const value = property2 && getProp(row, property2).value;
      if (column && column.formatter) {
        return column.formatter(row, column, value, $index);
      }
      return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
    }
    function treeCellPrefix({
      row,
      treeNode,
      store
    }, createPlaceholder = false) {
      const { ns } = store;
      if (!treeNode) {
        if (createPlaceholder) {
          return [
            h$1("span", {
              class: ns.e("placeholder")
            })
          ];
        }
        return null;
      }
      const ele = [];
      const callback = function(e) {
        e.stopPropagation();
        if (treeNode.loading) {
          return;
        }
        store.loadOrToggle(row);
      };
      if (treeNode.indent) {
        ele.push(h$1("span", {
          class: ns.e("indent"),
          style: { "padding-left": `${treeNode.indent}px` }
        }));
      }
      if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
        const expandClasses = [
          ns.e("expand-icon"),
          treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
        ];
        let icon = arrow_right_default;
        if (treeNode.loading) {
          icon = loading_default;
        }
        ele.push(h$1("div", {
          class: expandClasses,
          onClick: callback
        }, {
          default: () => {
            return [
              h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
                default: () => [h$1(icon)]
              })
            ];
          }
        }));
      } else {
        ele.push(h$1("span", {
          class: ns.e("placeholder")
        }));
      }
      return ele;
    }
    function getAllAliases(props, aliases) {
      return props.reduce((prev, cur) => {
        prev[cur] = cur;
        return prev;
      }, aliases);
    }
    function useWatcher(owner, props_) {
      const instance = getCurrentInstance();
      const registerComplexWatchers = () => {
        const props = ["fixed"];
        const aliases = {
          realWidth: "width",
          realMinWidth: "minWidth"
        };
        const allAliases = getAllAliases(props, aliases);
        Object.keys(allAliases).forEach((key) => {
          const columnKey = aliases[key];
          if (hasOwn(props_, columnKey)) {
            watch(() => props_[columnKey], (newVal) => {
              let value = newVal;
              if (columnKey === "width" && key === "realWidth") {
                value = parseWidth(newVal);
              }
              if (columnKey === "minWidth" && key === "realMinWidth") {
                value = parseMinWidth(newVal);
              }
              instance.columnConfig.value[columnKey] = value;
              instance.columnConfig.value[key] = value;
              const updateColumns = columnKey === "fixed";
              owner.value.store.scheduleLayout(updateColumns);
            });
          }
        });
      };
      const registerNormalWatchers = () => {
        const props = [
          "label",
          "filters",
          "filterMultiple",
          "filteredValue",
          "sortable",
          "index",
          "formatter",
          "className",
          "labelClassName",
          "filterClassName",
          "showOverflowTooltip"
        ];
        const aliases = {
          property: "prop",
          align: "realAlign",
          headerAlign: "realHeaderAlign"
        };
        const allAliases = getAllAliases(props, aliases);
        Object.keys(allAliases).forEach((key) => {
          const columnKey = aliases[key];
          if (hasOwn(props_, columnKey)) {
            watch(() => props_[columnKey], (newVal) => {
              instance.columnConfig.value[key] = newVal;
            });
          }
        });
      };
      return {
        registerComplexWatchers,
        registerNormalWatchers
      };
    }
    function useRender(props, slots, owner) {
      const instance = getCurrentInstance();
      const columnId = ref("");
      const isSubColumn = ref(false);
      const realAlign = ref();
      const realHeaderAlign = ref();
      const ns = useNamespace("table");
      watchEffect(() => {
        realAlign.value = props.align ? `is-${props.align}` : null;
        realAlign.value;
      });
      watchEffect(() => {
        realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
        realHeaderAlign.value;
      });
      const columnOrTableParent = computed(() => {
        let parent = instance.vnode.vParent || instance.parent;
        while (parent && !parent.tableId && !parent.columnId) {
          parent = parent.vnode.vParent || parent.parent;
        }
        return parent;
      });
      const hasTreeColumn = computed(() => {
        const { store } = instance.parent;
        if (!store)
          return false;
        const { treeData } = store.states;
        const treeDataValue = treeData.value;
        return treeDataValue && Object.keys(treeDataValue).length > 0;
      });
      const realWidth = ref(parseWidth(props.width));
      const realMinWidth = ref(parseMinWidth(props.minWidth));
      const setColumnWidth = (column) => {
        if (realWidth.value)
          column.width = realWidth.value;
        if (realMinWidth.value) {
          column.minWidth = realMinWidth.value;
        }
        if (!realWidth.value && realMinWidth.value) {
          column.width = void 0;
        }
        if (!column.minWidth) {
          column.minWidth = 80;
        }
        column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
        return column;
      };
      const setColumnForcedProps = (column) => {
        const type = column.type;
        const source = cellForced[type] || {};
        Object.keys(source).forEach((prop) => {
          const value = source[prop];
          if (prop !== "className" && value !== void 0) {
            column[prop] = value;
          }
        });
        const className = getDefaultClassName(type);
        if (className) {
          const forceClass = `${unref(ns.namespace)}-${className}`;
          column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
        }
        return column;
      };
      const checkSubColumn = (children) => {
        if (Array.isArray(children)) {
          children.forEach((child) => check(child));
        } else {
          check(children);
        }
        function check(item) {
          var _a2;
          if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
            item.vParent = instance;
          }
        }
      };
      const setColumnRenders = (column) => {
        if (props.renderHeader)
          ;
        else if (column.type !== "selection") {
          column.renderHeader = (scope) => {
            instance.columnConfig.value["label"];
            return renderSlot(slots, "header", scope, () => [column.label]);
          };
        }
        let originRenderCell = column.renderCell;
        if (column.type === "expand") {
          column.renderCell = (data) => h$1("div", {
            class: "cell"
          }, [originRenderCell(data)]);
          owner.value.renderExpanded = (data) => {
            return slots.default ? slots.default(data) : slots.default;
          };
        } else {
          originRenderCell = originRenderCell || defaultRenderCell;
          column.renderCell = (data) => {
            let children = null;
            if (slots.default) {
              const vnodes = slots.default(data);
              children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
            } else {
              children = originRenderCell(data);
            }
            const { columns } = owner.value.store.states;
            const firstUserColumnIndex = columns.value.findIndex((item) => item.type === "default");
            const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === firstUserColumnIndex;
            const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
            const props2 = {
              class: "cell",
              style: {}
            };
            if (column.showOverflowTooltip) {
              props2.class = `${props2.class} ${unref(ns.namespace)}-tooltip`;
              props2.style = {
                width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
              };
            }
            checkSubColumn(children);
            return h$1("div", props2, [prefix, children]);
          };
        }
        return column;
      };
      const getPropsData = (...propsKey) => {
        return propsKey.reduce((prev, cur) => {
          if (Array.isArray(cur)) {
            cur.forEach((key) => {
              prev[key] = props[key];
            });
          }
          return prev;
        }, {});
      };
      const getColumnElIndex = (children, child) => {
        return Array.prototype.indexOf.call(children, child);
      };
      const updateColumnOrder = () => {
        owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
      };
      return {
        columnId,
        realAlign,
        isSubColumn,
        realHeaderAlign,
        columnOrTableParent,
        setColumnWidth,
        setColumnForcedProps,
        setColumnRenders,
        getPropsData,
        getColumnElIndex,
        updateColumnOrder
      };
    }
    var defaultProps = {
      type: {
        type: String,
        default: "default"
      },
      label: String,
      className: String,
      labelClassName: String,
      property: String,
      prop: String,
      width: {
        type: [String, Number],
        default: ""
      },
      minWidth: {
        type: [String, Number],
        default: ""
      },
      renderHeader: Function,
      sortable: {
        type: [Boolean, String],
        default: false
      },
      sortMethod: Function,
      sortBy: [String, Function, Array],
      resizable: {
        type: Boolean,
        default: true
      },
      columnKey: String,
      align: String,
      headerAlign: String,
      showOverflowTooltip: {
        type: [Boolean, Object],
        default: void 0
      },
      fixed: [Boolean, String],
      formatter: Function,
      selectable: Function,
      reserveSelection: Boolean,
      filterMethod: Function,
      filteredValue: Array,
      filters: Array,
      filterPlacement: String,
      filterMultiple: {
        type: Boolean,
        default: true
      },
      filterClassName: String,
      index: [Number, Function],
      sortOrders: {
        type: Array,
        default: () => {
          return ["ascending", "descending", null];
        },
        validator: (val) => {
          return val.every((order) => ["ascending", "descending", null].includes(order));
        }
      }
    };
    let columnIdSeed = 1;
    var ElTableColumn$1 = /* @__PURE__ */ defineComponent({
      name: "ElTableColumn",
      components: {
        ElCheckbox
      },
      props: defaultProps,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const columnConfig = ref({});
        const owner = computed(() => {
          let parent2 = instance.parent;
          while (parent2 && !parent2.tableId) {
            parent2 = parent2.parent;
          }
          return parent2;
        });
        const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props);
        const {
          columnId,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          realAlign,
          updateColumnOrder
        } = useRender(props, slots, owner);
        const parent = columnOrTableParent.value;
        columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
        onBeforeMount(() => {
          isSubColumn.value = owner.value !== parent;
          const type = props.type || "default";
          const sortable = props.sortable === "" ? true : props.sortable;
          const showOverflowTooltip = isUndefined(props.showOverflowTooltip) ? parent.props.showOverflowTooltip : props.showOverflowTooltip;
          const defaults = {
            ...cellStarts[type],
            id: columnId.value,
            type,
            property: props.prop || props.property,
            align: realAlign,
            headerAlign: realHeaderAlign,
            showOverflowTooltip,
            filterable: props.filters || props.filterMethod,
            filteredValue: [],
            filterPlacement: "",
            filterClassName: "",
            isColumnGroup: false,
            isSubColumn: false,
            filterOpened: false,
            sortable,
            index: props.index,
            rawColumnKey: instance.vnode.key
          };
          const basicProps = [
            "columnKey",
            "label",
            "className",
            "labelClassName",
            "type",
            "renderHeader",
            "formatter",
            "fixed",
            "resizable"
          ];
          const sortProps = ["sortMethod", "sortBy", "sortOrders"];
          const selectProps = ["selectable", "reserveSelection"];
          const filterProps = [
            "filterMethod",
            "filters",
            "filterMultiple",
            "filterOpened",
            "filteredValue",
            "filterPlacement",
            "filterClassName"
          ];
          let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
          column = mergeOptions(defaults, column);
          const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
          column = chains(column);
          columnConfig.value = column;
          registerNormalWatchers();
          registerComplexWatchers();
        });
        onMounted(() => {
          var _a2;
          const parent2 = columnOrTableParent.value;
          const children = isSubColumn.value ? parent2.vnode.el.children : (_a2 = parent2.refs.hiddenColumns) == null ? void 0 : _a2.children;
          const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
          columnConfig.value.getColumnIndex = getColumnIndex;
          const columnIndex = getColumnIndex();
          columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null, updateColumnOrder);
        });
        onBeforeUnmount(() => {
          owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null, updateColumnOrder);
        });
        instance.columnId = columnId.value;
        instance.columnConfig = columnConfig;
        return;
      },
      render() {
        var _a2, _b, _c;
        try {
          const renderDefault = (_b = (_a2 = this.$slots).default) == null ? void 0 : _b.call(_a2, {
            row: {},
            column: {},
            $index: -1
          });
          const children = [];
          if (Array.isArray(renderDefault)) {
            for (const childNode of renderDefault) {
              if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                children.push(childNode);
              } else if (childNode.type === Fragment && Array.isArray(childNode.children)) {
                childNode.children.forEach((vnode2) => {
                  if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString$1(vnode2 == null ? void 0 : vnode2.children)) {
                    children.push(vnode2);
                  }
                });
              }
            }
          }
          const vnode = h$1("div", children);
          return vnode;
        } catch (e) {
          return h$1("div", []);
        }
      }
    });
    const ElTable = withInstall(Table, {
      TableColumn: ElTableColumn$1
    });
    const ElTableColumn = withNoopInstall(ElTableColumn$1);
    const textProps = buildProps({
      type: {
        type: String,
        values: ["primary", "success", "info", "warning", "danger", ""],
        default: ""
      },
      size: {
        type: String,
        values: componentSizes,
        default: ""
      },
      truncated: {
        type: Boolean
      },
      lineClamp: {
        type: [String, Number]
      },
      tag: {
        type: String,
        default: "span"
      }
    });
    const __default__$6 = /* @__PURE__ */ defineComponent({
      name: "ElText"
    });
    const _sfc_main$d = /* @__PURE__ */ defineComponent({
      ...__default__$6,
      props: textProps,
      setup(__props) {
        const props = __props;
        const textSize = useFormSize();
        const ns = useNamespace("text");
        const textKls = computed(() => [
          ns.b(),
          ns.m(props.type),
          ns.m(textSize.value),
          ns.is("truncated", props.truncated),
          ns.is("line-clamp", !isUndefined(props.lineClamp))
        ]);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass(unref(textKls)),
            style: normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    });
    var Text = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "text.vue"]]);
    const ElText = withInstall(Text);
    const Timeline = /* @__PURE__ */ defineComponent({
      name: "ElTimeline",
      setup(_2, { slots }) {
        const ns = useNamespace("timeline");
        provide("timeline", slots);
        return () => {
          return h$1("ul", { class: [ns.b()] }, [renderSlot(slots, "default")]);
        };
      }
    });
    const timelineItemProps = buildProps({
      timestamp: {
        type: String,
        default: ""
      },
      hideTimestamp: {
        type: Boolean,
        default: false
      },
      center: {
        type: Boolean,
        default: false
      },
      placement: {
        type: String,
        values: ["top", "bottom"],
        default: "bottom"
      },
      type: {
        type: String,
        values: ["primary", "success", "warning", "danger", "info"],
        default: ""
      },
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        values: ["normal", "large"],
        default: "normal"
      },
      icon: {
        type: iconPropType
      },
      hollow: {
        type: Boolean,
        default: false
      }
    });
    const __default__$5 = /* @__PURE__ */ defineComponent({
      name: "ElTimelineItem"
    });
    const _sfc_main$c = /* @__PURE__ */ defineComponent({
      ...__default__$5,
      props: timelineItemProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("timeline-item");
        const defaultNodeKls = computed(() => [
          ns.e("node"),
          ns.em("node", props.size || ""),
          ns.em("node", props.type || ""),
          ns.is("hollow", props.hollow)
        ]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("li", {
            class: normalizeClass([unref(ns).b(), { [unref(ns).e("center")]: _ctx.center }])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns).e("tail"))
            }, null, 2),
            !_ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(defaultNodeKls)),
              style: normalizeStyle({
                backgroundColor: _ctx.color
              })
            }, [
              _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("icon"))
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true)
            ], 6)) : createCommentVNode("v-if", true),
            _ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns).e("dot"))
            }, [
              renderSlot(_ctx.$slots, "dot")
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns).e("wrapper"))
            }, [
              !_ctx.hideTimestamp && _ctx.placement === "top" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns).e("timestamp"), unref(ns).is("top")])
              }, toDisplayString(_ctx.timestamp), 3)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              !_ctx.hideTimestamp && _ctx.placement === "bottom" ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass([unref(ns).e("timestamp"), unref(ns).is("bottom")])
              }, toDisplayString(_ctx.timestamp), 3)) : createCommentVNode("v-if", true)
            ], 2)
          ], 2);
        };
      }
    });
    var TimelineItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "timeline-item.vue"]]);
    const ElTimeline = withInstall(Timeline, {
      TimelineItem
    });
    const ElTimelineItem = withNoopInstall(TimelineItem);
    const uploadContextKey = Symbol("uploadContextKey");
    const SCOPE$1 = "ElUpload";
    class UploadAjaxError extends Error {
      constructor(message2, status, method, url) {
        super(message2);
        this.name = "UploadAjaxError";
        this.status = status;
        this.method = method;
        this.url = url;
      }
    }
    function getError(action, option, xhr) {
      let msg;
      if (xhr.response) {
        msg = `${xhr.response.error || xhr.response}`;
      } else if (xhr.responseText) {
        msg = `${xhr.responseText}`;
      } else {
        msg = `fail to ${option.method} ${action} ${xhr.status}`;
      }
      return new UploadAjaxError(msg, xhr.status, option.method, action);
    }
    function getBody(xhr) {
      const text = xhr.responseText || xhr.response;
      if (!text) {
        return text;
      }
      try {
        return JSON.parse(text);
      } catch (e) {
        return text;
      }
    }
    const ajaxUpload = (option) => {
      if (typeof XMLHttpRequest === "undefined")
        throwError(SCOPE$1, "XMLHttpRequest is undefined");
      const xhr = new XMLHttpRequest();
      const action = option.action;
      if (xhr.upload) {
        xhr.upload.addEventListener("progress", (evt) => {
          const progressEvt = evt;
          progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
          option.onProgress(progressEvt);
        });
      }
      const formData = new FormData();
      if (option.data) {
        for (const [key, value] of Object.entries(option.data)) {
          if (isArray$1(value) && value.length)
            formData.append(key, ...value);
          else
            formData.append(key, value);
        }
      }
      formData.append(option.filename, option.file, option.file.name);
      xhr.addEventListener("error", () => {
        option.onError(getError(action, option, xhr));
      });
      xhr.addEventListener("load", () => {
        if (xhr.status < 200 || xhr.status >= 300) {
          return option.onError(getError(action, option, xhr));
        }
        option.onSuccess(getBody(xhr));
      });
      xhr.open(option.method, action, true);
      if (option.withCredentials && "withCredentials" in xhr) {
        xhr.withCredentials = true;
      }
      const headers = option.headers || {};
      if (headers instanceof Headers) {
        headers.forEach((value, key) => xhr.setRequestHeader(key, value));
      } else {
        for (const [key, value] of Object.entries(headers)) {
          if (isNil(value))
            continue;
          xhr.setRequestHeader(key, String(value));
        }
      }
      xhr.send(formData);
      return xhr;
    };
    const uploadListTypes = ["text", "picture", "picture-card"];
    let fileId = 1;
    const genFileId = () => Date.now() + fileId++;
    const uploadBaseProps = buildProps({
      action: {
        type: String,
        default: "#"
      },
      headers: {
        type: definePropType(Object)
      },
      method: {
        type: String,
        default: "post"
      },
      data: {
        type: definePropType([Object, Function, Promise]),
        default: () => mutable({})
      },
      multiple: {
        type: Boolean,
        default: false
      },
      name: {
        type: String,
        default: "file"
      },
      drag: {
        type: Boolean,
        default: false
      },
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      accept: {
        type: String,
        default: ""
      },
      fileList: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        values: uploadListTypes,
        default: "text"
      },
      httpRequest: {
        type: definePropType(Function),
        default: ajaxUpload
      },
      disabled: Boolean,
      limit: Number
    });
    const uploadProps = buildProps({
      ...uploadBaseProps,
      beforeUpload: {
        type: definePropType(Function),
        default: NOOP
      },
      beforeRemove: {
        type: definePropType(Function)
      },
      onRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      onChange: {
        type: definePropType(Function),
        default: NOOP
      },
      onPreview: {
        type: definePropType(Function),
        default: NOOP
      },
      onSuccess: {
        type: definePropType(Function),
        default: NOOP
      },
      onProgress: {
        type: definePropType(Function),
        default: NOOP
      },
      onError: {
        type: definePropType(Function),
        default: NOOP
      },
      onExceed: {
        type: definePropType(Function),
        default: NOOP
      }
    });
    const uploadListProps = buildProps({
      files: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      disabled: {
        type: Boolean,
        default: false
      },
      handlePreview: {
        type: definePropType(Function),
        default: NOOP
      },
      listType: {
        type: String,
        values: uploadListTypes,
        default: "text"
      }
    });
    const uploadListEmits = {
      remove: (file) => !!file
    };
    const _hoisted_1$a = ["onKeydown"];
    const _hoisted_2$5 = ["src"];
    const _hoisted_3$3 = ["onClick"];
    const _hoisted_4$2 = ["title"];
    const _hoisted_5$2 = ["onClick"];
    const _hoisted_6$1 = ["onClick"];
    const __default__$4 = /* @__PURE__ */ defineComponent({
      name: "ElUploadList"
    });
    const _sfc_main$b = /* @__PURE__ */ defineComponent({
      ...__default__$4,
      props: uploadListProps,
      emits: uploadListEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const { t } = useLocale();
        const nsUpload = useNamespace("upload");
        const nsIcon = useNamespace("icon");
        const nsList = useNamespace("list");
        const disabled = useFormDisabled();
        const focusing = ref(false);
        const containerKls = computed(() => [
          nsUpload.b("list"),
          nsUpload.bm("list", props.listType),
          nsUpload.is("disabled", props.disabled)
        ]);
        const handleRemove = (file) => {
          emit2("remove", file);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(TransitionGroup, {
            tag: "ul",
            class: normalizeClass(unref(containerKls)),
            name: unref(nsList).b()
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
                return openBlock(), createElementBlock("li", {
                  key: file.uid || file.name,
                  class: normalizeClass([
                    unref(nsUpload).be("list", "item"),
                    unref(nsUpload).is(file.status),
                    { focusing: focusing.value }
                  ]),
                  tabindex: "0",
                  onKeydown: withKeys(($event) => !unref(disabled) && handleRemove(file), ["delete"]),
                  onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
                  onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
                  onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
                }, [
                  renderSlot(_ctx.$slots, "default", { file }, () => [
                    _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                      src: file.url,
                      alt: ""
                    }, null, 10, _hoisted_2$5)) : createCommentVNode("v-if", true),
                    file.status === "uploading" || _ctx.listType !== "picture-card" ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                    }, [
                      createBaseVNode("a", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                        onClick: withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("document"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(document_default))
                          ]),
                          _: 1
                        }, 8, ["class"]),
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-file-name")),
                          title: file.name
                        }, toDisplayString(file.name), 11, _hoisted_4$2)
                      ], 10, _hoisted_3$3),
                      file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                        key: 0,
                        type: _ctx.listType === "picture-card" ? "circle" : "line",
                        "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                        percentage: Number(file.percentage),
                        style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                      }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    createBaseVNode("label", {
                      class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                    }, [
                      _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_check_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(check_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2),
                    !unref(disabled) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass(unref(nsIcon).m("close")),
                      onClick: ($event) => handleRemove(file)
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(close_default))
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                    createCommentVNode(" This is a bug which needs to be fixed "),
                    createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                    !unref(disabled) ? (openBlock(), createElementBlock("i", {
                      key: 3,
                      class: normalizeClass(unref(nsIcon).m("close-tip"))
                    }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                    _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                      key: 4,
                      class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                        onClick: ($event) => _ctx.handlePreview(file)
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("zoom-in"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, _hoisted_5$2),
                      !unref(disabled) ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                        onClick: ($event) => handleRemove(file)
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("delete"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(delete_default))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, _hoisted_6$1)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true)
                  ])
                ], 42, _hoisted_1$a);
              }), 128)),
              renderSlot(_ctx.$slots, "append")
            ]),
            _: 3
          }, 8, ["class", "name"]);
        };
      }
    });
    var UploadList = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "upload-list.vue"]]);
    const uploadDraggerProps = buildProps({
      disabled: {
        type: Boolean,
        default: false
      }
    });
    const uploadDraggerEmits = {
      file: (file) => isArray$1(file)
    };
    const _hoisted_1$9 = ["onDrop", "onDragover"];
    const COMPONENT_NAME = "ElUploadDrag";
    const __default__$3 = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME
    });
    const _sfc_main$a = /* @__PURE__ */ defineComponent({
      ...__default__$3,
      props: uploadDraggerProps,
      emits: uploadDraggerEmits,
      setup(__props, { emit: emit2 }) {
        const uploaderContext = inject(uploadContextKey);
        if (!uploaderContext) {
          throwError(COMPONENT_NAME, "usage: <el-upload><el-upload-dragger /></el-upload>");
        }
        const ns = useNamespace("upload");
        const dragover = ref(false);
        const disabled = useFormDisabled();
        const onDrop = (e) => {
          if (disabled.value)
            return;
          dragover.value = false;
          e.stopPropagation();
          const files = Array.from(e.dataTransfer.files);
          const accept = uploaderContext.accept.value;
          if (!accept) {
            emit2("file", files);
            return;
          }
          const filesFiltered = files.filter((file) => {
            const { type, name } = file;
            const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
            const baseType = type.replace(/\/.*$/, "");
            return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
              if (acceptedType.startsWith(".")) {
                return extension === acceptedType;
              }
              if (/\/\*$/.test(acceptedType)) {
                return baseType === acceptedType.replace(/\/\*$/, "");
              }
              if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
                return type === acceptedType;
              }
              return false;
            });
          });
          emit2("file", filesFiltered);
        };
        const onDragover = () => {
          if (!disabled.value)
            dragover.value = true;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns).b("dragger"), unref(ns).is("dragover", dragover.value)]),
            onDrop: withModifiers(onDrop, ["prevent"]),
            onDragover: withModifiers(onDragover, ["prevent"]),
            onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 42, _hoisted_1$9);
        };
      }
    });
    var UploadDragger = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__file", "upload-dragger.vue"]]);
    const uploadContentProps = buildProps({
      ...uploadBaseProps,
      beforeUpload: {
        type: definePropType(Function),
        default: NOOP
      },
      onRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      onStart: {
        type: definePropType(Function),
        default: NOOP
      },
      onSuccess: {
        type: definePropType(Function),
        default: NOOP
      },
      onProgress: {
        type: definePropType(Function),
        default: NOOP
      },
      onError: {
        type: definePropType(Function),
        default: NOOP
      },
      onExceed: {
        type: definePropType(Function),
        default: NOOP
      }
    });
    const _hoisted_1$8 = ["onKeydown"];
    const _hoisted_2$4 = ["name", "multiple", "accept"];
    const __default__$2 = /* @__PURE__ */ defineComponent({
      name: "ElUploadContent",
      inheritAttrs: false
    });
    const _sfc_main$9 = /* @__PURE__ */ defineComponent({
      ...__default__$2,
      props: uploadContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("upload");
        const disabled = useFormDisabled();
        const requests = shallowRef({});
        const inputRef = shallowRef();
        const uploadFiles = (files) => {
          if (files.length === 0)
            return;
          const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
          if (limit && fileList.length + files.length > limit) {
            onExceed(files, fileList);
            return;
          }
          if (!multiple) {
            files = files.slice(0, 1);
          }
          for (const file of files) {
            const rawFile = file;
            rawFile.uid = genFileId();
            onStart(rawFile);
            if (autoUpload)
              upload(rawFile);
          }
        };
        const upload = async (rawFile) => {
          inputRef.value.value = "";
          if (!props.beforeUpload) {
            return doUpload(rawFile);
          }
          let hookResult;
          let beforeData = {};
          try {
            const originData = props.data;
            const beforeUploadPromise = props.beforeUpload(rawFile);
            beforeData = isPlainObject$1(props.data) ? cloneDeep(props.data) : props.data;
            hookResult = await beforeUploadPromise;
            if (isPlainObject$1(props.data) && isEqual(originData, beforeData)) {
              beforeData = cloneDeep(props.data);
            }
          } catch (e) {
            hookResult = false;
          }
          if (hookResult === false) {
            props.onRemove(rawFile);
            return;
          }
          let file = rawFile;
          if (hookResult instanceof Blob) {
            if (hookResult instanceof File) {
              file = hookResult;
            } else {
              file = new File([hookResult], rawFile.name, {
                type: rawFile.type
              });
            }
          }
          doUpload(Object.assign(file, {
            uid: rawFile.uid
          }), beforeData);
        };
        const resolveData = async (data, rawFile) => {
          if (isFunction$2(data)) {
            return data(rawFile);
          }
          return data;
        };
        const doUpload = async (rawFile, beforeData) => {
          const {
            headers,
            data,
            method,
            withCredentials,
            name: filename,
            action,
            onProgress,
            onSuccess,
            onError,
            httpRequest
          } = props;
          try {
            beforeData = await resolveData(beforeData != null ? beforeData : data, rawFile);
          } catch (e) {
            props.onRemove(rawFile);
            return;
          }
          const { uid: uid2 } = rawFile;
          const options = {
            headers: headers || {},
            withCredentials,
            file: rawFile,
            data: beforeData,
            method,
            filename,
            action,
            onProgress: (evt) => {
              onProgress(evt, rawFile);
            },
            onSuccess: (res) => {
              onSuccess(res, rawFile);
              delete requests.value[uid2];
            },
            onError: (err) => {
              onError(err, rawFile);
              delete requests.value[uid2];
            }
          };
          const request = httpRequest(options);
          requests.value[uid2] = request;
          if (request instanceof Promise) {
            request.then(options.onSuccess, options.onError);
          }
        };
        const handleChange = (e) => {
          const files = e.target.files;
          if (!files)
            return;
          uploadFiles(Array.from(files));
        };
        const handleClick = () => {
          if (!disabled.value) {
            inputRef.value.value = "";
            inputRef.value.click();
          }
        };
        const handleKeydown = () => {
          handleClick();
        };
        const abort = (file) => {
          const _reqs = entriesOf(requests.value).filter(file ? ([uid2]) => String(file.uid) === uid2 : () => true);
          _reqs.forEach(([uid2, req]) => {
            if (req instanceof XMLHttpRequest)
              req.abort();
            delete requests.value[uid2];
          });
        };
        expose({
          abort,
          upload
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.listType), unref(ns).is("drag", _ctx.drag)]),
            tabindex: "0",
            onClick: handleClick,
            onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
          }, [
            _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
              key: 0,
              disabled: unref(disabled),
              onFile: uploadFiles
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
            createBaseVNode("input", {
              ref_key: "inputRef",
              ref: inputRef,
              class: normalizeClass(unref(ns).e("input")),
              name: _ctx.name,
              multiple: _ctx.multiple,
              accept: _ctx.accept,
              type: "file",
              onChange: handleChange,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_2$4)
          ], 42, _hoisted_1$8);
        };
      }
    });
    var UploadContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "upload-content.vue"]]);
    const SCOPE = "ElUpload";
    const revokeFileObjectURL = (file) => {
      var _a2;
      if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
        URL.revokeObjectURL(file.url);
      }
    };
    const useHandlers = (props, uploadRef) => {
      const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
      const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
      function abort(file) {
        var _a2;
        (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
      }
      function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
        uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
      }
      const handleError2 = (err, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        console.error(err);
        file.status = "fail";
        uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
        props.onError(err, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      };
      const handleProgress = (evt, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        props.onProgress(evt, file, uploadFiles.value);
        file.status = "uploading";
        file.percentage = Math.round(evt.percent);
      };
      const handleSuccess = (response, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        file.status = "success";
        file.response = response;
        props.onSuccess(response, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      };
      const handleStart = (file) => {
        if (isNil(file.uid))
          file.uid = genFileId();
        const uploadFile = {
          name: file.name,
          percentage: 0,
          status: "ready",
          size: file.size,
          raw: file,
          uid: file.uid
        };
        if (props.listType === "picture-card" || props.listType === "picture") {
          try {
            uploadFile.url = URL.createObjectURL(file);
          } catch (err) {
            debugWarn(SCOPE, err.message);
            props.onError(err, uploadFile, uploadFiles.value);
          }
        }
        uploadFiles.value = [...uploadFiles.value, uploadFile];
        props.onChange(uploadFile, uploadFiles.value);
      };
      const handleRemove = async (file) => {
        const uploadFile = file instanceof File ? getFile(file) : file;
        if (!uploadFile)
          throwError(SCOPE, "file to be removed not found");
        const doRemove = (file2) => {
          abort(file2);
          const fileList = uploadFiles.value;
          fileList.splice(fileList.indexOf(file2), 1);
          props.onRemove(file2, fileList);
          revokeFileObjectURL(file2);
        };
        if (props.beforeRemove) {
          const before = await props.beforeRemove(uploadFile, uploadFiles.value);
          if (before !== false)
            doRemove(uploadFile);
        } else {
          doRemove(uploadFile);
        }
      };
      function submit() {
        uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
          var _a2;
          return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
        });
      }
      watch(() => props.listType, (val) => {
        if (val !== "picture-card" && val !== "picture") {
          return;
        }
        uploadFiles.value = uploadFiles.value.map((file) => {
          const { raw, url } = file;
          if (!url && raw) {
            try {
              file.url = URL.createObjectURL(raw);
            } catch (err) {
              props.onError(err, file, uploadFiles.value);
            }
          }
          return file;
        });
      });
      watch(uploadFiles, (files) => {
        for (const file of files) {
          file.uid || (file.uid = genFileId());
          file.status || (file.status = "success");
        }
      }, { immediate: true, deep: true });
      return {
        uploadFiles,
        abort,
        clearFiles,
        handleError: handleError2,
        handleProgress,
        handleStart,
        handleSuccess,
        handleRemove,
        submit,
        revokeFileObjectURL
      };
    };
    const __default__$1 = /* @__PURE__ */ defineComponent({
      name: "ElUpload"
    });
    const _sfc_main$8 = /* @__PURE__ */ defineComponent({
      ...__default__$1,
      props: uploadProps,
      setup(__props, { expose }) {
        const props = __props;
        const disabled = useFormDisabled();
        const uploadRef = shallowRef();
        const {
          abort,
          submit,
          clearFiles,
          uploadFiles,
          handleStart,
          handleError: handleError2,
          handleRemove,
          handleSuccess,
          handleProgress,
          revokeFileObjectURL: revokeFileObjectURL2
        } = useHandlers(props, uploadRef);
        const isPictureCard = computed(() => props.listType === "picture-card");
        const uploadContentProps2 = computed(() => ({
          ...props,
          fileList: uploadFiles.value,
          onStart: handleStart,
          onProgress: handleProgress,
          onSuccess: handleSuccess,
          onError: handleError2,
          onRemove: handleRemove
        }));
        onBeforeUnmount(() => {
          uploadFiles.value.forEach(revokeFileObjectURL2);
        });
        provide(uploadContextKey, {
          accept: toRef(props, "accept")
        });
        expose({
          abort,
          submit,
          clearFiles,
          handleStart,
          handleRemove
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", null, [
            unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
              key: 0,
              disabled: unref(disabled),
              "list-type": _ctx.listType,
              files: unref(uploadFiles),
              "handle-preview": _ctx.onPreview,
              onRemove: unref(handleRemove)
            }, createSlots({
              append: withCtx(() => [
                createVNode(UploadContent, mergeProps({
                  ref_key: "uploadRef",
                  ref: uploadRef
                }, unref(uploadContentProps2)), {
                  default: withCtx(() => [
                    _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                    !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16)
              ]),
              _: 2
            }, [
              _ctx.$slots.file ? {
                name: "default",
                fn: withCtx(({ file }) => [
                  renderSlot(_ctx.$slots, "file", { file })
                ])
              } : void 0
            ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
            !unref(isPictureCard) || unref(isPictureCard) && !_ctx.showFileList ? (openBlock(), createBlock(UploadContent, mergeProps({
              key: 1,
              ref_key: "uploadRef",
              ref: uploadRef
            }, unref(uploadContentProps2)), {
              default: withCtx(() => [
                _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16)) : createCommentVNode("v-if", true),
            _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "tip"),
            !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
              key: 3,
              disabled: unref(disabled),
              "list-type": _ctx.listType,
              files: unref(uploadFiles),
              "handle-preview": _ctx.onPreview,
              onRemove: unref(handleRemove)
            }, createSlots({ _: 2 }, [
              _ctx.$slots.file ? {
                name: "default",
                fn: withCtx(({ file }) => [
                  renderSlot(_ctx.$slots, "file", { file })
                ])
              } : void 0
            ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
          ]);
        };
      }
    });
    var Upload = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__file", "upload.vue"]]);
    const ElUpload = withInstall(Upload);
    function createLoadingComponent(options) {
      let afterLeaveTimer;
      const afterLeaveFlag = ref(false);
      const data = reactive({
        ...options,
        originalPosition: "",
        originalOverflow: "",
        visible: false
      });
      function setText(text) {
        data.text = text;
      }
      function destroySelf() {
        const target = data.parent;
        const ns = vm.ns;
        if (!target.vLoadingAddClassList) {
          let loadingNumber = target.getAttribute("loading-number");
          loadingNumber = Number.parseInt(loadingNumber) - 1;
          if (!loadingNumber) {
            removeClass(target, ns.bm("parent", "relative"));
            target.removeAttribute("loading-number");
          } else {
            target.setAttribute("loading-number", loadingNumber.toString());
          }
          removeClass(target, ns.bm("parent", "hidden"));
        }
        removeElLoadingChild();
        loadingInstance.unmount();
      }
      function removeElLoadingChild() {
        var _a2, _b;
        (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
      }
      function close() {
        var _a2;
        if (options.beforeClose && !options.beforeClose())
          return;
        afterLeaveFlag.value = true;
        clearTimeout(afterLeaveTimer);
        afterLeaveTimer = window.setTimeout(handleAfterLeave, 400);
        data.visible = false;
        (_a2 = options.closed) == null ? void 0 : _a2.call(options);
      }
      function handleAfterLeave() {
        if (!afterLeaveFlag.value)
          return;
        const target = data.parent;
        afterLeaveFlag.value = false;
        target.vLoadingAddClassList = void 0;
        destroySelf();
      }
      const elLoadingComponent = /* @__PURE__ */ defineComponent({
        name: "ElLoading",
        setup(_2, { expose }) {
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("loading");
          expose({
            ns,
            zIndex: zIndex2
          });
          return () => {
            const svg = data.spinner || data.svg;
            const spinner = h$1("svg", {
              class: "circular",
              viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50",
              ...svg ? { innerHTML: svg } : {}
            }, [
              h$1("circle", {
                class: "path",
                cx: "25",
                cy: "25",
                r: "20",
                fill: "none"
              })
            ]);
            const spinnerText = data.text ? h$1("p", { class: ns.b("text") }, [data.text]) : void 0;
            return h$1(Transition, {
              name: ns.b("fade"),
              onAfterLeave: handleAfterLeave
            }, {
              default: withCtx(() => [
                withDirectives(createVNode("div", {
                  style: {
                    backgroundColor: data.background || ""
                  },
                  class: [
                    ns.b("mask"),
                    data.customClass,
                    data.fullscreen ? "is-fullscreen" : ""
                  ]
                }, [
                  h$1("div", {
                    class: ns.b("spinner")
                  }, [spinner, spinnerText])
                ]), [[vShow, data.visible]])
              ])
            });
          };
        }
      });
      const loadingInstance = createApp(elLoadingComponent);
      const vm = loadingInstance.mount(document.createElement("div"));
      return {
        ...toRefs(data),
        setText,
        removeElLoadingChild,
        close,
        handleAfterLeave,
        vm,
        get $el() {
          return vm.$el;
        }
      };
    }
    let fullscreenInstance = void 0;
    const Loading = function(options = {}) {
      if (!isClient)
        return void 0;
      const resolved = resolveOptions(options);
      if (resolved.fullscreen && fullscreenInstance) {
        return fullscreenInstance;
      }
      const instance = createLoadingComponent({
        ...resolved,
        closed: () => {
          var _a2;
          (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
          if (resolved.fullscreen)
            fullscreenInstance = void 0;
        }
      });
      addStyle(resolved, resolved.parent, instance);
      addClassList(resolved, resolved.parent, instance);
      resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
      let loadingNumber = resolved.parent.getAttribute("loading-number");
      if (!loadingNumber) {
        loadingNumber = "1";
      } else {
        loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
      }
      resolved.parent.setAttribute("loading-number", loadingNumber);
      resolved.parent.appendChild(instance.$el);
      nextTick(() => instance.visible.value = resolved.visible);
      if (resolved.fullscreen) {
        fullscreenInstance = instance;
      }
      return instance;
    };
    const resolveOptions = (options) => {
      var _a2, _b, _c, _d;
      let target;
      if (isString$1(options.target)) {
        target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
      } else {
        target = options.target || document.body;
      }
      return {
        parent: target === document.body || options.body ? document.body : target,
        background: options.background || "",
        svg: options.svg || "",
        svgViewBox: options.svgViewBox || "",
        spinner: options.spinner || false,
        text: options.text || "",
        fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
        lock: (_c = options.lock) != null ? _c : false,
        customClass: options.customClass || "",
        visible: (_d = options.visible) != null ? _d : true,
        target
      };
    };
    const addStyle = async (options, parent, instance) => {
      const { nextZIndex } = instance.vm.zIndex || instance.vm._.exposed.zIndex;
      const maskStyle = {};
      if (options.fullscreen) {
        instance.originalPosition.value = getStyle(document.body, "position");
        instance.originalOverflow.value = getStyle(document.body, "overflow");
        maskStyle.zIndex = nextZIndex();
      } else if (options.parent === document.body) {
        instance.originalPosition.value = getStyle(document.body, "position");
        await nextTick();
        for (const property2 of ["top", "left"]) {
          const scroll = property2 === "top" ? "scrollTop" : "scrollLeft";
          maskStyle[property2] = `${options.target.getBoundingClientRect()[property2] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property2}`), 10)}px`;
        }
        for (const property2 of ["height", "width"]) {
          maskStyle[property2] = `${options.target.getBoundingClientRect()[property2]}px`;
        }
      } else {
        instance.originalPosition.value = getStyle(parent, "position");
      }
      for (const [key, value] of Object.entries(maskStyle)) {
        instance.$el.style[key] = value;
      }
    };
    const addClassList = (options, parent, instance) => {
      const ns = instance.vm.ns || instance.vm._.exposed.ns;
      if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
        addClass(parent, ns.bm("parent", "relative"));
      } else {
        removeClass(parent, ns.bm("parent", "relative"));
      }
      if (options.fullscreen && options.lock) {
        addClass(parent, ns.bm("parent", "hidden"));
      } else {
        removeClass(parent, ns.bm("parent", "hidden"));
      }
    };
    const INSTANCE_KEY = Symbol("ElLoading");
    const createInstance = (el, binding) => {
      var _a2, _b, _c, _d;
      const vm = binding.instance;
      const getBindingProp = (key) => isObject$1(binding.value) ? binding.value[key] : void 0;
      const resolveExpression = (key) => {
        const data = isString$1(key) && (vm == null ? void 0 : vm[key]) || key;
        if (data)
          return ref(data);
        else
          return data;
      };
      const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
      const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
      const options = {
        text: getProp2("text"),
        svg: getProp2("svg"),
        svgViewBox: getProp2("svgViewBox"),
        spinner: getProp2("spinner"),
        background: getProp2("background"),
        customClass: getProp2("customClass"),
        fullscreen,
        target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
        body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
        lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
      };
      el[INSTANCE_KEY] = {
        options,
        instance: Loading(options)
      };
    };
    const updateOptions = (newOptions, originalOptions) => {
      for (const key of Object.keys(originalOptions)) {
        if (isRef(originalOptions[key]))
          originalOptions[key].value = newOptions[key];
      }
    };
    const vLoading = {
      mounted(el, binding) {
        if (binding.value) {
          createInstance(el, binding);
        }
      },
      updated(el, binding) {
        const instance = el[INSTANCE_KEY];
        if (binding.oldValue !== binding.value) {
          if (binding.value && !binding.oldValue) {
            createInstance(el, binding);
          } else if (binding.value && binding.oldValue) {
            if (isObject$1(binding.value))
              updateOptions(binding.value, instance.options);
          } else {
            instance == null ? void 0 : instance.instance.close();
          }
        }
      },
      unmounted(el) {
        var _a2;
        (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
        el[INSTANCE_KEY] = null;
      }
    };
    const ElLoading = {
      install(app2) {
        app2.directive("loading", vLoading);
        app2.config.globalProperties.$loading = Loading;
      },
      directive: vLoading,
      service: Loading
    };
    const messageTypes = ["success", "info", "warning", "error"];
    const messageDefaults = mutable({
      customClass: "",
      center: false,
      dangerouslyUseHTMLString: false,
      duration: 3e3,
      icon: void 0,
      id: "",
      message: "",
      onClose: void 0,
      showClose: false,
      type: "info",
      offset: 16,
      zIndex: 0,
      grouping: false,
      repeatNum: 1,
      appendTo: isClient ? document.body : void 0
    });
    const messageProps = buildProps({
      customClass: {
        type: String,
        default: messageDefaults.customClass
      },
      center: {
        type: Boolean,
        default: messageDefaults.center
      },
      dangerouslyUseHTMLString: {
        type: Boolean,
        default: messageDefaults.dangerouslyUseHTMLString
      },
      duration: {
        type: Number,
        default: messageDefaults.duration
      },
      icon: {
        type: iconPropType,
        default: messageDefaults.icon
      },
      id: {
        type: String,
        default: messageDefaults.id
      },
      message: {
        type: definePropType([
          String,
          Object,
          Function
        ]),
        default: messageDefaults.message
      },
      onClose: {
        type: definePropType(Function),
        required: false
      },
      showClose: {
        type: Boolean,
        default: messageDefaults.showClose
      },
      type: {
        type: String,
        values: messageTypes,
        default: messageDefaults.type
      },
      offset: {
        type: Number,
        default: messageDefaults.offset
      },
      zIndex: {
        type: Number,
        default: messageDefaults.zIndex
      },
      grouping: {
        type: Boolean,
        default: messageDefaults.grouping
      },
      repeatNum: {
        type: Number,
        default: messageDefaults.repeatNum
      }
    });
    const messageEmits = {
      destroy: () => true
    };
    const instances = shallowReactive([]);
    const getInstance = (id) => {
      const idx = instances.findIndex((instance) => instance.id === id);
      const current = instances[idx];
      let prev;
      if (idx > 0) {
        prev = instances[idx - 1];
      }
      return { current, prev };
    };
    const getLastOffset = (id) => {
      const { prev } = getInstance(id);
      if (!prev)
        return 0;
      return prev.vm.exposed.bottom.value;
    };
    const getOffsetOrSpace = (id, offset) => {
      const idx = instances.findIndex((instance) => instance.id === id);
      return idx > 0 ? 20 : offset;
    };
    const _hoisted_1$7 = ["id"];
    const _hoisted_2$3 = ["innerHTML"];
    const __default__ = /* @__PURE__ */ defineComponent({
      name: "ElMessage"
    });
    const _sfc_main$7 = /* @__PURE__ */ defineComponent({
      ...__default__,
      props: messageProps,
      emits: messageEmits,
      setup(__props, { expose }) {
        const props = __props;
        const { Close } = TypeComponents;
        const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
        const { currentZIndex, nextZIndex } = zIndex2;
        const messageRef = ref();
        const visible = ref(false);
        const height = ref(0);
        let stopTimer = void 0;
        const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
        const typeClass = computed(() => {
          const type = props.type;
          return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
        });
        const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
        const lastOffset = computed(() => getLastOffset(props.id));
        const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
        const bottom = computed(() => height.value + offset.value);
        const customStyle = computed(() => ({
          top: `${offset.value}px`,
          zIndex: currentZIndex.value
        }));
        function startTimer() {
          if (props.duration === 0)
            return;
          ({ stop: stopTimer } = useTimeoutFn(() => {
            close();
          }, props.duration));
        }
        function clearTimer() {
          stopTimer == null ? void 0 : stopTimer();
        }
        function close() {
          visible.value = false;
        }
        function keydown({ code }) {
          if (code === EVENT_CODE.esc) {
            close();
          }
        }
        onMounted(() => {
          startTimer();
          nextZIndex();
          visible.value = true;
        });
        watch(() => props.repeatNum, () => {
          clearTimer();
          startTimer();
        });
        useEventListener(document, "keydown", keydown);
        useResizeObserver(messageRef, () => {
          height.value = messageRef.value.getBoundingClientRect().height;
        });
        expose({
          visible,
          bottom,
          close
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns).b("fade"),
            onBeforeLeave: _ctx.onClose,
            onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                id: _ctx.id,
                ref_key: "messageRef",
                ref: messageRef,
                class: normalizeClass([
                  unref(ns).b(),
                  { [unref(ns).m(_ctx.type)]: _ctx.type },
                  unref(ns).is("center", _ctx.center),
                  unref(ns).is("closable", _ctx.showClose),
                  _ctx.customClass
                ]),
                style: normalizeStyle(unref(customStyle)),
                role: "alert",
                onMouseenter: clearTimer,
                onMouseleave: startTimer
              }, [
                _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                  key: 0,
                  value: _ctx.repeatNum,
                  type: unref(badgeType),
                  class: normalizeClass(unref(ns).e("badge"))
                }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default", {}, () => [
                  !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("content"))
                  }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                    createBaseVNode("p", {
                      class: normalizeClass(unref(ns).e("content")),
                      innerHTML: _ctx.message
                    }, null, 10, _hoisted_2$3)
                  ], 2112))
                ]),
                _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass(unref(ns).e("closeBtn")),
                  onClick: withModifiers(close, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(Close))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 46, _hoisted_1$7), [
                [vShow, visible.value]
              ])
            ]),
            _: 3
          }, 8, ["name", "onBeforeLeave"]);
        };
      }
    });
    var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__file", "message.vue"]]);
    let seed = 1;
    const normalizeOptions = (params) => {
      const options = !params || isString$1(params) || isVNode(params) || isFunction$2(params) ? { message: params } : params;
      const normalized = {
        ...messageDefaults,
        ...options
      };
      if (!normalized.appendTo) {
        normalized.appendTo = document.body;
      } else if (isString$1(normalized.appendTo)) {
        let appendTo = document.querySelector(normalized.appendTo);
        if (!isElement(appendTo)) {
          appendTo = document.body;
        }
        normalized.appendTo = appendTo;
      }
      return normalized;
    };
    const closeMessage = (instance) => {
      const idx = instances.indexOf(instance);
      if (idx === -1)
        return;
      instances.splice(idx, 1);
      const { handler } = instance;
      handler.close();
    };
    const createMessage = ({ appendTo, ...options }, context) => {
      const id = `message_${seed++}`;
      const userOnClose = options.onClose;
      const container = document.createElement("div");
      const props = {
        ...options,
        id,
        onClose: () => {
          userOnClose == null ? void 0 : userOnClose();
          closeMessage(instance);
        },
        onDestroy: () => {
          render(null, container);
        }
      };
      const vnode = createVNode(MessageConstructor, props, isFunction$2(props.message) || isVNode(props.message) ? {
        default: isFunction$2(props.message) ? props.message : () => props.message
      } : null);
      vnode.appContext = context || message._context;
      render(vnode, container);
      appendTo.appendChild(container.firstElementChild);
      const vm = vnode.component;
      const handler = {
        close: () => {
          vm.exposed.visible.value = false;
        }
      };
      const instance = {
        id,
        vnode,
        vm,
        handler,
        props: vnode.component.props
      };
      return instance;
    };
    const message = (options = {}, context) => {
      if (!isClient)
        return { close: () => void 0 };
      if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
        return { close: () => void 0 };
      }
      const normalized = normalizeOptions(options);
      if (normalized.grouping && instances.length) {
        const instance2 = instances.find(({ vnode: vm }) => {
          var _a2;
          return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
        });
        if (instance2) {
          instance2.props.repeatNum += 1;
          instance2.props.type = normalized.type;
          return instance2.handler;
        }
      }
      const instance = createMessage(normalized, context);
      instances.push(instance);
      return instance.handler;
    };
    messageTypes.forEach((type) => {
      message[type] = (options = {}, appContext) => {
        const normalized = normalizeOptions(options);
        return message({ ...normalized, type }, appContext);
      };
    });
    function closeAll(type) {
      for (const instance of instances) {
        if (!type || type === instance.props.type) {
          instance.handler.close();
        }
      }
    }
    message.closeAll = closeAll;
    message._context = null;
    const ElMessage = withInstallFunction(message, "$message");
    const _sfc_main$6 = /* @__PURE__ */ defineComponent({
      name: "ElMessageBox",
      directives: {
        TrapFocus
      },
      components: {
        ElButton,
        ElFocusTrap,
        ElInput,
        ElOverlay,
        ElIcon,
        ...TypeComponents
      },
      inheritAttrs: false,
      props: {
        buttonSize: {
          type: String,
          validator: isValidComponentSize
        },
        modal: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        showClose: {
          type: Boolean,
          default: true
        },
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        closeOnHashChange: {
          type: Boolean,
          default: true
        },
        center: Boolean,
        draggable: Boolean,
        roundButton: {
          default: false,
          type: Boolean
        },
        container: {
          type: String,
          default: "body"
        },
        boxType: {
          type: String,
          default: ""
        }
      },
      emits: ["vanish", "action"],
      setup(props, { emit: emit2 }) {
        const {
          locale,
          zIndex: zIndex2,
          ns,
          size: btnSize
        } = useGlobalComponentSettings("message-box", computed(() => props.buttonSize));
        const { t } = locale;
        const { nextZIndex } = zIndex2;
        const visible = ref(false);
        const state = reactive({
          autofocus: true,
          beforeClose: null,
          callback: null,
          cancelButtonText: "",
          cancelButtonClass: "",
          confirmButtonText: "",
          confirmButtonClass: "",
          customClass: "",
          customStyle: {},
          dangerouslyUseHTMLString: false,
          distinguishCancelAndClose: false,
          icon: "",
          inputPattern: null,
          inputPlaceholder: "",
          inputType: "text",
          inputValue: null,
          inputValidator: null,
          inputErrorMessage: "",
          message: null,
          modalFade: true,
          modalClass: "",
          showCancelButton: false,
          showConfirmButton: true,
          type: "",
          title: void 0,
          showInput: false,
          action: "",
          confirmButtonLoading: false,
          cancelButtonLoading: false,
          confirmButtonDisabled: false,
          editorErrorMessage: "",
          validateError: false,
          zIndex: nextZIndex()
        });
        const typeClass = computed(() => {
          const type = state.type;
          return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
        });
        const contentId = useId();
        const inputId = useId();
        const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
        const hasMessage = computed(() => !!state.message);
        const rootRef = ref();
        const headerRef = ref();
        const focusStartRef = ref();
        const inputRef = ref();
        const confirmRef = ref();
        const confirmButtonClasses = computed(() => state.confirmButtonClass);
        watch(() => state.inputValue, async (val) => {
          await nextTick();
          if (props.boxType === "prompt" && val !== null) {
            validate();
          }
        }, { immediate: true });
        watch(() => visible.value, (val) => {
          var _a2, _b;
          if (val) {
            if (props.boxType !== "prompt") {
              if (state.autofocus) {
                focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
              } else {
                focusStartRef.value = rootRef.value;
              }
            }
            state.zIndex = nextZIndex();
          }
          if (props.boxType !== "prompt")
            return;
          if (val) {
            nextTick().then(() => {
              var _a22;
              if (inputRef.value && inputRef.value.$el) {
                if (state.autofocus) {
                  focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
            });
          } else {
            state.editorErrorMessage = "";
            state.validateError = false;
          }
        });
        const draggable = computed(() => props.draggable);
        useDraggable(rootRef, headerRef, draggable);
        onMounted(async () => {
          await nextTick();
          if (props.closeOnHashChange) {
            window.addEventListener("hashchange", doClose);
          }
        });
        onBeforeUnmount(() => {
          if (props.closeOnHashChange) {
            window.removeEventListener("hashchange", doClose);
          }
        });
        function doClose() {
          if (!visible.value)
            return;
          visible.value = false;
          nextTick(() => {
            if (state.action)
              emit2("action", state.action);
          });
        }
        const handleWrapperClick = () => {
          if (props.closeOnClickModal) {
            handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
          }
        };
        const overlayEvent = useSameTarget(handleWrapperClick);
        const handleInputEnter = (e) => {
          if (state.inputType !== "textarea") {
            e.preventDefault();
            return handleAction("confirm");
          }
        };
        const handleAction = (action) => {
          var _a2;
          if (props.boxType === "prompt" && action === "confirm" && !validate()) {
            return;
          }
          state.action = action;
          if (state.beforeClose) {
            (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
          } else {
            doClose();
          }
        };
        const validate = () => {
          if (props.boxType === "prompt") {
            const inputPattern = state.inputPattern;
            if (inputPattern && !inputPattern.test(state.inputValue || "")) {
              state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
              state.validateError = true;
              return false;
            }
            const inputValidator = state.inputValidator;
            if (typeof inputValidator === "function") {
              const validateResult = inputValidator(state.inputValue);
              if (validateResult === false) {
                state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              if (typeof validateResult === "string") {
                state.editorErrorMessage = validateResult;
                state.validateError = true;
                return false;
              }
            }
          }
          state.editorErrorMessage = "";
          state.validateError = false;
          return true;
        };
        const getInputElement = () => {
          const inputRefs = inputRef.value.$refs;
          return inputRefs.input || inputRefs.textarea;
        };
        const handleClose = () => {
          handleAction("close");
        };
        const onCloseRequested = () => {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        };
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        return {
          ...toRefs(state),
          ns,
          overlayEvent,
          visible,
          hasMessage,
          typeClass,
          contentId,
          inputId,
          btnSize,
          iconComponent,
          confirmButtonClasses,
          rootRef,
          focusStartRef,
          headerRef,
          inputRef,
          confirmRef,
          doClose,
          handleClose,
          onCloseRequested,
          handleWrapperClick,
          handleInputEnter,
          handleAction,
          t
        };
      }
    });
    const _hoisted_1$6 = ["aria-label", "aria-describedby"];
    const _hoisted_2$2 = ["aria-label"];
    const _hoisted_3$2 = ["id"];
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_icon = resolveComponent("el-icon");
      const _component_close = resolveComponent("close");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_button = resolveComponent("el-button");
      const _component_el_focus_trap = resolveComponent("el-focus-trap");
      const _component_el_overlay = resolveComponent("el-overlay");
      return openBlock(), createBlock(Transition, {
        name: "fade-in-linear",
        onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createVNode(_component_el_overlay, {
            "z-index": _ctx.zIndex,
            "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
            mask: _ctx.modal
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                role: "dialog",
                "aria-label": _ctx.title,
                "aria-modal": "true",
                "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
                onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
                onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
              }, [
                createVNode(_component_el_focus_trap, {
                  loop: "",
                  trapped: _ctx.visible,
                  "focus-trap-el": _ctx.rootRef,
                  "focus-start-el": _ctx.focusStartRef,
                  onReleaseRequested: _ctx.onCloseRequested
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      ref: "rootRef",
                      class: normalizeClass([
                        _ctx.ns.b(),
                        _ctx.customClass,
                        _ctx.ns.is("draggable", _ctx.draggable),
                        { [_ctx.ns.m("center")]: _ctx.center }
                      ]),
                      style: normalizeStyle(_ctx.customStyle),
                      tabindex: "-1",
                      onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        ref: "headerRef",
                        class: normalizeClass(_ctx.ns.e("header"))
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("title"))
                        }, [
                          _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                            key: 0,
                            class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true),
                          createBaseVNode("span", null, toDisplayString(_ctx.title), 1)
                        ], 2),
                        _ctx.showClose ? (openBlock(), createElementBlock("button", {
                          key: 0,
                          type: "button",
                          class: normalizeClass(_ctx.ns.e("headerbtn")),
                          "aria-label": _ctx.t("el.messagebox.close"),
                          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                          onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                        }, [
                          createVNode(_component_el_icon, {
                            class: normalizeClass(_ctx.ns.e("close"))
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_close)
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 42, _hoisted_2$2)) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      createBaseVNode("div", {
                        id: _ctx.contentId,
                        class: normalizeClass(_ctx.ns.e("content"))
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("container"))
                        }, [
                          _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                            key: 0,
                            class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true),
                          _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                            key: 1,
                            class: normalizeClass(_ctx.ns.e("message"))
                          }, [
                            renderSlot(_ctx.$slots, "default", {}, () => [
                              !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                key: 0,
                                for: _ctx.showInput ? _ctx.inputId : void 0
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                ]),
                                _: 1
                              }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                key: 1,
                                for: _ctx.showInput ? _ctx.inputId : void 0,
                                innerHTML: _ctx.message
                              }, null, 8, ["for", "innerHTML"]))
                            ])
                          ], 2)) : createCommentVNode("v-if", true)
                        ], 2),
                        withDirectives(createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("input"))
                        }, [
                          createVNode(_component_el_input, {
                            id: _ctx.inputId,
                            ref: "inputRef",
                            modelValue: _ctx.inputValue,
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                            type: _ctx.inputType,
                            placeholder: _ctx.inputPlaceholder,
                            "aria-invalid": _ctx.validateError,
                            class: normalizeClass({ invalid: _ctx.validateError }),
                            onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                          }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("errormsg")),
                            style: normalizeStyle({
                              visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                            })
                          }, toDisplayString(_ctx.editorErrorMessage), 7)
                        ], 2), [
                          [vShow, _ctx.showInput]
                        ])
                      ], 10, _hoisted_3$2),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.ns.e("btns"))
                      }, [
                        _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                          key: 0,
                          loading: _ctx.cancelButtonLoading,
                          class: normalizeClass([_ctx.cancelButtonClass]),
                          round: _ctx.roundButton,
                          size: _ctx.btnSize,
                          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                          onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                          ]),
                          _: 1
                        }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                        withDirectives(createVNode(_component_el_button, {
                          ref: "confirmRef",
                          type: "primary",
                          loading: _ctx.confirmButtonLoading,
                          class: normalizeClass([_ctx.confirmButtonClasses]),
                          round: _ctx.roundButton,
                          disabled: _ctx.confirmButtonDisabled,
                          size: _ctx.btnSize,
                          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                          ]),
                          _: 1
                        }, 8, ["loading", "class", "round", "disabled", "size"]), [
                          [vShow, _ctx.showConfirmButton]
                        ])
                      ], 2)
                    ], 6)
                  ]),
                  _: 3
                }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
              ], 42, _hoisted_1$6)
            ]),
            _: 3
          }, 8, ["z-index", "overlay-class", "mask"]), [
            [vShow, _ctx.visible]
          ])
        ]),
        _: 3
      });
    }
    var MessageBoxConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render], ["__file", "index.vue"]]);
    const messageInstance = /* @__PURE__ */ new Map();
    const getAppendToElement = (props) => {
      let appendTo = document.body;
      if (props.appendTo) {
        if (isString$1(props.appendTo)) {
          appendTo = document.querySelector(props.appendTo);
        }
        if (isElement(props.appendTo)) {
          appendTo = props.appendTo;
        }
        if (!isElement(appendTo)) {
          appendTo = document.body;
        }
      }
      return appendTo;
    };
    const initInstance = (props, container, appContext = null) => {
      const vnode = createVNode(MessageBoxConstructor, props, isFunction$2(props.message) || isVNode(props.message) ? {
        default: isFunction$2(props.message) ? props.message : () => props.message
      } : null);
      vnode.appContext = appContext;
      render(vnode, container);
      getAppendToElement(props).appendChild(container.firstElementChild);
      return vnode.component;
    };
    const genContainer = () => {
      return document.createElement("div");
    };
    const showMessage = (options, appContext) => {
      const container = genContainer();
      options.onVanish = () => {
        render(null, container);
        messageInstance.delete(vm);
      };
      options.onAction = (action) => {
        const currentMsg = messageInstance.get(vm);
        let resolve2;
        if (options.showInput) {
          resolve2 = { value: vm.inputValue, action };
        } else {
          resolve2 = action;
        }
        if (options.callback) {
          options.callback(resolve2, instance.proxy);
        } else {
          if (action === "cancel" || action === "close") {
            if (options.distinguishCancelAndClose && action !== "cancel") {
              currentMsg.reject("close");
            } else {
              currentMsg.reject("cancel");
            }
          } else {
            currentMsg.resolve(resolve2);
          }
        }
      };
      const instance = initInstance(options, container, appContext);
      const vm = instance.proxy;
      for (const prop in options) {
        if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
          vm[prop] = options[prop];
        }
      }
      vm.visible = true;
      return vm;
    };
    function MessageBox(options, appContext = null) {
      if (!isClient)
        return Promise.reject();
      let callback;
      if (isString$1(options) || isVNode(options)) {
        options = {
          message: options
        };
      } else {
        callback = options.callback;
      }
      return new Promise((resolve2, reject) => {
        const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
        messageInstance.set(vm, {
          options,
          callback,
          resolve: resolve2,
          reject
        });
      });
    }
    const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
    const MESSAGE_BOX_DEFAULT_OPTS = {
      alert: { closeOnPressEscape: false, closeOnClickModal: false },
      confirm: { showCancelButton: true },
      prompt: { showCancelButton: true, showInput: true }
    };
    MESSAGE_BOX_VARIANTS.forEach((boxType) => {
      MessageBox[boxType] = messageBoxFactory(boxType);
    });
    function messageBoxFactory(boxType) {
      return (message2, title, options, appContext) => {
        let titleOrOpts = "";
        if (isObject$1(title)) {
          options = title;
          titleOrOpts = "";
        } else if (isUndefined(title)) {
          titleOrOpts = "";
        } else {
          titleOrOpts = title;
        }
        return MessageBox(Object.assign({
          title: titleOrOpts,
          message: message2,
          type: "",
          ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
        }, options, {
          boxType
        }), appContext);
      };
    }
    MessageBox.close = () => {
      messageInstance.forEach((_2, vm) => {
        vm.doClose();
      });
      messageInstance.clear();
    };
    MessageBox._context = null;
    const _MessageBox = MessageBox;
    _MessageBox.install = (app2) => {
      _MessageBox._context = app2._context;
      app2.config.globalProperties.$msgbox = _MessageBox;
      app2.config.globalProperties.$messageBox = _MessageBox;
      app2.config.globalProperties.$alert = _MessageBox.alert;
      app2.config.globalProperties.$confirm = _MessageBox.confirm;
      app2.config.globalProperties.$prompt = _MessageBox.prompt;
    };
    const ElMessageBox = _MessageBox;
    function showWarmDialog(title, ok, cancel) {
      ElMessageBox.confirm(title, "Warning", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning"
      }).then(() => {
        ok();
      }).catch(() => {
        cancel();
      });
    }
    function showErrorTips(message2) {
      ElMessage({
        showClose: true,
        message: message2,
        type: "error"
      });
    }
    function showTips(code, message2) {
      if (code === 0) {
        showSucessTips(message2);
      } else {
        showWarmTips(message2);
      }
    }
    function showSucessTips(message2) {
      ElMessage({
        showClose: true,
        message: message2,
        type: "success"
      });
    }
    function showWarmTips(message2) {
      ElMessage({
        showClose: true,
        message: message2,
        type: "warning"
      });
    }
    function xhrPromise(config) {
      return new Promise((resolve2, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open(config.method || "GET", config.url);
        if (config.headers) {
          Object.entries(config.headers).forEach(([key, value]) => {
            xhr.setRequestHeader(key, value);
          });
        }
        if (config.responseType) {
          xhr.responseType = config.responseType;
        }
        if (config.timeout) {
          xhr.timeout = config.timeout;
        }
        if (config.onUploadProgress) {
          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const percentComplete = event.loaded / event.total * 100;
              console.log("--->", percentComplete + "%");
              config.onUploadProgress(percentComplete.toFixed(2));
            }
          };
        }
        if (config.onDownloadProgress) {
          xhr.onprogress = (e) => {
            config.onDownloadProgress({
              loaded: e.loaded,
              total: e.total,
              progress: e.loaded / e.total
            });
          };
        }
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve2({
              data: xhr.response,
              status: xhr.status,
              statusText: xhr.statusText,
              headers: xhr.getAllResponseHeaders()
            });
          } else {
            reject(new Error(`请求失败：${xhr.status} ${xhr.statusText}`));
          }
        };
        xhr.onerror = () => reject(new Error("网络错误"));
        xhr.ontimeout = () => reject(new Error(`请求超时（${config.timeout}ms）`));
        xhr.onabort = () => reject(new Error("请求被中止"));
        try {
          xhr.send(config.data);
        } catch (err) {
          reject(err);
        }
      });
    }
    function isMobile() {
      if (isMobileWidth() || isMobilePhone()) {
        return true;
      }
      return false;
    }
    function isMobileWidth() {
      if (window.innerWidth >= 992) {
        return false;
      }
      return true;
    }
    function isMobilePhone() {
      const ua = navigator.userAgent.toLowerCase();
      return !!ua.match(/iOS|iPhone|Android|windows Phone|BB\d+/i);
    }
    function showLoading(title) {
      return ElLoading.service({
        lock: true,
        text: title,
        background: "rgba(0, 0, 0, 0.7)"
      });
    }
    function markdownToHtml(markdown) {
      let lines = markdown.split("\n");
      let html = "";
      let inList = false;
      let listItems = [];
      let inCodeBlock = false;
      let codeBlockContent = "";
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        if (line.startsWith("```")) {
          if (inCodeBlock) {
            html += `<pre><code>${codeBlockContent}</code></pre>`;
            inCodeBlock = false;
            codeBlockContent = "";
          } else {
            inCodeBlock = true;
          }
          continue;
        }
        if (inCodeBlock) {
          codeBlockContent += line + "\n";
          continue;
        }
        if (/^(#+) (.*)$/.test(line)) {
          let [, hashes, content] = line.match(/^(#+) (.*)$/);
          let level = hashes.length;
          if (inList) {
            html += `<ul>${listItems.join("")}</ul>`;
            inList = false;
            listItems = [];
          }
          html += `<h${level}>${content}</h${level}>`;
        } else if (/^([*-]) (.*)$/.test(line)) {
          let [, , content] = line.match(/^([*-]) (.*)$/);
          if (!inList) {
            inList = true;
          }
          listItems.push(`<li>${content}</li>`);
        } else {
          if (inList) {
            html += `<ul>${listItems.join("")}</ul>`;
            inList = false;
            listItems = [];
          }
          if (line) {
            html += `<p>${line}</p>`;
          }
        }
      }
      if (inList) {
        html += `<ul>${listItems.join("")}</ul>`;
      }
      if (inCodeBlock) {
        html += `<pre><code>${codeBlockContent}</code></pre>`;
      }
      html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
      html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
      return html;
    }
    function formatTimeStamp(timestamp) {
      const date = new Date(timestamp * 1e3);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
    function formatToUTC8(timestamp) {
      const date = new Date(timestamp * 1e3);
      date.setHours(date.getHours() - 8);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
    const _hoisted_1$5 = { class: "upgrade-popup-content" };
    const _sfc_main$5 = /* @__PURE__ */ defineComponent({
      __name: "ClientTimeLineDialog",
      setup(__props, { expose: __expose }) {
        const showClientDialog = ref(false);
        const title = ref();
        const activities = ref([]);
        function fetchData(mac) {
          fetch(`../api/get/status?mac=${mac}`, {
            credentials: "include",
            method: "GET"
          }).then((res) => res.json()).then((json) => {
            console.log("get/status", json);
            if (json && json.code === 0 && json.data) {
              console.log(json);
              showClientDialog.value = true;
              activities.value = json.data;
            } else {
              showTips(json.code, json.msg);
            }
          }).catch(() => {
            showErrorTips("获取失败");
          });
        }
        function getTitle(row) {
          if (row.nickName != "") {
            return row.nickName;
          } else {
            return row.hostname;
          }
        }
        const openClientDetailDialog = (row) => {
          console.log("打开对话框，row:", row);
          title.value = `${getTitle(row)}状态时间表`;
          fetchData(row.mac);
        };
        __expose({
          openClientDialog: openClientDetailDialog
        });
        return (_ctx, _cache) => {
          const _component_el_timeline_item = ElTimelineItem;
          const _component_el_timeline = ElTimeline;
          const _component_el_dialog = ElDialog;
          return openBlock(), createBlock(_component_el_dialog, {
            modal: true,
            "close-on-click-modal": true,
            "close-on-press-escape": true,
            width: unref(isMobile)() ? "80%" : "30%",
            modelValue: showClientDialog.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showClientDialog.value = $event),
            title: title.value
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$5, [
                createVNode(_component_el_timeline, { style: { "max-width": "200px" } }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(activities.value, (activity, index) => {
                      return openBlock(), createBlock(_component_el_timeline_item, {
                        key: index,
                        color: activity.connected ? "#55f604" : "red",
                        hollow: false,
                        timestamp: unref(formatToUTC8)(activity.timestamp)
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", {
                            style: normalizeStyle({ color: activity.connected ? "#55f604" : "red" })
                          }, toDisplayString(activity.connected ? "在线" : "离线") + "-" + toDisplayString(activities.value.length - index), 5)
                        ]),
                        _: 2
                      }, 1032, ["color", "timestamp"]);
                    }), 128))
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 8, ["width", "modelValue", "title"]);
        };
      }
    });
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const ClientTimeLineDialog = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-0cb1f3d2"]]);
    class SimpleSSEClient {
      constructor(url) {
        __publicField(this, "eventSource", null);
        __publicField(this, "retryCount", 0);
        __publicField(this, "maxRetries", 3);
        __publicField(this, "retryInterval", 5e3);
        __publicField(this, "onOpenFunction", null);
        __publicField(this, "onErrorFunction", null);
        this.url = url;
      }
      connect() {
        if (this.eventSource) {
          this.close();
        }
        this.eventSource = new EventSource(this.url);
        this.eventSource.onopen = () => {
          this.retryCount = 0;
          console.log("SSE连接成功", this.retryCount);
          if (this.onOpenFunction) {
            this.onOpenFunction();
          }
        };
        this.eventSource.onmessage = (e) => {
          try {
            const parsedData = JSON.parse(e.data);
            this.handleMessage(parsedData);
          } catch (err) {
            console.error("数据解析失败:", err);
          }
        };
        this.eventSource.onerror = (e) => {
          console.log("SSE连接错误:", e);
          if (this.onErrorFunction) {
            this.onErrorFunction();
          }
          if (this.retryCount >= this.maxRetries) {
            this.close();
            return;
          }
          setTimeout(() => {
            this.retryCount++;
            this.reconnect();
          }, this.retryInterval);
        };
      }
      setOnOpenFunction(f2) {
        this.onOpenFunction = f2;
      }
      setOnErrorFunction(f2) {
        this.onErrorFunction = f2;
      }
      handleMessage(data) {
        console.log("收到消息:", data);
      }
      reconnect() {
        this.close();
        this.connect();
      }
      close() {
        var _a2;
        (_a2 = this.eventSource) == null ? void 0 : _a2.close();
        this.eventSource = null;
      }
    }
    class EventAwareSSEClient extends SimpleSSEClient {
      constructor() {
        super(...arguments);
        __publicField(this, "handlers", {});
      }
      addEventListener(eventName, callback) {
        this.handlers[eventName] = callback;
      }
      handleMessage(data) {
        if (data.event && this.handlers[data.event]) {
          this.handlers[data.event](data.payload);
        } else {
          super.handleMessage(data);
        }
      }
    }
    const _hoisted_1$4 = { class: "main" };
    const _sfc_main$4 = /* @__PURE__ */ defineComponent({
      __name: "ViewExpand",
      props: {
        row: {}
      },
      setup(__props) {
        return (_ctx, _cache) => {
          const _component_el_form_item = ElFormItem;
          const _component_el_form = ElForm;
          return openBlock(), createElementBlock("div", _hoisted_1$4, [
            createVNode(_component_el_form, {
              "label-position": "left",
              "label-width": "auto"
            }, {
              default: withCtx(() => [
                createVNode(_component_el_form_item, { label: "昵称" }, {
                  default: withCtx(() => [
                    createBaseVNode("span", null, toDisplayString(_ctx.row.nickName), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_form_item, { label: "名称" }, {
                  default: withCtx(() => [
                    createBaseVNode("span", null, toDisplayString(_ctx.row.hostname), 1)
                  ]),
                  _: 1
                }),
                unref(isMobile)() ? (openBlock(), createBlock(_component_el_form_item, {
                  key: 0,
                  label: "Mac地址"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", null, toDisplayString(_ctx.row.mac), 1)
                  ]),
                  _: 1
                })) : createCommentVNode("", true),
                _ctx.row.phy !== "" ? (openBlock(), createBlock(_component_el_form_item, {
                  key: 1,
                  label: "网络接口"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", null, toDisplayString(_ctx.row.phy), 1)
                  ]),
                  _: 1
                })) : createCommentVNode("", true),
                unref(isMobile)() ? (openBlock(), createBlock(_component_el_form_item, {
                  key: 2,
                  label: "连接时间"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", null, toDisplayString(unref(formatTimeStamp)(_ctx.row.starTime)), 1)
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ]);
        };
      }
    });
    const _withScopeId = (n) => (pushScopeId("data-v-7edf2438"), n = n(), popScopeId(), n);
    const _hoisted_1$3 = {
      key: 0,
      class: "upgrade-popup-overlay"
    };
    const _hoisted_2$1 = { class: "upgrade-popup" };
    const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("h3", null, "❤️ 发现新版本", -1));
    const _hoisted_4$1 = ["innerHTML"];
    const _hoisted_5$1 = { class: "upgrade-popup-footer" };
    const _sfc_main$3 = /* @__PURE__ */ defineComponent({
      __name: "UpgradeDialog",
      setup(__props, { expose: __expose }) {
        const showUpgradeDialog = ref(false);
        const binUrl = ref();
        const updateContent = ref();
        const patchUrl = ref();
        const showUpdateDialog = (patchurl, binurl, message2) => {
          showUpgradeDialog.value = true;
          updateContent.value = markdownToHtml(message2);
          binUrl.value = binurl;
          patchUrl.value = patchurl;
          console.log("binUrl", binUrl);
          console.log("patchUrl", patchurl);
        };
        const upgradeByUrl = (binurl) => {
          console.log("binurl", binurl);
          console.log("patchUrl", patchUrl.value);
          console.log("binUrl", binUrl.value);
          const loading = showLoading("程序升级中...");
          fetch("../api/upgrade", {
            credentials: "include",
            method: "PUT",
            body: binurl
          }).then((res) => {
            return res.json();
          }).then((json) => {
            showTips(json.code, json.msg);
            if (json.code === 0) {
              setTimeout(function() {
                window.location.reload();
              }, 1e3);
            }
          }).catch((error) => {
            console.log("更新失败", error);
          }).finally(() => {
            loading.close();
          });
        };
        const checkVersion = () => {
          fetch("../api/checkversion", { credentials: "include" }).then((res) => {
            return res.json();
          }).then((json) => {
            if (json.code === 0) {
              showUpdateDialog(
                json.data.patchUrl,
                json.data.fullUrl,
                json.data.releaseNotes
              );
            } else {
              showSucessTips(json.msg);
            }
          });
        };
        __expose({
          openUpgradeDialog: checkVersion
        });
        const handleConfirm = () => {
          showUpgradeDialog.value = false;
          if (patchUrl.value !== "") {
            upgradeByUrl(patchUrl.value);
          } else {
            upgradeByUrl(binUrl.value);
          }
        };
        const handleClose = () => {
          showUpgradeDialog.value = false;
          console.log("handleClose", showUpgradeDialog.value);
        };
        return (_ctx, _cache) => {
          const _component_el_button = ElButton;
          return openBlock(), createElementBlock("div", null, [
            showUpgradeDialog.value ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
              createBaseVNode("div", _hoisted_2$1, [
                createBaseVNode("div", { class: "upgrade-popup-header" }, [
                  _hoisted_3$1,
                  createBaseVNode("button", {
                    onClick: handleClose,
                    class: "close-button"
                  }, "×")
                ]),
                createBaseVNode("div", {
                  class: "upgrade-popup-content",
                  innerHTML: updateContent.value
                }, null, 8, _hoisted_4$1),
                createBaseVNode("div", _hoisted_5$1, [
                  createVNode(_component_el_button, { onClick: handleClose }, {
                    default: withCtx(() => [
                      createTextVNode("稍后提醒")
                    ]),
                    _: 1
                  }),
                  patchUrl.value !== "" ? (openBlock(), createBlock(_component_el_button, {
                    key: 0,
                    type: "warning",
                    onClick: handleConfirm
                  }, {
                    default: withCtx(() => [
                      createTextVNode("差量升级 ")
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: handleConfirm
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(patchUrl.value === "" ? "升级" : "全量升级"), 1)
                    ]),
                    _: 1
                  })
                ])
              ])
            ])) : createCommentVNode("", true)
          ]);
        };
      }
    });
    const UpgradeDialog = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-7edf2438"]]);
    const _hoisted_1$2 = { class: "upgrade-popup-content" };
    const _sfc_main$2 = /* @__PURE__ */ defineComponent({
      __name: "ClientStaticIpSettingDialog",
      setup(__props, { expose: __expose }) {
        const formData = ref({
          show: false,
          loading: false,
          title: "",
          client: {
            hostname: "",
            ip: "",
            mac: ""
          }
        });
        function handleConfirm() {
          formData.value.loading = true;
          fetch(`../api/staticip/set`, {
            credentials: "include",
            method: "POST",
            body: JSON.stringify(formData.value.client)
          }).then((res) => res.json()).then((json) => {
            console.log("static ip setting", json);
            if (json && json.code === 0) {
              showSucessTips(json.msg);
            } else {
              showTips(json.code, json.msg);
            }
          }).catch((error) => {
            console.log(error);
            showErrorTips(`获取失败${JSON.stringify(error)}`);
          }).finally(() => {
            formData.value.loading = false;
            setTimeout(function() {
              formData.value.show = false;
            }, 500);
          });
        }
        const showDialogForm = (row) => {
          console.log("打开对话框，row:", row);
          formData.value.title = `客户端【${row.hostname}】设置静态IP`;
          formData.value.client = JSON.parse(JSON.stringify(row));
          formData.value.show = true;
        };
        __expose({
          showDialogForm
        });
        return (_ctx, _cache) => {
          const _component_el_input = ElInput;
          const _component_el_form_item = ElFormItem;
          const _component_el_form = ElForm;
          const _component_el_button = ElButton;
          const _component_el_dialog = ElDialog;
          return openBlock(), createBlock(_component_el_dialog, {
            modal: true,
            "close-on-click-modal": true,
            "close-on-press-escape": true,
            width: unref(isMobile)() ? "80%" : "30%",
            modelValue: formData.value.show,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.show = $event),
            title: formData.value.title
          }, {
            footer: withCtx(() => [
              createVNode(_component_el_button, {
                type: "primary",
                loading: formData.value.loading,
                "loading-icon": unref(eleme_default),
                onClick: handleConfirm
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(formData.value.loading ? "静态地址设置中..." : "确定"), 1)
                ]),
                _: 1
              }, 8, ["loading", "loading-icon"])
            ]),
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$2, [
                createVNode(_component_el_form, { "label-width": "130px" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form_item, { label: "设备名称：" }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: formData.value.client.hostname,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => formData.value.client.hostname = $event),
                          placeholder: "请输入设备名称"
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, { label: "设备Mac：" }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: formData.value.client.mac,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.client.mac = $event),
                          placeholder: "请输入设备Mac地址"
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, { label: "设备IP：" }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: formData.value.client.ip,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.client.ip = $event),
                          placeholder: "请输入设备IP"
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 8, ["width", "modelValue", "title"]);
        };
      }
    });
    const ClientStaticIpSettingDialog = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-ea7edc26"]]);
    const _hoisted_1$1 = { class: "upgrade-popup-content" };
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "StaticIpListDialog",
      setup(__props, { expose: __expose }) {
        const searchKeyword = ref("");
        const pageSize = ref(50);
        const currentPage = ref(1);
        const tableData = ref([]);
        const paginatedTableData = computed(() => {
          const start = (currentPage.value - 1) * pageSize.value;
          const end = start + pageSize.value;
          return filteredTableData.value.slice(start, end);
        });
        const filteredTableData = computed(() => {
          return tableData.value.filter(() => !searchKeyword.value);
        });
        const handlePageChange = (page) => {
          currentPage.value = page;
        };
        function renderTable(data) {
          tableData.value = data;
        }
        const formData = ref({
          show: false,
          loading: false,
          title: "",
          client: {
            hostname: "",
            ip: "",
            mac: ""
          }
        });
        function refreshList() {
          const loadings = showLoading("静态IP列表请求中...");
          fetch(`../api/staticip/list`, {
            credentials: "include",
            method: "GET"
          }).then((res) => res.json()).then((json) => {
            console.log("静态IP列表", json);
            if (json && json.code === 0) {
              console.log(json);
              if (json.data) {
                renderTable(json.data);
              }
            }
            showTips(json.code, json.msg);
          }).catch((error) => {
            console.log("error", error);
            showErrorTips(`获取失败${JSON.stringify(error)}`);
          }).finally(() => {
            loadings.close();
          });
        }
        function handleDelete(row) {
          console.log(row);
          const loader = showLoading("删除中...");
          fetch(`../api/staticip/delete?mac=${row.mac}`, {
            credentials: "include",
            method: "DELETE"
          }).then((res) => {
            return res.json();
          }).then((json) => {
            console.log("handleDeleteStaticIp", json);
            showTips(json.code, json.msg);
          }).catch((error) => {
            console.log("error", error);
            showErrorTips("删除失败");
          }).finally(() => {
            loader.close();
            refreshList();
          });
        }
        const showDialogForm = (list) => {
          console.log("打开对话框，row:");
          formData.value.title = `静态IP列表`;
          formData.value.show = true;
          renderTable(list);
        };
        __expose({
          showDialogForm
        });
        return (_ctx, _cache) => {
          const _component_el_table_column = ElTableColumn;
          const _component_el_button = ElButton;
          const _component_el_table = ElTable;
          const _component_el_pagination = ElPagination;
          const _component_el_main = ElMain;
          const _component_el_dialog = ElDialog;
          return openBlock(), createBlock(_component_el_dialog, {
            modal: true,
            "close-on-click-modal": true,
            "close-on-press-escape": true,
            width: unref(isMobile)() ? "80%" : "80%",
            modelValue: formData.value.show,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => formData.value.show = $event),
            title: formData.value.title
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$1, [
                createBaseVNode("section", null, [
                  createVNode(_component_el_main, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_table, {
                        data: paginatedTableData.value,
                        style: { "width": "100%" },
                        border: true,
                        "preserve-expanded-content": true
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_table_column, {
                            prop: "index",
                            label: "索引",
                            sortable: ""
                          }),
                          createVNode(_component_el_table_column, {
                            prop: "hostname",
                            label: "名称",
                            sortable: ""
                          }),
                          createVNode(_component_el_table_column, {
                            prop: "ip",
                            label: "IP",
                            sortable: ""
                          }),
                          !unref(isMobile)() ? (openBlock(), createBlock(_component_el_table_column, {
                            key: 0,
                            prop: "mac",
                            label: "Mac地址",
                            sortable: ""
                          })) : createCommentVNode("", true),
                          createVNode(_component_el_table_column, { label: "操作" }, {
                            default: withCtx(({ row }) => [
                              createVNode(_component_el_button, {
                                size: "small",
                                type: "text",
                                onClick: ($event) => handleDelete(row)
                              }, {
                                default: withCtx(() => [
                                  createTextVNode("删除 ")
                                ]),
                                _: 2
                              }, 1032, ["onClick"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["data"]),
                      createVNode(_component_el_pagination, {
                        style: { "margin-top": "20px" },
                        background: "",
                        layout: "prev, pager, next",
                        total: filteredTableData.value.length,
                        "page-size": pageSize.value,
                        "current-page": currentPage.value,
                        "pager-count": 7,
                        onCurrentChange: handlePageChange
                      }, null, 8, ["total", "page-size", "current-page"])
                    ]),
                    _: 1
                  })
                ])
              ])
            ]),
            _: 1
          }, 8, ["width", "modelValue", "title"]);
        };
      }
    });
    const StaticIpListDialog = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-a32c5265"]]);
    const _hoisted_1 = { id: "app" };
    const _hoisted_2 = { class: "grid-content header-color" };
    const _hoisted_3 = { class: "header-content" };
    const _hoisted_4 = { class: "brand" };
    const _hoisted_5 = { href: "#" };
    const _hoisted_6 = { class: "dark-switch" };
    const _hoisted_7 = /* @__PURE__ */ createBaseVNode("footer", null, null, -1);
    const _hoisted_8 = /* @__PURE__ */ createBaseVNode("span", null, "程序升级", -1);
    const _hoisted_9 = { class: "dialog-footer" };
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        const title = ref("客户端列表");
        const clientTimeLineDialogRef = ref(null);
        const clientStaticIpDialogRef = ref(null);
        const staticIpListDialogRef = ref(null);
        const manusForm = ref({
          show: false,
          binUrl: ""
        });
        const customColors = [
          { color: "#f56c6c", percentage: 20 },
          { color: "#e6a23c", percentage: 40 },
          { color: "#5cb87a", percentage: 60 },
          { color: "#1989fa", percentage: 80 },
          { color: "#6f7ad3", percentage: 100 }
        ];
        const appinfo = ref();
        const globalProgress = ref(0);
        const isDark = useDark();
        const darkmodeSwitch = ref(isDark);
        const toggleDark = useToggle(isDark);
        const source = ref();
        const searchKeyword = ref("");
        const pageSize = ref(50);
        const currentPage = ref(1);
        const tableData = ref([]);
        const paginatedTableData = computed(() => {
          const start = (currentPage.value - 1) * pageSize.value;
          const end = start + pageSize.value;
          return filteredTableData.value.slice(start, end);
        });
        const filteredTableData = computed(() => {
          return tableData.value.filter(() => !searchKeyword.value);
        });
        function renderTable(data) {
          tableData.value = data;
        }
        function getClientName(row) {
          if (row.nickName === "") {
            return row.hostname;
          } else {
            return row.nickName;
          }
        }
        const getVersion = () => {
          fetch("../api/version", { credentials: "include", method: "GET" }).then((res) => {
            return res.json();
          }).then((json) => {
            if (json && json.code === 0 && json.data) {
              appinfo.value = json.data;
              if (json.data && json.data.appVersion) {
                title.value = `客户端列表 ${json.data.appVersion}`;
              }
            }
          }).catch(() => {
            showErrorTips("失败");
          });
        };
        const upgradeRef = ref(null);
        const handleShowCheckVersionDialog = () => {
          if (upgradeRef.value) {
            upgradeRef.value.openUpgradeDialog();
          }
        };
        const handleUploadUpgradeBin = (options) => {
          const { file } = options;
          const formData = new FormData();
          formData.append("file", file);
          const loading = showLoading("程序更新中...");
          globalProgress.value = 0;
          manusForm.value.show = false;
          xhrPromise({
            url: "../api/upgrade",
            method: "POST",
            data: formData,
            onUploadProgress: (progress) => {
              console.log(`上传进度：${progress}`);
              loading.setText(`程序更新中...${progress}%`);
              globalProgress.value = parseInt(progress);
            }
          }).then((data) => {
            console.log("请求成功", data);
            const json = JSON.parse(data.data);
            if (json.code !== 0) {
              if (json.msg !== "") {
                showErrorTips(json.msg);
              }
            } else {
              if (json.msg !== "") {
                showSucessTips(json.msg);
              }
            }
          }).catch((error) => {
            console.error("请求失败", error);
          }).finally(() => {
            setTimeout(function() {
              loading.close();
              globalProgress.value = 0;
              manusForm.value.show = false;
              window.location.reload();
            }, 4e3);
          });
        };
        const handleUpdate = () => {
          if (manusForm.value.binUrl.length > 0) {
            const binUrl = manusForm.value.binUrl;
            console.log("upgradeByUrl", binUrl);
            const loading = showLoading("程序升级中...");
            manusForm.value.show = false;
            fetch("../api/upgrade", {
              credentials: "include",
              method: "PUT",
              body: binUrl
            }).then((res) => {
              return res.json();
            }).then((json) => {
              showTips(json.code, json.msg);
            }).catch(() => {
              showWarmTips("更新失败");
            }).finally(() => {
              setTimeout(function() {
                loading.close();
                window.location.reload();
              }, 4e3);
            });
          } else {
            showWarmTips("请正确输入url地址");
          }
        };
        const fetchData = () => {
          const timestamp = 1752266198;
          console.log("fetchData", formatToUTC8(timestamp));
          fetch(`../api/clients/get`, {
            credentials: "include",
            method: "GET"
          }).then((res) => res.json()).then((json) => {
            console.log("fetchData", json);
            if (json && json.code === 0 && json.data) {
              console.log(json);
              renderTable(json.data);
            }
          }).catch((error) => {
            console.error(error);
            showErrorTips(`${JSON.stringify(error)}`);
            renderTable(testData);
          });
        };
        const handleClearData = () => {
          showWarmDialog(
            `确定清空临时数据吗？`,
            () => {
              fetch("../api/clear", { credentials: "include", method: "DELETE" }).then((res) => {
                return res.json();
              }).then((json) => {
                showTips(json.code, json.msg);
              }).catch(() => {
                showErrorTips("清空失败");
              });
            },
            () => {
            }
          );
        };
        const handleDeleteStaticIp = (row) => {
          console.log("handleDeleteStaticIp", row);
          ElMessageBox.confirm(`确定删除【${row.hostname}】静态IP吗?`, "Warning", {
            confirmButtonText: "确定",
            cancelButtonText: "取消",
            type: "warning"
          }).then(() => {
            const loader = showLoading("删除中...");
            fetch(`../api/staticip/delete?mac=${row.mac}`, {
              credentials: "include",
              method: "DELETE"
            }).then((res) => {
              return res.json();
            }).then((json) => {
              console.log("handleDeleteStaticIp", json);
              showTips(json.code, json.msg);
            }).catch((error) => {
              console.log("error", error);
              showErrorTips("删除失败");
            }).finally(() => {
              loader.close();
            });
          }).catch(() => {
          });
        };
        const handleChangeNickName = (row) => {
          console.log("handleChangeNickName", row);
          ElMessageBox.prompt("请输入设备昵称", "修改昵称", {
            confirmButtonText: "确定",
            cancelButtonText: "取消",
            inputValue: row.nickName
          }).then(({ value }) => {
            row.nickName = value;
            fetch("../api/nick/set", {
              credentials: "include",
              method: "POST",
              body: JSON.stringify(row)
            }).then((res) => {
              return res.json();
            }).then((json) => {
              console.log("handleChangeNickName", json);
              showTips(json.code, json.msg);
            }).catch((error) => {
              console.log("error", error);
              showErrorTips("修改昵称失败");
            });
          });
        };
        function handleResetClients() {
          console.log("handleResetClients");
          fetch(`../api/clients/reset`, {
            credentials: "include",
            method: "POST"
          }).then((res) => res.json()).then((json) => {
            console.log("重置列表", json);
            showTips(json.code, json.msg);
          }).catch((error) => {
            console.log("error", error);
            showErrorTips(`重置失败${JSON.stringify(error)}`);
          });
        }
        function handleAResetNetwork() {
          showWarmDialog(
            `确定重置网络吗？`,
            () => {
              fetch("../api/network/reset", { credentials: "include", method: "POST" }).then((res) => {
                return res.json();
              }).then((json) => {
                showTips(json.code, json.msg);
              }).catch((error) => {
                console.log("error", error);
                showErrorTips(`重置网络失败${JSON.stringify(error)}`);
              });
            },
            () => {
            }
          );
        }
        function handleShowStaticIpListDialog() {
          console.log("查看静态IP列表");
          const loadings = showLoading("静态IP列表请求中...");
          fetch(`../api/staticip/list`, {
            credentials: "include",
            method: "GET"
          }).then((res) => res.json()).then((json) => {
            console.log("静态IP列表", json);
            if (json && json.code === 0) {
              console.log(json);
              if (staticIpListDialogRef.value && json.data) {
                staticIpListDialogRef.value.showDialogForm(json.data);
              }
            }
            showTips(json.code, json.msg);
          }).catch((error) => {
            console.log("error", error);
            showErrorTips(`获取失败${JSON.stringify(error)}`);
          }).finally(() => {
            loadings.close();
          });
        }
        const handleShowStaitcIpDialog = (row) => {
          console.log("handleShowStaitcIpDialog", row);
          if (clientStaticIpDialogRef.value) {
            clientStaticIpDialogRef.value.showDialogForm(row);
          }
        };
        const handleGoToTimeLineDialog = (row) => {
          console.log("handleGoToTimeLineDialog", row);
          if (clientTimeLineDialogRef.value) {
            clientTimeLineDialogRef.value.openClientDialog(row);
          }
        };
        const handlePageChange = (page) => {
          currentPage.value = page;
        };
        const mobileLayout = ref(false);
        const checkMobile = () => {
          mobileLayout.value = window.innerWidth < 768;
        };
        const dialogWidth = ref("500px");
        const updateDialogWidth = () => {
          checkMobile();
          dialogWidth.value = mobileLayout.value ? "90%" : "500px";
        };
        const connectSSE = () => {
          try {
            const sseUrl = `../api/client/sse`;
            console.log("connectSSE", sseUrl);
            source.value = new EventAwareSSEClient(sseUrl);
            source.value.addEventListener("update", (data) => {
              console.log("update", data);
              renderTable(data);
            });
            source.value.connect();
          } catch (e) {
            console.error("connectSSE err", e);
          }
        };
        const testData = [];
        onMounted(() => {
          window.addEventListener("resize", updateDialogWidth);
          updateDialogWidth();
        });
        onUnmounted(() => {
          window.removeEventListener("resize", updateDialogWidth);
        });
        getVersion();
        connectSSE();
        fetchData();
        return (_ctx, _cache) => {
          const _component_el_progress = ElProgress;
          const _component_el_dropdown_item = ElDropdownItem;
          const _component_el_dropdown_menu = ElDropdownMenu;
          const _component_el_dropdown = ElDropdown;
          const _component_el_switch = ElSwitch;
          const _component_el_table_column = ElTableColumn;
          const _component_el_text = ElText;
          const _component_el_tag = ElTag;
          const _component_el_button = ElButton;
          const _component_el_table = ElTable;
          const _component_el_pagination = ElPagination;
          const _component_el_main = ElMain;
          const _component_el_input = ElInput;
          const _component_el_upload = ElUpload;
          const _component_el_dialog = ElDialog;
          return openBlock(), createElementBlock(Fragment, null, [
            globalProgress.value > 0 && globalProgress.value < 100 ? (openBlock(), createBlock(_component_el_progress, {
              key: 0,
              percentage: globalProgress.value,
              "stroke-width": 2,
              "show-text": false,
              color: customColors,
              class: "global-progress-bar"
            }, null, 8, ["percentage"])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_1, [
              createBaseVNode("header", _hoisted_2, [
                createBaseVNode("div", _hoisted_3, [
                  createBaseVNode("div", _hoisted_4, [
                    createVNode(_component_el_dropdown, { trigger: "click" }, {
                      dropdown: withCtx(() => [
                        createVNode(_component_el_dropdown_menu, null, {
                          default: withCtx(() => [
                            createVNode(_component_el_dropdown_item, { onClick: handleShowCheckVersionDialog }, {
                              default: withCtx(() => [
                                createTextVNode("版本检测 ")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_dropdown_item, {
                              onClick: _cache[0] || (_cache[0] = ($event) => manusForm.value.show = true)
                            }, {
                              default: withCtx(() => [
                                createTextVNode("手动升级 ")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_dropdown_item, { onClick: handleClearData }, {
                              default: withCtx(() => [
                                createTextVNode("清空数据 ")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_dropdown_item, { onClick: handleResetClients }, {
                              default: withCtx(() => [
                                createTextVNode("重置列表 ")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_dropdown_item, { onClick: handleAResetNetwork }, {
                              default: withCtx(() => [
                                createTextVNode("重置网络 ")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_dropdown_item, { onClick: handleShowStaticIpListDialog }, {
                              default: withCtx(() => [
                                createTextVNode("静态列表 ")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createBaseVNode("a", _hoisted_5, toDisplayString(title.value), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  createBaseVNode("div", _hoisted_6, [
                    createVNode(_component_el_switch, {
                      modelValue: darkmodeSwitch.value,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => darkmodeSwitch.value = $event),
                      "inline-prompt": "",
                      "active-text": "Dark",
                      "inactive-text": "Light",
                      onChange: unref(toggleDark),
                      style: { "--el-switch-on-color": "#444452", "--el-switch-off-color": "#589ef8" }
                    }, null, 8, ["modelValue", "onChange"])
                  ])
                ])
              ]),
              createBaseVNode("section", null, [
                createVNode(_component_el_main, null, {
                  default: withCtx(() => [
                    createVNode(_component_el_table, {
                      data: paginatedTableData.value,
                      style: { "width": "100%" },
                      border: true,
                      "highlight-current-row": false,
                      "preserve-expanded-content": true
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_table_column, { type: "expand" }, {
                          default: withCtx((props) => [
                            createVNode(_sfc_main$4, {
                              row: props.row
                            }, null, 8, ["row"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_table_column, {
                          prop: "hostname",
                          label: "名称",
                          sortable: "",
                          "min-width": "130"
                        }, {
                          default: withCtx((scope) => [
                            createVNode(_component_el_text, {
                              type: scope.row.online ? "success" : "none"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(getClientName(scope.row)), 1)
                              ]),
                              _: 2
                            }, 1032, ["type"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_table_column, {
                          prop: "ip",
                          label: "IP",
                          sortable: "",
                          "min-width": "135"
                        }),
                        !unref(isMobile)() ? (openBlock(), createBlock(_component_el_table_column, {
                          key: 0,
                          prop: "mac",
                          label: "Mac地址",
                          sortable: ""
                        })) : createCommentVNode("", true),
                        !unref(isMobile)() ? (openBlock(), createBlock(_component_el_table_column, {
                          key: 1,
                          prop: "starTime",
                          label: "连接时间",
                          sortable: ""
                        }, {
                          default: withCtx((props) => [
                            createTextVNode(toDisplayString(unref(formatTimeStamp)(props.row.starTime)), 1)
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        createVNode(_component_el_table_column, {
                          prop: "online",
                          label: "状态",
                          sortable: "",
                          "min-width": "80",
                          align: "center"
                        }, {
                          default: withCtx((scope) => [
                            scope.row.online ? (openBlock(), createBlock(_component_el_tag, {
                              key: 0,
                              type: "success"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("在线")
                              ]),
                              _: 1
                            })) : (openBlock(), createBlock(_component_el_tag, {
                              key: 1,
                              type: "danger"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("离线")
                              ]),
                              _: 1
                            }))
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_table_column, {
                          label: "操作",
                          max: "80",
                          fixed: "right",
                          align: "center"
                        }, {
                          default: withCtx(({ row }) => [
                            createVNode(_component_el_dropdown, { trigger: "click" }, {
                              dropdown: withCtx(() => [
                                createVNode(_component_el_dropdown_menu, null, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_dropdown_item, {
                                      onClick: ($event) => handleShowStaitcIpDialog(row)
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode("设置静态IP ")
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"]),
                                    createVNode(_component_el_dropdown_item, {
                                      onClick: ($event) => handleDeleteStaticIp(row)
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode("删除静态IP ")
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"]),
                                    createVNode(_component_el_dropdown_item, {
                                      onClick: ($event) => handleChangeNickName(row)
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode("修改名称 ")
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"]),
                                    createVNode(_component_el_dropdown_item, {
                                      onClick: ($event) => handleGoToTimeLineDialog(row)
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode("时间表 ")
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              default: withCtx(() => [
                                createVNode(_component_el_button, { type: "text" }, {
                                  default: withCtx(() => [
                                    createTextVNode("菜单")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["data"]),
                    createVNode(_component_el_pagination, {
                      style: { "margin-top": "20px" },
                      background: "",
                      layout: "prev, pager, next",
                      total: filteredTableData.value.length,
                      "page-size": pageSize.value,
                      "current-page": currentPage.value,
                      "pager-count": mobileLayout.value ? 3 : 7,
                      onCurrentChange: handlePageChange
                    }, null, 8, ["total", "page-size", "current-page", "pager-count"])
                  ]),
                  _: 1
                })
              ]),
              _hoisted_7
            ]),
            createVNode(_component_el_dialog, {
              modelValue: manusForm.value.show,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => manusForm.value.show = $event),
              "align-center": "",
              width: "500"
            }, {
              header: withCtx(() => [
                _hoisted_8
              ]),
              footer: withCtx(() => [
                createBaseVNode("div", _hoisted_9, [
                  createVNode(_component_el_upload, {
                    class: "upload-demo",
                    "http-request": handleUploadUpgradeBin,
                    limit: 1
                  }, {
                    trigger: withCtx(() => [
                      createVNode(_component_el_button, {
                        type: "primary",
                        disabled: manusForm.value.binUrl.length > 0
                      }, {
                        default: withCtx(() => [
                          createTextVNode("上传文件升级 ")
                        ]),
                        _: 1
                      }, 8, ["disabled"])
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        style: { "margin-left": "10px" },
                        type: "danger",
                        onClick: handleUpdate
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" 文件url升级 ")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ])
              ]),
              default: withCtx(() => [
                createVNode(_component_el_input, {
                  modelValue: manusForm.value.binUrl,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => manusForm.value.binUrl = $event),
                  autocomplete: "off",
                  placeholder: "请输入程序Url地址～"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }, 8, ["modelValue"]),
            createVNode(StaticIpListDialog, {
              ref_key: "staticIpListDialogRef",
              ref: staticIpListDialogRef
            }, null, 512),
            createVNode(ClientStaticIpSettingDialog, {
              ref_key: "clientStaticIpDialogRef",
              ref: clientStaticIpDialogRef
            }, null, 512),
            createVNode(UpgradeDialog, {
              ref_key: "upgradeRef",
              ref: upgradeRef
            }, null, 512),
            createVNode(ClientTimeLineDialog, {
              ref_key: "clientTimeLineDialogRef",
              ref: clientTimeLineDialogRef
            }, null, 512)
          ], 64);
        };
      }
    });
    const app = createApp(_sfc_main);
    app.mount("#app");
  }
});
export default require_index_001();
//# sourceMappingURL=index--CdHuQtu.js.map
